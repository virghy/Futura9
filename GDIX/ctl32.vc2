*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="ctl32.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS ctl32_animation AS ctl32_controlbase OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "ctl32.h"
	Name = "ctl32_animation"
	ctlTextbox.Name = "ctlTextbox"
	lblname.Name = "lblname"

ENDDEFINE

DEFINE CLASS ctl32_balloontip AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="..\..\vfpp.backup\ctl32\ctl32_balloontip.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="tmrHide" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrShow" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlactive_assign
		*m: ctlalignment_assign
		*m: ctlbackcolor_assign
		*m: ctlcapslockstyle_assign
		*m: ctlclosebutton_assign
		*m: ctlfadein_assign
		*m: ctlfadeout_assign
		*m: ctlfontbold_assign
		*m: ctlfontcharset_assign
		*m: ctlfontitalic_assign
		*m: ctlfontname_assign
		*m: ctlfontsize_assign
		*m: ctlfontstrikethru_assign
		*m: ctlfontunderline_assign
		*m: ctlforecolor_assign
		*m: ctlhide
		*m: ctlhidedelay_assign
		*m: ctlhwnd_access
		*m: ctlhwnd_assign
		*m: ctliconlarge_assign
		*m: ctlicon_assign
		*m: ctllangid_assign
		*m: ctllink_access
		*m: ctlmakelink
		*m: ctlmarginbottom_assign
		*m: ctlmarginleft_assign
		*m: ctlmarginright_assign
		*m: ctlmargintop_assign
		*m: ctlmargin_assign
		*m: ctlmaxwidth_assign
		*m: ctlopenlink
		*m: ctlreset
		*m: ctlsavestate
		*m: ctlsetdefaultfont
		*m: ctlshow
		*m: ctlshowdelay_assign
		*m: ctlstyle_assign
		*m: ctltext_assign
		*m: ctltitle_assign
		*m: ctltrack
		*m: ctlvisible_assign
		*m: _addobjects
		*m: _addproperties
		*m: _bindevents
		*m: _create
		*m: _eventhandlerformmoved
		*m: _eventhandlerformresize
		*m: _eventhandlerscreenmoved
		*m: _getfontdefault
		*m: _gettrackposparam
		*m: _messagehandlerformwm_keydown
		*m: _messagehandlerhostwm_lbuttondown
		*m: _messagehandlerhostwm_notify
		*m: _propertyhandlerformwmnotifymsg
		*m: _setfont
		*m: _seticonandtitle
		*m: _setlocalestrings
		*m: _setmargins
		*m: _show
		*m: _showstyle1
		*m: _showstyle2
		*p: ctlabout
		*p: ctlactive
		*p: ctlalignment
		*p: ctlbackcolor
		*p: ctlcapslockstyle
		*p: ctlclosebutton
		*p: ctlcontrol
		*p: ctlfadein
		*p: ctlfadeout
		*p: ctlfontbold
		*p: ctlfontcharset
		*p: ctlfontitalic
		*p: ctlfontname
		*p: ctlfontsize
		*p: ctlfontstrikethru
		*p: ctlfontunderline
		*p: ctlforecolor
		*p: ctlhidedelay
		*p: ctlhwnd		&& Specifies the Window handle of the Window.
		*p: ctlicon
		*p: ctliconlarge
		*p: ctllangid
		*p: ctlleft
		*p: ctllink
		*p: ctllinklabel
		*p: ctllinkurl
		*p: ctlmargin		&& Sets the top, left, bottom, and right margins for a ToolTip window. A margin is the distance, in pixels, between the ToolTip window border and the text contained within the ToolTip window.
		*p: ctlmarginbottom
		*p: ctlmarginleft
		*p: ctlmarginright
		*p: ctlmargintop
		*p: ctlmaxwidth		&& Sets the maximum width for a ToolTip window.
		*p: ctloffsetx
		*p: ctloffsety
		*p: ctlposition
		*p: ctlpositionstyle
		*p: ctlshowdelay
		*p: ctlstyle		&& 1 = Balloon; 2 = Rectangular; 3 = Rectangular with no borders
		*p: ctltext
		*p: ctltitle
		*p: ctltop
		*p: ctlversion
		*p: ctlvisible
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	ctlabout = ctl32_balloontip - Carlos Alloatti.
	ctlactive = .T.
	ctlalignment = 3
	ctlbackcolor = -1
	ctlcapslockstyle = .F.
	ctlclosebutton = .F.
	ctlcontrol = 
	ctlfadein = .F.
	ctlfadeout = .F.
	ctlfontbold = 
	ctlfontcharset = 
	ctlfontitalic = 
	ctlfontname = 
	ctlfontsize = 
	ctlfontstrikethru = 
	ctlfontunderline = 
	ctlforecolor = -1
	ctlhidedelay = 5000
	ctlhwnd = 0		&& Specifies the Window handle of the Window.
	ctlicon = 0
	ctliconlarge = .F.
	ctllangid = 0
	ctlleft = 0
	ctllink = 
	ctllinklabel = 
	ctllinkurl = 
	ctlmargin = 0		&& Sets the top, left, bottom, and right margins for a ToolTip window. A margin is the distance, in pixels, between the ToolTip window border and the text contained within the ToolTip window.
	ctlmarginbottom = 0
	ctlmarginleft = 0
	ctlmarginright = 0
	ctlmargintop = 0
	ctlmaxwidth = 255		&& Sets the maximum width for a ToolTip window.
	ctloffsetx = 0.75
	ctloffsety = 0.75
	ctlposition = 3
	ctlpositionstyle = 1
	ctlshowdelay = 200
	ctlstyle = 1		&& 1 = Balloon; 2 = Rectangular; 3 = Rectangular with no borders
	ctltext = 
	ctltitle = 
	ctltop = 0
	ctlversion = 20070711
	ctlvisible = .F.
	ForeColor = 255,0,245
	Height = 48
	Name = "ctl32_balloontip"
	Visible = .F.
	Width = 120

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_balloontip", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 3, ;
		Width = 77
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'tmrHide' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 0, ;
		Left = 120, ;
		Name = "tmrHide", ;
		Top = 0, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'tmrShow' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 200, ;
		Left = 192, ;
		Name = "tmrShow", ;
		Top = 24, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	HIDDEN PROCEDURE ctlactive_assign
		Lparameters vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		Endif
		
		This.ctlActive = m.vNewVal
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlCapsLockStyle And This.ctlActive And Capslock() Then
			This.ctlVisible = TRUE
		Endif
		
		*!* Hide if not Active
		If This.ctlActive = FALSE Then
			This.ctlVisible = FALSE
		Else
			apiSendMessageInteger(This._ControlHwnd, TTM_ACTIVATE, 1, 0)
		Endif
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlalignment_assign
		Lparameters m.vNewVal
		
		Local ;
			lnAlignmentNew As Integer, ;
			lnAlignmentOld As Integer, ;
			lbRecreate As boolean
		
		m.lbRecreate = FALSE
		
		m.lnAlignmentOld = This.ctlAlignment
		m.lnAlignmentNew = m.vNewVal
		
		This.ctlAlignment = m.vNewVal
		
		If This.ctlStyle = CON_BTSTYLE_BALLOON Then
			If Inlist(m.lnAlignmentOld, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
				If Not Inlist(m.lnAlignmentNew, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
					m.lbRecreate = TRUE
				Endif
			Else
				If Inlist(m.lnAlignmentNew, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
					m.lbRecreate = TRUE
				Endif
			Endif
		Endif
		
		If m.lbRecreate = TRUE Then
			*!* Recreate BalloonTip
			This._Create()
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE ctlbackcolor_assign
		*!* ctlBackColor_Assign
		
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") <> T_NUMERIC Then
		    m.vNewVal = -1
		Endif
		
		This.ctlBackColor = m.vNewVal
		
		If This.ctlBackColor = -1 Then
		    This.ctlBackColor = apiGetSysColor(COLOR_INFOBK)
		Endif
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This._ControlHwnd > 0 Then
		    apiSendMessageInteger(This._ControlHwnd, TTM_SETTIPBKCOLOR, This.ctlBackColor, 0)
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE ctlcapslockstyle_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		Endif
		
		This.ctlCapsLockStyle = m.vNewVal
		
		If This.ctlCapsLockStyle Then
			This.ctlVisible = FALSE
			*!* Set HideDelay
			This.ctlHideDelay = 5000
		
			*!* Set TipPositionStyle to CARET
			This.ctlPositionStyle = CON_BTPOS_CARET
		
			*!* Set Icon
			This.ctlIcon = TTI_WARNING
		
			*!* Set title and text
			This.ctlTitle = This._LangTitle
			This.ctlText = This._LangText
		Else
			This.ctlVisible = FALSE
		Endif
		
		If This.ctlCapsLockStyle And This.ctlActive And Capslock() Then
			This.ctlVisible = TRUE
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE ctlclosebutton_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		ENDIF
		
		This.ctlCloseButton = m.vNewVal
		
		*!* Recreate BalloonTip
		This._Create()
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlfadein_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		Endif
		
		This.ctlFadeIn = m.vNewVal
		
		*!* Recreate BalloonTip
		This._Create()
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlfadeout_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		Endif
		
		This.ctlFadeOut = m.vNewVal
		
	ENDPROC

	HIDDEN PROCEDURE ctlfontbold_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal >= FW_BOLD Then
				m.vNewVal = TRUE
			Else
				m.vNewVal = FALSE
			Endif
		Endif
		
		This.ctlFontBold = m.vNewVal
		
		This._SetFont()
		
	ENDPROC

	HIDDEN PROCEDURE ctlfontcharset_assign
		Lparameters m.vNewVal
		
		This.ctlFontCharSet = m.vNewVal
		
		This._SetFont()
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlfontitalic_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		Endif
		
		This.ctlFontItalic = m.vNewVal
		
		This._SetFont()
		
	ENDPROC

	HIDDEN PROCEDURE ctlfontname_assign
		Lparameters m.vNewVal
		
		This.ctlFontName = m.vNewVal
		
		This._SetFont()
		
	ENDPROC

	HIDDEN PROCEDURE ctlfontsize_assign
		Lparameters m.vNewVal
		
		This.ctlFontsize = m.vNewVal
		
		This._SetFont()
		
	ENDPROC

	HIDDEN PROCEDURE ctlfontstrikethru_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
		    If m.vNewVal = 0 Then
		        m.vNewVal = FALSE
		    Else
		        m.vNewVal = TRUE
		    Endif
		Endif
		
		This.ctlFontStrikethru = m.vNewVal
		
		This._SetFont()
		
	ENDPROC

	HIDDEN PROCEDURE ctlfontunderline_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
		    If m.vNewVal = 0 Then
		        m.vNewVal = FALSE
		    Else
		        m.vNewVal = TRUE
		    Endif
		Endif
		
		This.ctlFontUnderline = m.vNewVal
		
		This._SetFont()
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlforecolor_assign
		*!* ctlForecolor_Assign
		
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") <> T_NUMERIC Then
		    m.vNewVal = -1
		Endif
		
		This.ctlForeColor = m.vNewVal
		
		If m.vNewVal = -1 Then
		    This.ctlForeColor = apiGetSysColor(COLOR_INFOTEXT)
		Endif
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This._ControlHwnd > 0 Then
		    apiSendMessageInteger(This._ControlHwnd, TTM_SETTIPTEXTCOLOR, This.ctlForeColor, 0)
		Endif
		
	ENDPROC

	PROCEDURE ctlhide
		*!* ctlHide()
		
		Lparameters m.tnHideCode As Integer
		
		Do Case
		    Case m.tnHideCode = -1		&& Link CLICKED
		        This.ctlOpenLink()
		
		    Case m.tnHideCode = 0		&& Hide Delay timeout
		    Case m.tnHideCode = 1		&& Click Inside BalloonTip
		    Case m.tnHideCode = 2		&& Click Outside BalloonTip
		    Case m.tnHideCode = 3		&& Click X Close Button
		    Case m.tnHideCode = 4		&& Key Pressed
		    Case m.tnHideCode = 5		&& CAPS LOCK key set to off
		    Case m.tnHideCode = 6		&& Form moved, resized
		        *!* 20070610 New Hide Code
		    Case m.tnHideCode = 7		&& ctlVisible set to FALSE
		Endcase
		
	ENDPROC

	HIDDEN PROCEDURE ctlhidedelay_assign
		Lparameters m.vNewVal
		
		If m.vNewVal < 0 Then
			m.vNewVal = 0
		Endif
		
		This.ctlHideDelay = m.vNewVal
		
		This.tmrHide.Interval = m.vNewVal
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlhwnd_access
		Return This._ControlHwnd
		
	ENDPROC

	HIDDEN PROCEDURE ctlhwnd_assign
		Lparameters m.vNewVal
		
		Return
		
		
	ENDPROC

	HIDDEN PROCEDURE ctliconlarge_assign
		Lparameters m.vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		Endif
		
		If This.ctlIconLarge <> m.vNewVal Then
			This.ctlIconLarge = m.vNewVal
			This._SetIconAndTitle()
		Endif
		
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlicon_assign
		*!* ctlIcon_Assign()
		
		*!*	TTI_NONE								0
		*!*	TTI_INFO								1
		*!*	TTI_WARNING								2
		*!*	TTI_ERROR								3
		*!*	TTI_INFO_LARGE          				4		&& VISTA
		*!*	TTI_WARNING_LARGE       				5		&& VISTA
		*!*	TTI_ERROR_LARGE         				6		&& VISTA
		
		Lparameters vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
		    If m.vNewVal < 0 Then
		        m.vNewVal = 0
		    Endif
		    *!*	    If m.vNewVal > 6 Then
		    *!*	        m.vNewVal = 0
		    *!*	    Endif
		Endif
		
		This.ctlIcon = m.vNewVal
		
		This.oIcon = Null
		
		If Type("This.ctlIcon") = T_CHARACTER Then
		    If ctlGetOsVersion() >= NTDDI_WINXPSP2 Then	&& Custom icons only work in xp sp2 and up
		        If File(This.ctlIcon) Then
		            This.oIcon = Null
		            This.oIcon = LoadPicture(This.ctlIcon)
		            This.ctlIcon = This.oIcon.Handle
		        Else
		            This.ctlIcon = 0
		        Endif
		    Else
		        This.ctlIcon = 0
		    Endif
		Endif
		
		This._SetIconAndTitle()
		
	ENDPROC

	HIDDEN PROCEDURE ctllangid_assign
		Lparameters m.vNewVal
		
		This.ctllangid = m.vNewVal
		
		This._SetLocaleStrings()
		
	ENDPROC

	HIDDEN PROCEDURE ctllink_access
		*!* Store Link URL in ctlLinkURL
		*!* Store Link Label in ctlLinkLabel
		*!* Retrieve complete Link form ctlLink
		
		Local lcLink
		
		m.lcLink = ""
		
		If ctlGetOsVersion() >= NTDDI_WINXP Then
			Do Case
				Case Not Empty(This.ctlLinkURL) And Not Empty(This.ctlLinkLabel)
					m.lcLink =[<A href="] + Alltrim(This.ctlLinkURL) + [">] + Alltrim(This.ctlLinkLabel) + "</A>"
		
				Case Not Empty(This.ctlLinkURL) And Empty(This.ctlLinkLabel)
					m.lcLink = "<A>" + Alltrim(This.ctlLinkLabel) + "</A>"
		
				Case Empty(This.ctlLinkURL) And Not Empty(This.ctlLinkLabel)
					m.lcLink =Alltrim(This.ctlLinkLabel)
		
			Endcase
		Else
			m.lcLink = Alltrim(Alltrim(This.ctlLinkLabel) + " " + Alltrim(This.ctlLinkURL))
		Endif
		
		Return m.lcLink
		
	ENDPROC

	PROCEDURE ctlmakelink
		Lparameters m.tcLinkLabel As String, m.tcLinkURL As String
		
		This.ctlLinkLabel = m.tcLinkLabel
		This.ctlLinkURL = m.tcLinkURL
		
		Return This.ctlLink
		
	ENDPROC

	HIDDEN PROCEDURE ctlmarginbottom_assign
		Lparameters vNewVal
		
		This.ctlMarginBottom = m.vNewVal
		
		This._SetMargins()
		
	ENDPROC

	HIDDEN PROCEDURE ctlmarginleft_assign
		Lparameters vNewVal
		
		This.ctlMarginLeft = m.vNewVal
		
		This._SetMargins()
	ENDPROC

	HIDDEN PROCEDURE ctlmarginright_assign
		Lparameters vNewVal
		
		This.ctlMarginRight = m.vNewVal
		
		This._SetMargins()
	ENDPROC

	HIDDEN PROCEDURE ctlmargintop_assign
		Lparameters vNewVal
		
		This.ctlMarginTop = m.vNewVal
		
		This._SetMargins()
	ENDPROC

	HIDDEN PROCEDURE ctlmargin_assign
		*!* Sets the margin between the text and the borders of the balloon tip
		
		Lparameters vNewVal
		
		This.ctlMargin = m.vNewVal
		
		With This
		    .ctlMarginTop		= .ctlMargin
		    .ctlMarginLeft		= .ctlMargin
		    .ctlMarginRight		= .ctlMargin
		    .ctlMarginBottom	= .ctlMargin
		Endwith
		
	ENDPROC

	HIDDEN PROCEDURE ctlmaxwidth_assign
		Lparameters vNewVal
		
		*!*	If m.vNewVal < 0 Then
		*!*		m.vNewVal = 0
		*!*	Endif
		
		This.ctlMaxWidth = m.vNewVal
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, TTM_SETMAXTIPWIDTH , 0, This.ctlMaxWidth)
		
	ENDPROC

	PROCEDURE ctlopenlink
		*!* ctlOpenLink
		
		*!* 20071114 removed ["] + This.ctlLinkURL + ["]
		*!* Always pass string variables to api functions and not object properties
		
		Local lcLink As String
		
		m.lcLink = This.ctlLinkURL
		
		If Not Empty(m.lcLink) Then
			?apiShellExecute(0, 0, m.lcLink, 0, 0, SW_SHOWNORMAL)
		Endif
		
	ENDPROC

	PROCEDURE ctlreset
		If Pemstatus(This, "aProperties", 5) = FALSE Then
			Return
		Endif
		
		With This
			.ctlactive			=	.aProperties(01)
			.ctlalignment		=	.aProperties(02)
			.ctlbackcolor		=	.aProperties(03)
			.ctlcapslockstyle	=	.aProperties(04)
			.ctlclosebutton		=	.aProperties(05)
			.ctlcontrol			=	.aProperties(06)
			.ctlfadein			=	.aProperties(07)
			.ctlfadeout			=	.aProperties(08)
			.ctlfontbold		=	.aProperties(09)
			.ctlfontcharset		=	.aProperties(10)
			.ctlfontitalic		=	.aProperties(11)
			.ctlfontsize		=	.aProperties(12)
			.ctlfontstrikethru	=	.aProperties(13)
			.ctlfontunderline	=	.aProperties(14)
			.ctlforecolor		=	.aProperties(15)
			.ctlhidedelay		=	.aProperties(16)
			.ctlicon			=	.aProperties(17)
			.ctliconlarge		=	.aProperties(18)
			.ctllangid			=	.aProperties(19)
			.ctlleft			=	.aProperties(20)
			.ctllinklabel		=	.aProperties(21)
			.ctllinkurl			=	.aProperties(22)
			.ctlmargin			=	.aProperties(23)
			.ctlmarginbottom	=	.aProperties(24)
			.ctlmarginleft		=	.aProperties(25)
			.ctlmarginright		=	.aProperties(26)
			.ctlmargintop		=	.aProperties(27)
			.ctlmaxwidth		=	.aProperties(28)
			.ctloffsetx			=	.aProperties(29)
			.ctloffsety			=	.aProperties(30)
			.ctlposition		=	.aProperties(31)
			.ctlpositionstyle	=	.aProperties(32)
			.ctlshowdelay		=	.aProperties(33)
			.ctlstyle			=	.aProperties(34)
			.ctltext			=	.aProperties(35)
			.ctltitle			=	.aProperties(36)
			.ctltop				=	.aProperties(37)
			.ctlvisible			=	.aProperties(38)
		Endwith
		
		
		
	ENDPROC

	PROCEDURE ctlsavestate
		*!* ctlSaveState
		
		If Pemstatus(This, "aProperties", 5) = FALSE Then
			This.AddProperty("aProperties[50]", FALSE)
		Endif
		
		With This
			.aProperties(01) =	.ctlactive
			.aProperties(02) =	.ctlalignment
			.aProperties(03) =	.ctlbackcolor
			.aProperties(04) =	.ctlcapslockstyle
			.aProperties(05) =	.ctlclosebutton
			.aProperties(06) =	.ctlcontrol
			.aProperties(07) =	.ctlfadein
			.aProperties(08) =	.ctlfadeout
			.aProperties(09) =	.ctlfontbold
			.aProperties(10) =	.ctlfontcharset
			.aProperties(11) =	.ctlfontitalic
			.aProperties(12) =	.ctlfontsize
			.aProperties(13) =	.ctlfontstrikethru
			.aProperties(14) =	.ctlfontunderline
			.aProperties(15) =	.ctlforecolor
			.aProperties(16) =	.ctlhidedelay
			.aProperties(17) =	.ctlicon
			.aProperties(18) =	.ctliconlarge
			.aProperties(19) =	.ctllangid
			.aProperties(20) =	.ctlleft
			.aProperties(21) =	.ctllinklabel
			.aProperties(22) =	.ctllinkurl
			.aProperties(23) =	.ctlmargin
			.aProperties(24) =	.ctlmarginbottom
			.aProperties(25) =	.ctlmarginleft
			.aProperties(26) =	.ctlmarginright
			.aProperties(27) =	.ctlmargintop
			.aProperties(28) =	.ctlmaxwidth
			.aProperties(29) =	.ctloffsetx
			.aProperties(30) =	.ctloffsety
			.aProperties(31) =	.ctlposition
			.aProperties(32) =	.ctlpositionstyle
			.aProperties(33) =	.ctlshowdelay
			.aProperties(34) =	.ctlstyle
			.aProperties(35) =	.ctltext
			.aProperties(36) =	.ctltitle
			.aProperties(37) =	.ctltop
			.aProperties(38) =	.ctlvisible
		Endwith
		
	ENDPROC

	PROCEDURE ctlsetdefaultfont
		This._SetFontEnable = FALSE
		
		This.oLogFont.Value 	= This._DefaultLogFont
		This.ctlFontBold 		= This.oLogFont.FontBold
		This.ctlFontCharSet		= This.oLogFont.FontCharSet
		This.ctlFontItalic 		= This.oLogFont.FontItalic
		This.ctlFontName 		= This.oLogFont.FontName
		This.ctlFontSize 		= This.oLogFont.FontSize
		This.ctlFontStrikethru 	= This.oLogFont.FontStrikethru
		This.ctlFontUnderline	= This.oLogFont.FontUnderline
		
		This._SetFontEnable = TRUE
		
		This._SetFont()
		
	ENDPROC

	PROCEDURE ctlshow
		*!* ctlShow()
		
		*!* Displays/hides tip
		Lparameters ;
		    m.tnPositionStyle As Integer, ;
		    m.tcText As String , ;
		    m.tcTitle As String, ;
		    m.tuIcon As Variant
		
		This.ctlVisible = FALSE
		
		If Pcount() > 0 Then
		    This.ctlPositionStyle = m.tnPositionStyle
		Else
		    m.tnPositionStyle = 0
		Endif
		
		If Pcount() > 1 Then
		    This.ctlText = m.tcText
		Endif
		
		If Pcount() > 2 Then
		    This.ctlTitle = m.tcTitle
		Endif
		
		If Pcount() > 3 Then
		    This.ctlIcon = m.tuIcon
		Endif
		
		*!* If the first parameter is 0 then we hide tooltip
		
		If m.tnPositionStyle = 0 Then
		    This.ctlVisible = FALSE
		else
		    This.ctlVisible = TRUE
		Endif
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlshowdelay_assign
		Lparameters vNewVal
		
		If m.vNewVal < 200 Then
		    m.vNewVal = 200
		Endif
		
		This.ctlShowDelay = m.vNewVal
		
		This.tmrShow.Interval = m.vNewVal
		
	ENDPROC

	HIDDEN PROCEDURE ctlstyle_assign
		*!*	#Define CON_BTSTYLE_BALLOON					1
		*!*	#Define CON_BTSTYLE_RECT					2
		*!*	#Define CON_BTSTYLE_NOBORDER				3
		
		Lparameters vNewVal
		
		If This.ctlStyle <> m.vNewVal Then
		
		    If m.vNewVal > 3 Then
		        m.vNewVal = CON_BTSTYLE_BALLOON
		    Endif
		
		    If m.vNewVal < 1 Then
		        m.vNewVal = CON_BTSTYLE_BALLOON
		    Endif
		
		    This.ctlStyle = m.vNewVal
		Else
		    Return
		Endif
		
		This._Create()
		
		
		
		
		
	ENDPROC

	HIDDEN PROCEDURE ctltext_assign
		Lparameters m.vNewVal
		
		Local lcText As String
		
		This.ctlText = m.vNewVal
		m.lcText = m.vNewVal
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		Local lcText
		
		*!* Replace TABS with four spaces:
		m.lcText = Strtran(m.lcText, Chr(9), Space(4))
		
		*!* Add one space at end of each line if font is italic to prevent clipping
		If This.ctlFontItalic = TRUE Then
			m.lcText = Strtran(m.lcText, CRLF, " " + CRLF)
			m.lcText = m.lcText + " "
		Endif
		
		*!* Add terminating nul
		If Right(m.lcText, 1) <> NULCHAR Then
			m.lcText = m.lcText + NULCHAR
		Endif
		
		This.oToolInfo.lpszText = m.lcText
		
		apiSendMessageInteger(This._ControlHwnd, TTM_UPDATETIPTEXTA, 0, This.oToolInfo.Address)
	ENDPROC

	HIDDEN PROCEDURE ctltitle_assign
		Lparameters vNewVal
		
		This.ctlTitle = m.vNewVal
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		This._SetIconAndTitle()
		
		
		
	ENDPROC

	PROCEDURE ctltrack
		*!* ctlTrack()
		
		Lparameters m.tcText
		
		Local ;
		    lcPoint As String, ;
		    lnLeft As Integer, ;
		    lnWidth As Integer, ;
		    lnHeight As Integer, ;
		    lnOffsetX As Integer, ;
		    lnOffsetY As Integer, ;
		    lnTop As Integer, ;
		    lnParam As Integer
		
		*!* If balloonTip is not active, dont show, just return
		If This.ctlActive = FALSE Then
		    Return
		Endif
		
		If This._ControlHwnd = 0 Then
		    Return
		Endif
		
		If Pcount() > 0 And Vartype(m.tcText) = T_CHARACTER Then
		
		    *!* 20070714 Check to see if text changed
		    If Not This.ctlText == m.tcText Then
		        This.ctlText = m.tcText
		    Endif
		Endif
		
		*!* ctlTrack ignores ctlPosition and ctlAlignment
		
		m.lcPoint = Space(8)
		*!* Get position of mouse cursor
		apiGetCursorPos(@m.lcPoint)
		
		m.lnLeft = ctlGetXFromPoint(m.lcPoint)
		m.lnTop =  ctlGetYFromPoint(m.lcPoint)
		
		m.lnWidth 	= 16
		m.lnHeight 	= 16
		
		m.lnOffsetX = m.lnWidth  * This.ctlOffsetX - m.lnWidth
		m.lnOffsetY = m.lnHeight * This.ctlOffsetY - m.lnHeight
		
		m.lnTop  = Int(m.lnTop + m.lnHeight + m.lnOffsetY)
		m.lnLeft = Int(m.lnLeft + m.lnWidth + m.lnOffsetX)
		
		*!* Make DWORD for TTM_TRACKPOSITION message (MAKELPARAM)
		m.lnParam = ctlMakelParam(m.lnLeft, m.lnTop)
		
		*!* Set tooltip position
		*!* 20070714 Check to see if m.lnParam (TrackPosition) changed
		If This._OldTrackPosition <> m.lnParam Then
		    apiSendMessageInteger(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)
		    This._OldTrackPosition = m.lnParam
		Endif
		
		If This._TrackActive = 0 Then
		
		     *!* Activate tooltip:
		    apiSendMessageInteger(This._ControlHwnd, TTM_TRACKACTIVATE, 1, This.oToolInfo.Address)
		    This._TrackActive = 1
		
		Endif
		
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlvisible_assign
		Lparameters vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
		    If m.vNewVal = 0 Then
		        m.vNewVal = FALSE
		    Else
		        m.vNewVal = TRUE
		    Endif
		Endif
		
		This.ctlVisible = m.vNewVal
		
		If This._ControlHwnd = 0 Then
		    Return
		Endif
		
		If This.ctlVisible Then
		    *!* We have a timer call This._Show() to overcome the
		    *!* bug of setting the balloon Visible in an object getfocus,
		    *!* the cursor (caret) is still in the previous control.
		
		    *!* If ctlPositionStyle = CON_BTPOS_SYS1270, save object reference now,
		    *!* This is done in case user moves mouse away from control.
		    If This.ctlPositionStyle = CON_BTPOS_SYS1270 Then
		        This.ctlControl = Sys(1270)
		    Endif
		
		    This.tmrShow.Enabled = TRUE
		    *!* This timer just calls _Show()
		Else
		    This.tmrShow.Enabled = FALSE
		    *!* Here we hide balloontip:
		    If This.ctlFadeOut = FALSE Then
		        *!* We first hide the tooltip window to prevent fade out effect, TTF_NOFADE seems to
		        *!* have no effect on fade out, only on fade in
		        apiShowWindow(This._ControlHwnd, SW_HIDE)
		    Endif
		
			apiSendMessageInteger(This._ControlHwnd, TTM_TRACKACTIVATE, 0, This.oToolInfo.Address)
		    This._TrackActive = 0
		
		    This.tmrHide.Enabled = FALSE
		Endif
		
	ENDPROC

	PROCEDURE Destroy
		apiDestroyWindow(This._ControlHwnd)
		
		*!* Disable timer just in case (Forum/rcanop/2006-11-26)
		This.tmrShow.Enabled = FALSE
		
		*!* Control is an object reference to the control to use to locate the balloontip
		This.ctlControl = Null
		
		*!* oToolInfo is an instance of the _toolinfo class of ctl32_structs
		This.oToolInfo = Null
		
		*!* loIcon is an object reference to an icon file if a custom icon was used
		This.oIcon = Null
		
		*!* oFont stores a handle to a Logical Font in memory
		If This.oFont <> 0 Then
		    apiDeleteObject(This.oFont)
		Endif
		
	ENDPROC

	PROCEDURE Init
		
		*!* If we have a parameter, Status Bar is creating this
		Lparameters m.tnParam
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		*!* This Property we need now:
		If Not Pemstatus(This, "_StatusBarHwnd", CON_PEMSTAT_DEFINED)
			This.AddProperty("_StatusBarHwnd", 0)
		Endif
		
		*!* If we have a parameter, Status Bar is creating this
		If Pcount() > 0 And Type("m.tnParam") = T_NUMERIC Then
			This._StatusBarHwnd = m.tnParam
		Endif
		
		*!* Check if -1 parameter from statusbar, that means no Init yet
		If This._StatusBarHwnd = -1
			Return
		Endif
		
		This._AddObjects()
		This._AddProperties()
		This._SetLocaleStrings()
		This._Create()
		This._BindEvents()
		
	ENDPROC

	PROCEDURE _addobjects
		*!* _AddObjects()
		
		*!* This will hold an object reference to a custom icon to display in balloontip
		This.AddProperty("oIcon", 0)
		
		*!* Add oToolInfo object
		This.AddProperty("oToolInfo", Createobject("_TOOLINFO"))
		
		*!* Rect structure
		This.AddProperty("oRect", Createobject("_RECT"))
		
		*!* nonclientmetrics structure
		*!* This.AddProperty("oNonClientMetrics", Newobject("_NonClientMetrics", m.lcVcxStructs))
		
		*!* logfont structure
		This.AddProperty("oLogFont", Createobject("_LOGFONT"))
		
		*!* This stores a font object reference that we apply to the tooltip
		*!* it gets released at Destroy() event
		This.AddProperty("oFont", 0)
		
	ENDPROC

	HIDDEN PROCEDURE _addproperties
		*!* _AddProperties()
		
		*!* Here we add properties to the class that will be used internally
		
		*!* Stores the hWnd of the host window
		This.AddProperty("_HosthWnd", ctlGetHostHWnd(This))
		
		*!* Indicates we are in the creation stage
		This.AddProperty("_Creating", FALSE)
		
		*!* Stores the value of VFP window procedure
		This.AddProperty("_VFPWndProc", apiGetWindowLong(_vfp.HWnd, GWL_WNDPROC))
		
		*!* Stores hWnd of Windows common control created by the class
		This.AddProperty("_ControlHwnd", 0)
		
		*!* These 2 properties hold the title and text for the capslock balloontip
		This.AddProperty("_LangTitle", "")
		This.AddProperty("_LangText", "")
		
		*!* Specifies the state of the TTM_TRACKACTIVATE flag
		This.AddProperty("_TrackActive", 0)
		
		*!* Saves old TrackPosition, used by ctlTrack()
		This.AddProperty("_OldTrackPosition", 0)
		
		*!* Font handling properties:
		
		*!* This indicates if the default system font for tooltips has
		*!* already been saved in _DefaultLogFont
		This.AddProperty("_DefaultFontSaved", FALSE)
		
		*!* This stores a LogFont structure of the default system font as a string
		*!* for tooltips
		This.AddProperty("_DefaultLogFont", "")
		
		*!* This indicates if _SetFont is allowed to continue
		This.AddProperty("_SetFontEnable", TRUE)
		
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _bindevents
		*!* _BindEvents()
		
		Bindevent(Thisform, "RESIZE", This, "_EventHandlerFormResize", 1)
		Bindevent(Thisform, "MOVED", This, "_EventHandlerFormMoved", 1)
		Bindevent(_Screen, "MOVED", This, "_EventHandlerScreenMoved", 1)
		
		Bindevent(Thisform.HWnd, WM_KEYDOWN, This, "_MessageHandlerFormWm_KeyDown", 1)
		Bindevent(This._HosthWnd, WM_LBUTTONDOWN, This, "_MessageHandlerHostWm_lButtonDown", 1)
		
		*!* Catch clicks in links
		
		If Pemstatus(Thisform,"_WM_NOTIFY_HWND", 5) = FALSE Then
			Thisform.AddProperty("_WmNotifyHwnd", 0)
			Thisform.AddProperty("_WmNotifyMsg", 0)
			Thisform.AddProperty("_WmNotifyWparam", 0)
			Thisform.AddProperty("_WmNotifyLparam", 0)
		Endif
		
		Bindevent(This._HosthWnd, WM_NOTIFY, This, "_MessageHandlerHostWm_Notify", 1)
		Bindevent(Thisform, "_WmNotifyMsg", This, "_PropertyHandlerFormWmNotifyMsg", 1)
		
		
	ENDPROC

	HIDDEN PROCEDURE _create
		*!* _Create()
		
		*!*	CON_STYLE_BALLOON						1
		*!*	CON_STYLE_RECT							2
		*!*	CON_STYLE_NOBORDER						3
		
		
		*!* This procedure creates the Window common control and sets its initial properties
		
		*!* Destroy current tooltip window if present
		If This._ControlHwnd <> 0 Then
		    apiDestroyWindow(This._ControlHwnd)
		    This._ControlHwnd = 0
		Endif
		
		This._Creating = TRUE
		
		Local ;
		    dwExStyle As Integer, ;
		    lpClassName As String, ;
		    lpWindowName As String, ;
		    dwStyle As Integer, ;
		    hWndParent As Integer, ;
		    hMenu As Integer, ;
		    hInstance As Integer, ;
		    lpParam As Integer
		
		*!* Set apiCreateWindowEx parameters
		m.dwExStyle = WS_EX_TOPMOST
		m.lpClassName = TOOLTIPS_CLASSA
		m.lpWindowName = ""
		
		*!* 20070830 TTS_USEVISUALSTYLE property removed, makes text all blue in Vista
		m.dwStyle = Bitor(TTS_NOANIMATE, TTS_NOPREFIX)
		
		If This.ctlStyle = CON_BTSTYLE_BALLOON
		    m.dwStyle = Bitor(m.dwStyle, TTS_BALLOON)
		Endif
		
		If This.ctlCloseButton = TRUE Then
		    m.dwStyle = Bitor(m.dwStyle, TTS_CLOSE)
		Endif
		
		If This.ctlFadeIn = FALSE Then
		    m.dwStyle = Bitor(m.dwStyle, TTS_NOFADE)
		Endif
		
		m.hWndParent = 0
		
		m.hMenu = 0
		m.hInstance = 0
		m.lpParam = 0
		
		This._ControlHwnd = apiCreateWindowEx( ;
		    m.dwExStyle, ;
		    m.lpClassName, ;
		    m.lpWindowName, ;
		    m.dwStyle, ;
		    CW_USEDEFAULT, ;
		    CW_USEDEFAULT, ;
		    CW_USEDEFAULT, ;
		    CW_USEDEFAULT, ;
		    m.hWndParent, ;
		    m.hMenu, ;
		    m.hInstance, ;
		    m.lpParam)
		
		*!* Add TOOL
		This.oToolInfo.uFlags   = Bitor(TTF_IDISHWND, TTF_TRACK, TTF_TRANSPARENT, TTF_PARSELINKS, TTF_BITMAP)
		
		*!* If tooltip does not have balloon style, then position is absolute:
		If This.ctlStyle <> CON_BTSTYLE_BALLOON Then
		    This.oToolInfo.uFlags   = Bitor(This.oToolInfo.uFlags, TTF_ABSOLUTE)
		Endif
		
		*!* Check if we have a centered balloon tip:
		If This.ctlStyle = CON_BTSTYLE_BALLOON ;
		        And Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER) Then
		    This.oToolInfo.uFlags   = Bitor(This.oToolInfo.uFlags, TTF_CENTERTIP)
		Endif
		
		This.oToolInfo.hWnd			= This._HosthWnd
		This.oToolInfo.hInst    	= 0
		This.oToolInfo.uId      	= This._HosthWnd
		This.oToolInfo.Rect.Left	= 0
		This.oToolInfo.Rect.Top		= 0
		This.oToolInfo.Rect.Right	= 0
		This.oToolInfo.Rect.Bottom	= 0
		
		This.oToolInfo.lpszText	= NULCHAR
		This.oToolInfo.lParam			= 0
		
		apiSendMessageInteger(This._ControlHwnd, TTM_ADDTOOLA, 0, This.oToolInfo.Address)
		
		*!* 20070608 Assign colors before text or color change fails:
		This.ctlBackColor = This.ctlBackColor
		This.ctlForeColor = This.ctlForeColor
		
		*!* Save default system font for tooltips:
		This._GetFontDefault()
		
		*!* Set font of tooltip:
		This._SetFont()
		
		This.ctlIcon = 		This.ctlIcon && also assigns ctlTitle
		This.ctlText = 		This.ctlText
		This.ctlHideDelay = This.ctlHideDelay
		This.ctlShowDelay = This.ctlShowDelay
		This.ctlMaxWidth = 	This.ctlMaxWidth
		
		If This.ctlMarginTop <> 0 ;
		        Or This.ctlMarginLeft <> 0 ;
		        Or This.ctlMarginRight <> 0 ;
		        Or This.ctlMarginBottom <> 0 Then
		
		    This._SetMargins()
		
		Endif
		
		If This.ctlMargin <> 0 Then
		    This.ctlMargin = 	This.ctlMargin
		Endif
		
		*!* 20071022 changed bitclear to bitxor/bitor
		
		*If This.ctlStyle = CON_BTSTYLE_NOBORDER Then
		*!* Borders have no effect on Vista
		If ctlGetOsVersion() < NTDDI_VISTA Then
		    m.dwStyle = apiGetWindowLong(This.ctlHWnd, GWL_STYLE)
		
		    If This.ctlStyle = CON_BTSTYLE_NOBORDER Then
		
		        m.dwStyle = Bitxor(Bitor(m.dwStyle, WS_BORDER), WS_BORDER)
		
		    Endif
		
		    *!* Have to remove TTS_CLOSE button:
		    If This.ctlCloseButton = FALSE Then
		        m.dwStyle = Bitxor(Bitor(m.dwStyle, TTS_CLOSE), TTS_CLOSE)
		    Endif
		
		    apiSetWindowLong(This.ctlHWnd, GWL_STYLE, m.dwStyle)
		
		    *!* This makes the window "refresh"
		    *        apiSendMessageInteger(This.ctlHWnd, TTM_UPDATE, 0, 0)
		    *        apiSetWindowPos(This.ctlHWnd, ;
		    0, ;
		    0, ;
		    0, ;
		    0, ;
		    0, ;
		    BITOR(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_NOACTIVATE, SWP_FRAMECHANGED))
		Endif
		*Endif
		
		This._Creating = FALSE
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _eventhandlerformmoved
		*!* _EventHandlerFormMoved
		
		If This.ctlVisible And This.ctlActive Then
			This.ctlVisible = FALSE
			Raiseevent(This, "ctlHide", 6)
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE _eventhandlerformresize
		*!* _EventHandlerFormResize
		
		If This.ctlVisible and This.ctlActive Then
			This.ctlVisible = FALSE
			Raiseevent(This, "ctlHide", 6)
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE _eventhandlerscreenmoved
		*!* _EventHandlerScreenMoved
		
		If This.ctlVisible And This.ctlActive Then
			This.ctlVisible = FALSE
			Raiseevent(This, "ctlHide", 6)
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE _getfontdefault
		*!* _GetFontDefault()
		
		*!* Here we save the original system default font for tooltips, so we can
		*!* use it later in ctlSetDefaultFont()
		
		*!* This method is called only from _Create()
		
		*!* If default system font for tooltips has been saved, return:
		If This._DefaultFontSaved = TRUE Then
		    Return
		Endif
		
		Local ;
			lnFont As Integer, ;
		    lcLogFont As String, ;
		    lnLen As Integer
		
		*!* Get a handle to the current font of the tooltip:
		m.lnFont = apiSendMessageInteger(This._ControlHwnd, WM_GETFONT, 0, 0)
		
		*!* Initialize an empty logfont structure:
		m.lcLogFont = This.oLogFont.Value
		m.lnLen = Len(m.lcLogFont)
		
		*!* Get font info from font handle, as a logfont stucture:
		apiGetobject(m.lnFont, m.lnLen, @m.lcLogFont)
		
		*!* Save logfont structure:
		This._DefaultLogFont = m.lcLogFont
		
		*!* Use oLogFont object to obtain structure members
		This.oLogFont.Value = m.lcLogFont
		
		*!* Disable font updates to the tooltip:
		This._SetFontEnable = FALSE
		
		*!* Here we fill the empty font properties with the default values:
		If Empty(This.ctlFontBold) Then
		    This.ctlFontBold = This.oLogFont.FontBold
		Endif
		
		If Empty(This.ctlFontCharSet) Then
		    This.ctlFontCharSet = This.oLogFont.FontCharSet
		Endif
		
		If Empty(This.ctlFontItalic) Then
		    This.ctlFontItalic = This.oLogFont.FontItalic
		Endif
		
		If Empty(This.ctlFontName) Then
		    This.ctlFontName = This.oLogFont.FontName
		Endif
		
		If Empty(This.ctlFontSize) Then
		    This.ctlFontSize = This.oLogFont.FontSize
		Endif
		
		If Empty(This.ctlFontStrikethru) Then
		    This.ctlFontStrikethru = This.oLogFont.FontStrikethru
		Endif
		
		If Empty(This.ctlFontUnderline) Then
		    This.ctlFontUnderline = This.oLogFont.FontUnderline
		Endif
		
		This._SetFontEnable = TRUE
		
		m.lnFont = Null
		
		This._DefaultFontSaved = TRUE
		
	ENDPROC

	HIDDEN PROCEDURE _gettrackposparam
		*!* _GetTrackPosParam()
		
		Lparameters m.tnX As Integer, m.tnY As Integer
		
		Local ;
		    lnX As Integer, ;
		    lnY As Integer, ;
		    lnParam As Integer
		
		Local lcPoint As String
		
		*!* Convert form coordinates to screen coordinates:
		m.lcPoint = ctlMakePoint(m.tnX, m.tnY)
		*!* 20070603 Changed Thisform.hWnd to This._HosthWnd
		apiClientToScreen(This._HostHWnd, @m.lcPoint)
		m.lnX = ctlGetXFromPoint(m.lcPoint)
		m.lnY = ctlGetYFromPoint(m.lcPoint)
		
		*!* Make DWORD for TTM_TRACKPOSITION message (MAKELPARAM)
		m.lnParam = ctlMakelParam(m.lnX, m.lnY)
		
		Return m.lnParam
		
	ENDPROC

	HIDDEN PROCEDURE _messagehandlerformwm_keydown
		*!* _MessageHandlerFormWm_KeyDown
		
		Lparameters pnHWnd As Integer, pnMsg As Integer, pnWparam As Integer, pnLparam As Integer
		
		Local lnResult As Number
		
		If This.ctlActive
			If This.ctlCapsLockStyle Then
				*!* If last key pressed was CAPS LOCK
				If m.pnWparam = VK_CAPITAL
					*!* If CAPS LOCK was set to on:
					If Bittest(apiGetKeyState(VK_CAPITAL), 0) = TRUE Then
						This.ctlVisible = TRUE
					Endif
					*!* If CAPS LOCK was set to off and the balloontip is visible:
					If Bittest(apiGetKeyState(VK_CAPITAL), 0) = FALSE And This.ctlVisible Then
						This.ctlVisible = FALSE
						Raiseevent(This, "ctlHide", 5)
					Endif
				Else
					*!* Key pressed was not CAPS LOCK, hide the balloontip is visible
					If This.ctlVisible  Then
						This.ctlVisible = FALSE
						Raiseevent(This, "ctlHide", 4)
					Endif
				Endif
			Else
				*!* Not ctlCapsLockStyle, Hide balloontip with any key
				If This.ctlVisible  Then
					This.ctlVisible = FALSE
					Raiseevent(This, "ctlHide", 4)
				Endif
			Endif
		
		Endif
		
		m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)
		
		Return m.lnResult
		
	ENDPROC

	HIDDEN PROCEDURE _messagehandlerhostwm_lbuttondown
		*!* _MessageHandlerHostWm_lButtonDown
		
		*!*	Here we detect a mouseclick on the form. The Balloontip transfers its mouse events to the form
		*!*	HWND. When the user clicks on the form or the balloontip, we hide the balloontip.
		*!*	IF the user clicked on the form, the form gets the click. If the user clicked on the balloontip
		*!*	we discard the click to prevent undesired clicks on the underlying form. For example, if underneath
		*!*	the balloontip there is a button, and the user clicks the balloontip to hide it, the button
		*!*	will get the click. This method prevents that.
		
		Lparameters pnHWnd As Integer, pnMsg As Integer, pnWparam As Integer, pnLparam As Integer
		
		Local lnResult As Number, lnX, lnY, lcPoint, lnOption
		
		m.lnOption = -1		&& not used
		
		If This.ctlVisible And This.ctlActive Then
		
			m.lnOption = 0		&& do not discard click
		
			*!* Get form coordinates of mouse click from lParam
		
			m.lnX = ctlGet_X_lParam(m.pnLparam)
			m.lnY = ctlGet_Y_lParam(m.pnLparam)
		
			*!* Convert form coordinates to screen coordinates:
			m.lcPoint = ctlMakePoint(m.lnX, m.lnY)
			*!* 20070603 Changed Thisform.hWnd to This._HosthWnd
			apiClientToScreen(This._HostHWnd, @m.lcPoint)
			m.lnX = ctlGetXFromPoint(m.lcPoint)
			m.lnY = ctlGetYFromPoint(m.lcPoint)
		
			*!* apiWindowFromPoint only works on XP and up, in 98 and 2K returns hwnd of form
			If ctlGetOsVersion() >= NTDDI_WINXP Then
				*!* We will check if the mouse click is in the ballontip or in the form
				*!* If the mouse click is on the balloontip, we do not pass the click to the form
				If apiWindowFromPoint(m.lnX, m.lnY) = This.ctlHwnd Then
					m.lnOption = 1	&& discard
				Endif
			Else
				*!* Not XP, use WindowRect that is not as exact, but close
		
				apiGetWindowRect(This.ctlHwnd, This.oRect.Address)
		
				If Between(m.lnY, This.oRect.Top, This.oRect.Bottom) And ;
						between(m.lnX, This.oRect.Left, This.oRect.Right) Then
					m.lnOption = 1 	&& Discard
				Endif
			Endif
		
			*!* Hide BalloonTip
			This.ctlVisible = FALSE
		
		Endif
		
		Do Case
		
			Case m.lnOption = -1	&& BalloonTip not visible and active
				m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)
		
			Case m.lnOption = 0		&& BalloonTip visible, click was outside balloontip
				m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)
				Raiseevent(This, "ctlHide", 2)
		
			Case m.lnOption = 1		&& BalloonTip visible, click was inside balloontip
				m.lnResult  = 1
				Raiseevent(This, "ctlHide", 1)
		Endcase
		
		Return m.lnResult
		
	ENDPROC

	HIDDEN PROCEDURE _messagehandlerhostwm_notify
		*!* _MessageHandlerHostWm_Notify
		
		Lparameters pnHWnd As Integer, pnMsg As Integer, pnWparam As Integer, pnLparam As Integer
		
		Local lnResult As Integer
		
		m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)
		
		Thisform._WmNotifyHwnd		= m.pnHWnd
		Thisform._WmNotifyWparam	= m.pnWparam
		Thisform._WmNotifyLparam	= m.pnLparam
		Thisform._WmNotifyMsg		= m.pnMsg
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE _propertyhandlerformwmnotifymsg
		*!* _PropertyHandlerFormWmNotifyMsg
		
		*!* This fires when the WM_NOTIFY_MSG property of the form changes
		
		Local lnCode, loNmhdr As _NMHDR
		
		m.loNmhdr = Createobject("_NMHDR", Thisform._WmNotifyLparam)
		
		If This._ControlHwnd <> m.loNmhdr.hwndFrom Then
			Return
		Endif
		
		m.lnCode = m.loNmhdr.Code
		
		*!* 20080813
		Do Case
		
			Case m.lnCode = TTN_LINKCLICK
				This.ctlVisible = FALSE
				Raiseevent(This, "ctlHide", -1)
		
			Case m.lnCode = TTN_POP
				This.ctlVisible = FALSE
				Raiseevent(This, "ctlHide", 3)
		
			Case m.lnCode = TTN_SHOW
		
				Local ;
				lnSize As Integer, ;
				loRect As _RECT
		
				m.lnSize = apiSendMessageInteger(This._ControlHwnd, TTM_GETBUBBLESIZE, 0, This.oToolInfo.Address)
		
				m.loRect = Newobject("_RECT")
		
				m.loRect.Left = 0
				m.loRect.Top = 0
				m.loRect.Right = ctlLoWord(m.lnSize)
				m.loRect.Bottom = ctlHiWord(m.lnSize)
		
				apiSendMessageInteger(This._ControlHwnd, TTM_ADJUSTRECT, 0, m.loRect.Address)
		
				m.loRect = Null
				release m.loRect
				
		*!*			?ctlLoWord(m.lnSize), m.loRect.Width, ctlLoWord(m.lnSize) - m.loRect.Width
		*!*			?ctlHiWord(m.lnSize), m.loRect.Height,ctlHiWord(m.lnSize) - m.loRect.Height
		
		Endcase
		
		m.loNmhdr = .Null.
		Release m.loNmhdr
		
	ENDPROC

	HIDDEN PROCEDURE _setfont
		*!* _SetFont()
		
		*!*	typedef struct tagLOGFONT {
		*!*	  LONG lfHeight;
		*!*	  LONG lfWidth;
		*!*	  LONG lfEscapement;
		*!*	  LONG lfOrientation;
		*!*	  LONG lfWeight;
		*!*	  BYTE lfItalic;
		*!*	  BYTE lfUnderline;
		*!*	  BYTE lfStrikeOut;
		*!*	  BYTE lfCharSet;
		*!*	  BYTE lfOutPrecision;
		*!*	  BYTE lfClipPrecision;
		*!*	  BYTE lfQuality;
		*!*	  BYTE lfPitchAndFamily;
		*!*	  TCHAR lfFaceName[LF_FACESIZE];
		*!*	} LOGFONT, *PLOGFONT;
		
		*!*	    *!* Get default font for tooltips
		*!*	    Local m.lcNonClientMetrics As String
		
		*!*	    m.lcNonClientMetrics = This.oNonClientMetrics._Struct
		*!*	    ?apiSystemParametersInfo(SPI_GETNONCLIENTMETRICS, Len(m.lcNonClientMetrics), @m.lcNonClientMetrics, 0)
		*!*	    This.oNonClientMetrics._Struct = m.lcNonClientMetrics
		
		*!*	    m.lcLogFont = This.oNonClientMetrics._lfStatusFontStruct
		
		
		If This._SetFontEnable = FALSE Then
		    Return
		Endif
		
		If This._ControlHwnd = 0 Then
		    Return
		Endif
		
		This._SetFontEnable = FALSE
		
		Local lcLogFont As String
		
		*!* Set default values:
		This.oLogFont.Value = This._DefaultLogFont
		
		*!* Fill members of font structure:
		With This.oLogFont
		    .FontBold			= This.ctlFontBold
		    .FontCharSet		= This.ctlFontCharSet
		    .FontItalic 		= This.ctlFontItalic
		    .FontName 			= This.ctlFontName
		    .FontSize			= This.ctlFontSize
			.FontStrikethru 	= This.ctlFontStrikethru
			.FontUnderline 		= This.ctlFontUnderline
		Endwith
		
		m.lcLogFont = This.oLogFont.Value
		
		*!* Release Font object if we already have one:
		If This.oFont <> 0 Then
		    apiDeleteObject(This.oFont)
		Endif
		
		*!* Create a new font object:
		This.oFont = apiCreateFontIndirect(@m.lcLogFont)
		
		*!* Set tooltip font to this font object:
		apiSendMessageInteger(This._ControlHwnd, WM_SETFONT, This.oFont, 1)
		
		This._SetFontEnable = TRUE
		
		
	ENDPROC

	HIDDEN PROCEDURE _seticonandtitle
		*!* _SetIconAndTitle()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		Local ;
			lnIcon As Integer, ;
			lcTitle As String
		
		m.lnIcon = This.ctlIcon
		
		*!* Check if a large icon is desired
		If ctlGetOsVersion() >= NTDDI_VISTA And This.ctlIconLarge = TRUE Then
			If Between(m.lnIcon, 1, 3) Then
				m.lnIcon = m.lnIcon + 3
			Endif
		Endif
		
		*!* 20080812
		*!* When calling TTM_SETTITLE, the string pointed to by pszTitle
		*!* must not exceed 100 TCHARs in length, including the terminating NULL.
		
		m.lcTitle = Left(Alltrim(Transform(This.ctlTitle)), 99)
		
		If Empty(m.lcTitle) And (This.ctlIcon > 0 Or This.ctlCloseButton = TRUE) Then
			m.lcTitle = " "
		Endif
		
		m.lcTitle = m.lcTitle + NULA
		
		apiSendMessageString(This._ControlHwnd, TTM_SETTITLEA, m.lnIcon, m.lcTitle)
		
	ENDPROC

	HIDDEN PROCEDURE _setlocalestrings
		*!* _SetLocaleStrings()
		
		*!* 20061011 Added space at end in some strings to avoid compilation errors in DBCS Windows
		*!* language strings extracted from comctl32.dll version 6 using String Extractor: http://www.zexersoft.com/products.html
		
		Local lcLocaleInfo As Character, ;
			lcTitle As Character ;
			lcText As Character, ;
			lnLangID As Number, ;
			lnPrimaryLangID As Number, ;
			lnSubLangID As Number
		
		
		If This.ctlLangID = 0x0 Then
			m.lnPrimaryLangID = ctlGetPrimaryLangID(LOCALE_USER_DEFAULT)
			m.lnSubLangID     = ctlGetSubLangID(LOCALE_USER_DEFAULT)
		Else
			*!* If ctlLangID is <> 0 then it overrides the system locale language
			m.lnPrimaryLangID = ctlGetPrimaryLangIDFromLangID(This.ctlLangID)
			m.lnSubLangID = 	ctlGetSubLangIDFromLangID(This.ctlLangID)
		Endif
		
		Do Case
			Case m.lnPrimaryLangID = LANG_BASQUE	&& 0x2d
				m.lcTitle = "Blok Maius piztuta dago"
				m.lcText = "Blok Maius piztuta edukiz gero, zure pasahitza behar ez den bezala sar dezakezu.\r\n\r\nSakatu Blok Maius piztuta egon ez dadila zure pasahitza sartu baino lehen."
		
			Case m.lnPrimaryLangID = LANG_CATALAN	&& 0x03
				m.lcTitle = "La tecla Bloq Maj està activada"
				m.lcText = "Si teniu la tecla Bloq Maj activada, podríeu introduir la contrasenya incorrectament.\r\n\r\nHauríeu de prémer Bloq Maj per desactivar-la abans d'escriure la vostra contrasenya."
		
			Case m.lnPrimaryLangID = LANG_CHINESE And m.lnSubLangID = SUBLANG_CHINESE_TRADITIONAL && 0x04  0x01 Traditional Chinese for Taiwan and Hong Kong
				m.lcTitle = "¤j¼gÂê©w¤w±Ò¥Î "
				m.lcText = "±Ò¥Î¤j¼gÂê©w¥i¯à°µ¦¨±zªº±K½X¿é¤J¿ù»~¡C\r\n\r\n±zÀ³¸Ó«ö¤@¤U¤j¼gÂê©w¡A±N¥¦Ãö³¬¦A¿é¤J±zªº±K½X¡C "
		
			Case m.lnPrimaryLangID = LANG_CHINESE And m.lnSubLangID = SUBLANG_CHINESE_SIMPLIFIED && 0x04 0x02
				m.lcTitle = "´óÐ´Ëø¶¨´ò¿ª¡£ "
				m.lcText = "±£³Ö´óÐ´Ëø¶¨´ò¿ª¿ÉÄÜ»áÊ¹Äú´íÎóÊäÈëÃÜÂë¡£\r\n\r\nÊäÈëÃÜÂëÇ°£¬ÄúÓ¦¸Ã°´¡°Caps Lock¡±¼üÀ´½«Æä¹Ø±Õ¡£ "
		
			Case m.lnPrimaryLangID = LANG_CROATIAN And m.lnSubLangID = SUBLANG_CROATIAN_CROATIA		&& 0x1a 0x01
				m.lcTitle = "Caps Lock je ukljucen"
				m.lcText = "Ako je ukljucen Caps Lock moe se dogoditi da upiete krivu lozinku.\r\n\r\nTrebate pritisnuti Caps Lock kako biste ga iskljucili prije unosa lozinke."
		
			Case m.lnPrimaryLangID = LANG_CZECH		&& 0x05
				m.lcTitle = Trim("Reim Caps Lock je aktivní ")
				m.lcText = "Zapnutí reimu Caps Lock mue zpusobit nesprávné zadání hesla.\r\n\r\nPred zadáním hesla vypnete reim Caps Lock stisknutím klávesy Caps Lock."
		
			Case m.lnPrimaryLangID = LANG_DANISH	&& 0x06
				m.lcTitle = "Caps Lock er slået til"
				m.lcText = "Hvis Caps Lock er slået til, kan det det medføre, at adgangskoden bliver skrevet forkert.\r\n\r\nDu bør trykke på Caps Lock for at slå den fra, før du skriver adgangskoden."
		
			Case m.lnPrimaryLangID = LANG_DUTCH		&& 0x13
				m.lcTitle = "De toets CapsLock staat aan"
				m.lcText = "Als de toets CapsLock is ingeschakeld, wordt het wachtwoord mogelijk onjuist ingevoerd.\r\n\r\nDruk op CapsLock alvorens het wachtwoord in te voeren."
		
			Case m.lnPrimaryLangID = LANG_ENGLISH	&& 0x09
				m.lcTitle = "Caps Lock is On"
				m.lcText = "Having Caps Lock on may cause you to enter your password incorrectly.\r\n\r\nYou should press Caps Lock to turn it off before entering your password."
		
			Case m.lnPrimaryLangID = LANG_ESTONIAN	&& 0x25
				m.lcTitle = "Suurtähelukk on sisse lülitatud"
				m.lcText = "Sisselülitatud suurtähelukk võib põhjustada teie parooli vale sisestamise.\r\n\r\nEnne parooli sisestamist peaksite suurtäheluku klahvi Caps Lock vajutamisega välja lülitama."
		
			Case m.lnPrimaryLangID = LANG_FINNISH	&& 0x0b
				m.lcTitle = Trim("Caps Lock on päällä ")
				m.lcText = "Jos Caps Lock on päällä salasanan isot ja pienet kirjaimet saattavat vaihtua.\r\n\r\nOta Caps Lock pois päältä ennen salasanan kirjoittamista."
		
			Case m.lnPrimaryLangID = LANG_FRENCH	&& 0x0c
				m.lcTitle = "La touche Verr. Maj. est active"
				m.lcText = "La touche Verr. Maj. est enfoncée, ce qui peut fausser la saisie de votre mot de passe.\r\n\r\nAppuyez sur Verr. Maj. pour la désactiver, puis entrez votre mot de passe."
		
			Case m.lnPrimaryLangID = LANG_GALICIAN	&& 0x56
				m.lcTitle = "A tecla Bloq Maiús está activada"
				m.lcText = "Coa tecla Bloq Maiús activada é probábel que introduza o seu contrasinal de forma incorrecta.\r\n\r\nPrémaa para a desactivar antes de introducir o seu contrasinal."
		
			Case m.lnPrimaryLangID = LANG_GERMAN	&& 0x07
				m.lcTitle = "Feststelltaste ist aktiviert"
				m.lcText = "Das Kennwort wird eventuell falsch eingegeben, wenn die Feststelltaste aktiviert ist.\r\n\r\nSie sollten die Feststelltaste deaktivieren, bevor Sie ein Kennwort eingeben."
		
			Case m.lnPrimaryLangID = LANG_HUNGARIAN	&& 0x0e
				m.lcTitle = "A Caps Lock be van kapcsolva"
				m.lcText = "Ha be van kapcsolva a Caps Lock, elofordulhat, hogy hibásan adja meg a jelszót.\r\n\r\nA jelszó beírása elott érdemes kikapcsolnia a Caps Lock billentyu megnyomásával."
		
			Case m.lnPrimaryLangID = LANG_ICELANDIC	&& 0x0f
				m.lcTitle = "Stafalás er virkur"
				m.lcText = "Ef stafalás er virkur gæti aðgangsorð verið fært inn á rangan hátt.\r\n\r\nStyðja ætti á stafalás til að gera hann óvirkan áður en aðgangsorðið er fært inn."
		
			Case m.lnPrimaryLangID = LANG_INDONESIAN	&& 0x21
				m.lcTitle = "Caps Lock dalam posisi On"
				m.lcText = "Bila Caps Lock dalam posisi ON, ada kemungkinan Anda keliru memasukkan sandi.\r\n\r\nAnda harus menekan Caps Lock untuk mematikannya sebelum memasukkan sandi."
		
			Case m.lnPrimaryLangID = LANG_ITALIAN	&& 0x10
				m.lcTitle = "BLOC MAIUSC - Attivato"
				m.lcText = "Se il tasto BLOC MAIUSC è attivo può accadere di digitare la password in modo errato.\r\n\r\nPremere il tasto BLOC MAIUSC per disattivarlo prima di digitare la password."
		
			Case m.lnPrimaryLangID = LANG_LATVIAN	&& 0x26
				m.lcTitle = "Ir ieslegts taustin Caps Lock"
				m.lcText = "Ja ir ieslegts taustin Caps Lock, parole, iespejams, tiks ievadita nepareizi.\r\n\r\nLai to izslegtu, pirms paroles ievadianas taustin Caps Lock janospie."
		
			Case m.lnPrimaryLangID = LANG_LITHUANIAN	&& 0x27
				m.lcTitle = "Ijungtas mygtukas Caps Lock"
				m.lcText = "Jei mygtukas Caps Lock yra ijungtas, del to galite neteisingai ivesti slaptaodi.\r\n\r\nPrie ivesdami slaptaodi spustelekite mygtuka Caps Lock, kad ji ijungtumete."
		
			Case m.lnPrimaryLangID = LANG_MALAY		&& 0x3e
				m.lcTitle = "Caps Lock Dipasang"
				m.lcText = "Penggunaan Caps Lock mungkin akan menyebabkan anda memasukkan kata laluan yang salah.\r\n\r\nAnda sepatutnya menekan Caps Lock untuk mematikannya sebelum memasukkan kata laluan."
		
			Case m.lnPrimaryLangID = LANG_NORWEGIAN		&& 0x14
				m.lcTitle = Trim("Caps Lock er på ")
				m.lcText = "Hvis Caps Lock er på, kan det føre til at passord skrives inn feil.\r\n\r\nPass på at Caps Lock er slått av før du skriver inn passordet."
		
			Case m.lnPrimaryLangID = LANG_POLISH	&& 0x15
				m.lcTitle = "Klawisz Caps Lock jest wlaczony"
				m.lcText = "Wpisywanie przy wlaczonym klawiszu Caps Lock moze spowodowac niepoprawne wprowadzenie hasla.\r\n\r\nPrzed wprowadzeniem hasla nacisnij klawisz Caps Lock, aby go wylaczyc."
		
			Case m.lnPrimaryLangID = LANG_PORTUGUESE And m.lnSubLangID = SUBLANG_PORTUGUESE_BRAZILIAN	&& 0x16 0x01
				m.lcTitle = "Caps Lock está ativada"
				m.lcText = "Se Caps Lock estiver ativado, isso pode fazer com que você digite a senha incorretamente.\r\n\r\nVocê deve pressionar a tecla Caps Lock para desativá-la antes de digitar a senha."
		
			Case m.lnPrimaryLangID = LANG_PORTUGUESE And m.lnSubLangID = SUBLANG_PORTUGUESE_PORTUGAL	&& 0x16 0x02
				m.lcTitle = "Caps Lock está ligado"
				m.lcText = "Ter Caps Lock ligado pode fazer com que introduza incorrectamente a palavra-passe.\r\n\r\nDeve premir Caps Lock para desactivar antes de introduzir a sua palavra-passe."
		
			Case m.lnPrimaryLangID = LANG_ROMANIAN	&& 0x18
				m.lcTitle = "Tasta Caps Lock este activata"
				m.lcText = "Daca tasta Caps Lock este activata exista posibilitatea sa introduceti parola incorect.\r\n\r\nApasati tasta Caps Lock pentru a o dezactiva înainte de a introduce parola."
		
				*!* Andrew L. Shalgochev andluska@hotbox.ru
			Case m.lnPrimaryLangID = LANG_RUSSIAN	&& 0x19
				* russian text in transliteration :) so as understandable
				* Caps Lock vkluchen
				* Parol mozet byt' vveden nepravylno iz-za nazatoi klavishi <Caps Lock>.
				* Otkluchite <Caps Lock> pered tem, kak vvodit' parol.
		
				* the same text encoded by Base64 binary
				m.lcTitle = Strconv("Q2FwcyBMb2NrIOLq6/735e0=", 14)
				m.lcText = Strconv("z+Dw7uv8IOzu5uXyIOH78vwg4uLl5OXtIO3l7/Dg4ujr/O3uIOjnLefgIO3g5uDy7ukg6uvg4uj46CA8Q2FwcyBMb2NrPi5cclxuXHJcbs7y6uv+9+jy5SA8Q2FwcyBMb2NrPiDv5fDl5CDy5ewsIOrg6iDi4u7k6PL8IO/g8O7r/C4=", 14)
		
				* on select, but i thinking in hexbinary is simple and long
				* maybe keep in reserve this code ;-)
				*!*	        * the same text encoded by hexbinary
				*!*	        m.lcTitle = STRCONV("43617073204C6F636B20E2EAEBFEF7E5ED", 16)
				*!*	        m.lcText = STRCONV("CFE0F0EEEBFC20ECEEE6E5F220E1FBF2FC20E2E2E5E4E5ED20EDE5EFF0E0E2E8EBFCEDEE20E8E72DE7E020EDE0E6E0F2EEE920EAEBE0E2E8F8E8203C43617073204C6F636B3E2E5C725C6E5C725C6ECEF2EAEBFEF7E8F2E5203C43617073204C6F636B3E20EFE5F0E5E420F2E5EC2C20EAE0EA20E2E2EEE4E8F2FC20EFE0F0EEEBFC2E", 16)
		
			Case m.lnPrimaryLangID = LANG_SERBIAN And m.lnSubLangID = SUBLANG_SERBIAN_LATIN		&& 0x1a 0x02
				m.lcTitle = "Taster Caps Lock je ukljucen"
				m.lcText = "Ako je ukljucen taster Caps Lock, moe se desiti da unesete pogrenu lozinku.\r\n\r\nTrebalo bi da pritisnete taster Caps Lock da biste ga iskljucili pre unoenja lozinke."
		
			Case m.lnPrimaryLangID = LANG_SLOVAK	&& 0x1b
				m.lcTitle = Trim("Kláves Caps Lock je zapnutý ")
				m.lcText = "Ak je zapnutý kláves Caps Lock, heslo môe byt zadané nesprávne.\r\n\r\nPred zadaním hesla vypnite kláves Caps Lock."
		
			Case m.lnPrimaryLangID = LANG_SLOVENIAN	&& 0x24
				m.lcTitle = "Tipka Caps Lock je vkljucena"
				m.lcText = "Ce je vkljucena tipka Caps Lock, se lahko zgodi, da boste nepravilno vnesli svoje geslo.\r\n\r\nPreden vnesete geslo, pritisnite tipko Caps Lock, da izklopite funkcijo."
		
			Case m.lnPrimaryLangID = LANG_SPANISH	&& 0x0a
				m.lcTitle = "Bloq Mayús activado"
				m.lcText = "Si tiene activada la tecla Bloq Mayús es posible que escriba incorrectamente su contraseña.\r\n\r\nPresione la tecla Bloq Mayús para desactivarla antes de escribir su contraseña."
		
			Case m.lnPrimaryLangID = LANG_SWEDISH	&& 0x1d
				m.lcTitle = "Caps Lock är aktiverat"
				m.lcText = "Om Caps Lock är aktiverat kanske du skriver in ditt lösenord felaktigt.\r\n\r\nInaktivera Caps Lock innan du anger ditt lösenord."
		
			Case m.lnPrimaryLangID = LANG_TURKISH	&& 0x1f
				m.lcTitle = "Caps Lock Açik"
				m.lcText = "Açik Caps Lock parolanizi yanlis girmenize sebep olabilir.\r\n\r\nParolanizi girmeden önce  kapatmak için Caps Lock tusuna basmalisiniz."
		
			Otherwise
				m.lcTitle = "Caps Lock is On"
				m.lcText = "Having Caps Lock on may cause you to enter your password incorrectly.\r\n\r\nYou should press Caps Lock to turn it off before entering your password."
		
		Endcase
		
		This._LangTitle = m.lcTitle
		This._LangText  = Strtran(m.lcText, "\r\n", CRLF)
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _setmargins
		*!* _SetMargins()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		With This.oRect
		    .Top 		= This.ctlMarginTop
		    .Left 		= This.ctlMarginLeft
		    .Right 		= This.ctlMarginRight
		    .Bottom 	= This.ctlMarginBottom
		Endwith
		
		apiSendMessageInteger(This._ControlHwnd, TTM_SETMARGIN, 0, This.oRect.Address)
		
	ENDPROC

	PROCEDURE _show
		*!* _Show()
		
		*!*	CON_BTPOS_NONE 							1
		*!*	CON_BTPOS_LEFTTOP						1
		*!*	CON_BTPOS_ACTIVECTRL 					2
		*!*	CON_BTPOS_CARET							3
		*!*	CON_BTPOS_SYS1270						4
		*!*	CON_BTPOS_CTRLREF						5
		*!*	CON_BTPOS_MOUSE							6
		
		Lparameters m.tnPositionStyle As Integer
		
		*!* If balloonTip is not active, dont show, just return
		If This.ctlActive = FALSE Then
		    Return
		Endif
		
		Local ;
		    lbReturn As Boolean, ;
		    lnPositionStyle As Integer, ;
		    lnLeft As Integer, ;
		    lnTop As Integer, ;
		    lnWidth As Integer, ;
		    lnHeight As Integer, ;
		    loControl As Control, ;
		    lcPoint As String, ;
		    lnOffsetX As Integer, ;
		    lnOffsetY As Integer, ;
		    lnPosition As Integer
		
		*!* lbReturn is set to TRUE when this procedure is called again
		*!* with a different position style
		m.lbReturn = FALSE
		
		*!* If we have a parameter, this method has called itself with a
		*!* different position style as a parameter
		
		If Pcount() = 0 Then
		    m.lnPositionStyle = This.ctlPositionStyle
		Else
		    m.lnPositionStyle = m.tnPositionStyle
		Endif
		
		*!* Now we check which positioning method we should use:
		
		Do Case
		
		    Case m.lnPositionStyle = CON_BTPOS_LEFTTOP && 1
		        *!* This.ctlLeft and This.ctlTop should have been defined
		        *!* by user before getting here.
		        m.lnTop  = This.ctlTop
		        m.lnLeft = This.ctlLeft
		
		    Case m.lnPositionStyle = CON_BTPOS_ACTIVECTRL && 2
		        If Type("Thisform.ActiveControl") = T_OBJECT Then
		            m.loControl = Thisform.ActiveControl
		        Else
		            This._Show(CON_BTPOS_SYS1270)
		            m.lbReturn = TRUE
		        Endif
		
		    Case m.lnPositionStyle = CON_BTPOS_CARET && 3
		        *!* If object has selected text, just call this method again with CON_BTPOS_ACTIVECTRL
		
		        *!* 20070608 added check for caret in control:
		        If Type("Thisform.ActiveControl") = T_OBJECT ;
		                And Pemstatus(Thisform.ActiveControl, "SelLength", CON_PEMSTAT_DEFINED) ;
		                And Thisform.ActiveControl.SelLength = 0
		
		            m.lcPoint = Space(8)
		            *!* Get position of caret
		            apiGetCaretPos(@m.lcPoint)
		            *!* Save coordinates of caret
		            m.lnLeft = ctlGetXFromPoint(m.lcPoint) + 5
		            
		            If This.ctlStyle = CON_BTSTYLE_BALLOON Then
		                m.lnTop  = ctlGetYFromPoint(m.lcPoint) + 10
		            Else
		                m.lnTop  = ctlGetYFromPoint(m.lcPoint) + 20
		            Endif
		        Else
		            This._Show(CON_BTPOS_ACTIVECTRL)
		            m.lbReturn = TRUE
		        Endif
		
		    Case m.lnPositionStyle = CON_BTPOS_SYS1270 && 4
		
		        *!* This control reference was saved in CtlVisible_Assign
		        If Type("This.ctlControl") = T_OBJECT
		            m.loControl = This.ctlControl
		 
		            If m.loControl.BaseClass = "Form" Then
		                This._Show(CON_BTPOS_MOUSE)
		                m.lbReturn = TRUE
		            Endif
		        Else
		            This._Show(CON_BTPOS_MOUSE)
		            m.lbReturn = TRUE
		        Endif
		
		    Case m.lnPositionStyle = CON_BTPOS_CTRLREF && 5
		        If Type("This.ctlControl") = T_OBJECT
		            m.loControl = This.ctlControl
		        Else
		            This._Show(CON_BTPOS_SYS1270)
		            m.lbReturn = TRUE
		        Endif
		
		    Case m.lnPositionStyle >= CON_BTPOS_MOUSE && 6
		        m.lcPoint = Space(8)
		        *!* Get position of mouse cursor
		        apiGetCursorPos(@m.lcPoint)
		        *!* 20070603 Changed Thisform.hWnd to This._HosthWnd
		        apiScreenToClient(This._HostHWnd, @m.lcPoint)
		        m.lnLeft = ctlGetXFromPoint(m.lcPoint)
		        m.lnTop  = ctlGetYFromPoint(m.lcPoint)
		
		        *!* 20070612
		    Otherwise
		        This._Show(CON_BTPOS_MOUSE)
		        m.lbReturn = TRUE
		Endcase
		
		*!* If _Show was called again with another position style, just return now:
		If m.lbReturn = TRUE Then
		    m.loControl = Null
		    Return
		Endif
		
		*!* If the position style is active control, control under mouse, or control reference,
		*!* we calculate position based on control position and size
		
		Do Case
		
		    Case m.lnPositionStyle = CON_BTPOS_LEFTTOP
		        m.lnWidth 	= 0
		        m.lnHeight 	= 0
		        m.lnPosition = This.ctlAlignment
		
		    Case m.lnPositionStyle = CON_BTPOS_CARET
		        m.lnWidth 	= 0
		        m.lnHeight 	= 0
		        m.lnPosition = This.ctlAlignment
		
		    Case m.lnPositionStyle = CON_BTPOS_MOUSE
		        m.lnWidth 	= 16
		        m.lnHeight 	= 16
		        m.lnPosition = This.ctlAlignment
		
		    Otherwise
		        *!* Get position and size of control:
		        m.lnLeft 	= Objtoclient(m.loControl, CON_OBJTOCLI_LEFT)
		        m.lnTop 	= Objtoclient(m.loControl, CON_OBJTOCLI_TOP)
		        m.lnWidth 	= Objtoclient(m.loControl, CON_OBJTOCLI_WIDTH)
		        m.lnHeight 	= Objtoclient(m.loControl, CON_OBJTOCLI_HEIGHT)
		
		        *!* Get offset dimensions from size of control:
		        m.lnPosition = This.ctlPosition
		Endcase
		
		m.lnOffsetX = m.lnWidth  * This.ctlOffsetX - m.lnWidth
		m.lnOffsetY = m.lnHeight * This.ctlOffsetY - m.lnHeight
		*!* Check ctlPosition and adjust left and top:
		
		*!*	*!* Alignment Values
		*!*	CON_ALIGN_MIDDLELEFT		0
		*!*	CON_ALIGN_MIDDLERIGHT		1
		*!*	CON_ALIGN_MIDDLECENTER		2
		*!*	CON_ALIGN_AUTOMATIC			3
		*!*	CON_ALIGN_TOPLEFT			4
		*!*	CON_ALIGN_TOPRIGHT			5
		*!*	CON_ALIGN_TOPCENTER			6
		*!*	CON_ALIGN_BOTTOMLEFT		7
		*!*	CON_ALIGN_BOTTOMRIGHT		8
		*!*	CON_ALIGN_BOTTOMCENTER		9
		
		*!* Vertical:
		Do Case
		
		        *!* Middle (0,1,2):
		    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLELEFT, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_MIDDLECENTER)
		        m.lnTop  = m.lnTop + Int(m.lnHeight / 2)
		
		        *!* Top (4,5,6):
		    Case Inlist(m.lnPosition, CON_ALIGN_TOPLEFT, CON_ALIGN_TOPRIGHT, CON_ALIGN_TOPCENTER)
		        m.lnTop  = m.lnTop - m.lnOffsetY
		
		        *!* Bottom (7,8,9):
		    Case Inlist(m.lnPosition, CON_ALIGN_BOTTOMLEFT, CON_ALIGN_BOTTOMRIGHT, CON_ALIGN_BOTTOMCENTER)
		        m.lnTop  = m.lnTop + m.lnHeight + m.lnOffsetY
		
		    Otherwise
		        *!* (3) Defaults to Bottom:
		        m.lnTop  = m.lnTop + m.lnHeight + m.lnOffsetY
		
		Endcase
		
		*!* Horizontal:
		Do Case
		
		        *!* Left (0,4,7):
		    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLELEFT, CON_ALIGN_TOPLEFT, CON_ALIGN_BOTTOMLEFT)
		        m.lnLeft = m.lnLeft - m.lnOffsetX
		
		        *!* Right (1,5,8):
		    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_TOPRIGHT, CON_ALIGN_BOTTOMRIGHT)
		        m.lnLeft = m.lnLeft + m.lnWidth + m.lnOffsetX
		
		        *!* Center (2,6,9):
		    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
		        m.lnLeft = m.lnLeft + Int(m.lnWidth / 2)
		
		    Otherwise
		        *!* (3) Defaults to Right:
		        m.lnLeft = m.lnLeft + m.lnWidth + m.lnOffsetX
		
		Endcase
		
		*!* Now that we have our Left, Top coordinates, we continue
		
		*!* Now we have two different methods, if the style is ballon, or if the style is
		*!* rectangular tooltip.
		
		*!* For balloon tips, we have to calculate the x,y values to where the tip will point.
		
		If This.ctlStyle = CON_BTSTYLE_BALLOON Then
		
		    This._ShowStyle1(m.lnPositionStyle, m.lnLeft, m.lnTop)
		
		Else && This.ctlStyle = CON_STYLE_BALLOON
		
		    This._ShowStyle2(m.lnPositionStyle, m.lnLeft, m.lnTop)
		Endif
		
		*!* Reset HIDE timer and enable it, so tooltip autohides.
		*!* if tmrHide.Interval is 0 the tooltip will not autohide
		If This.ctlHideDelay > 0 Then
		    This.tmrHide.Reset()
		    This.tmrHide.Enabled = TRUE
		Endif
		
		
		m.loControl = Null
		
	ENDPROC

	HIDDEN PROCEDURE _showstyle1
		*!* _ShowStyle1()
		
		*!* For Balloontips
		
		*!* Check ctlAlignment
		
		*!* As this is a balloon shaped tip, in the case of alignment I have not found a
		*!* way to force the orientation of the balloon in respect to the tip.
		*!* What we do is first create the balloontip in certain positions of the screen
		*!* that we now will give us a balloon with the desired orientation, for example
		*!* if we choose tip coordinates equal to thw width and height of the screen,
		*!* we get a balloon with the tip in its lower right corner
		
		Lparameters m.lnPositionStyle As Integer, m.lnLeft As Integer, m.lnTop As Integer
		
		Local ;
		    lcPoint As String, ;
		    lnX As Integer, ;
		    lnY As Integer, ;
		    lnX2 As Integer, ;
		    lnY2 As Integer, ;
		    lbReposition As Boolean, ;
		    lnParam As Integer
		
		*!* Convert form coordinates to screen coordinates:
		m.lcPoint = ctlMakePoint(m.lnLeft, m.lnTop)
		
		*!* 20070603 Changed Thisform.hWnd to This._HosthWnd
		apiClientToScreen(This._HostHWnd, @m.lcPoint)
		m.lnX = ctlGetXFromPoint(m.lcPoint)
		m.lnY = ctlGetYFromPoint(m.lcPoint)
		
		m.lbReposition = FALSE
		
		*!* Vertical: (No middle alignment for balloon tips)
		
		Do Case
		*!*	    Case Inlist(m.lnPositionStyle, CON_BTPOS_CARET)
		*!*	        m.lnY2 = m.lnY
		
		        *!* Top :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_TOPLEFT, CON_ALIGN_TOPRIGHT, CON_ALIGN_TOPCENTER)
		        m.lnY2 = 8192
		        m.lbReposition = TRUE
		
		        *!* Bottom :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_BOTTOMLEFT, CON_ALIGN_BOTTOMRIGHT, CON_ALIGN_BOTTOMCENTER)
		        m.lnY2 = m.lnY
		
		    Otherwise
		        *!* Defaults to Bottom:
		        m.lnY2 = m.lnY
		Endcase
		
		*!* Horizontal:
		Do Case
		*!*	    Case Inlist(m.lnPositionStyle, CON_BTPOS_CARET)
		*!*	        m.lnX2 = m.lnX
		
		        *!* Left :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLELEFT, CON_ALIGN_TOPLEFT, CON_ALIGN_BOTTOMLEFT)
		        m.lnX2 = Sysmetric(1) - 32
		        m.lbReposition = TRUE
		
		        *!* Right :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_TOPRIGHT, CON_ALIGN_BOTTOMRIGHT)
		        m.lnX2 = m.lnX
		
		        *!* Center : (TTF_CENTERTIP style set in _Create())
		    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
		        m.lnX2 = m.lnX
		
		    Otherwise
		        *!* Defaults to Right:
		        m.lnX2 = m.lnX
		Endcase
		
		**************************************************************************
		
		*!* First position BallonTip in temp coordinates so ballontip gets created with
		*!* the tip in the desired position:
		
		*!* Make DWORD for TTM_TRACKPOSITION message (MAKELPARAM)
		m.lnParam = ctlMakelParam(m.lnX2, m.lnY2)
		
		*!* Set tooltip position
		apiSendMessageInteger(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)
		
		*!* Activate tooltip so we can get size of window:
		apiSendMessageInteger(This._ControlHwnd, TTM_TRACKACTIVATE, 1, This.oToolInfo.Address)
		This._TrackActive = 1
		
		*!* Do we have to reposition the balloon tip to its final position?
		If m.lbReposition = TRUE Then
		    *!* Get size of balloontip:
		
		    apiGetWindowRect(This.ctlHwnd, This.oRect.Address)
		
		    *!* Check vertical position of tip
		    If This.oRect.Top < m.lnY2 Then
		        *!* Tip is on bottom
		        m.lnY = m.lnY - This.oRect.Height
		    Else
		        *!* Tip is on top
		        m.lnY = m.lnY
		    Endif
		
		    *!* Check horizontal position of tip
		    If Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER) Then
		        *!* Tip is centered
		        m.lnX = m.lnX - Int(This.oRect.Width / 2)
		    Else
		        If This.oRect.Left < m.lnX2 - 16 Then
		            *!* Tip is on right
		            m.lnX = m.lnX - This.oRect.Width + 16
		        Else
		            *!* Tip is on left
		            m.lnX = m.lnX - 16
		        Endif
		    Endif
		
		    **! Reposition balloon tip
		    apiSetWindowPos(This._ControlHwnd, ;
		        0, ;
		        m.lnX, ;
		        m.lnY, ;
		        0, ;
		        0, ;
		        Bitor(SWP_NOSIZE, SWP_NOZORDER, SWP_NOACTIVATE))
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE _showstyle2
		*!* _ShowStyle2()
		
		*!* For rectangular tooltips
		
		Lparameters m.lnPositionStyle As Integer, m.lnLeft As Integer, m.lnTop As Integer
		
		
		Local ;
		    lnParam As Integer, ;
		    lnTipHeight As Integer, ;
		    lnTipWidth As Integer
		
		*!* We activate tooltip off screen to get tooltip size:
		
		
		*!* Set Tooltip position way off screen
		m.lnParam = ctlMakelParam(16000, 16000)
		
		*!* Set tooltip position
		apiSendMessageInteger(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)
		
		*!* Activate tooltip
		apiSendMessageInteger(This._ControlHwnd, TTM_TRACKACTIVATE, 1, This.oToolInfo.Address)
		
		This._TrackActive = 1
		
		*!* Now Get size of balloontip:
		apiGetWindowRect(This.ctlHwnd, This.oRect.Address)
		
		
		m.lnTipHeight = This.oRect.Height
		m.lnTipWidth  = This.oRect.Width
		
		**************************************************************************
		
		*!* Check ctlAlignment:
		
		*!* Vertical:
		Do Case
		        *!* Middle :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLELEFT, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_MIDDLECENTER)
		        m.lnTop  = m.lnTop - Ceiling(m.lnTipHeight / 2)
		
		        *!* Top :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_TOPLEFT, CON_ALIGN_TOPRIGHT, CON_ALIGN_TOPCENTER)
		        m.lnTop  = m.lnTop - m.lnTipHeight
		
		        *!* Bottom :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_BOTTOMLEFT, CON_ALIGN_BOTTOMRIGHT, CON_ALIGN_BOTTOMCENTER)
		        m.lnTop  = m.lnTop
		
		    Otherwise
		        m.lnTop  = m.lnTop
		Endcase
		
		*!* Horizontal:
		Do Case
		        *!* Left :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLELEFT, CON_ALIGN_TOPLEFT, CON_ALIGN_BOTTOMLEFT)
		        m.lnLeft = m.lnLeft - m.lnTipWidth
		
		        *!* Right :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_TOPRIGHT, CON_ALIGN_BOTTOMRIGHT)
		        m.lnLeft = m.lnLeft
		
		        *!* Center :
		    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
		        m.lnLeft = m.lnLeft - Int(m.lnTipWidth / 2)
		
		    Otherwise
		        m.lnLeft = m.lnLeft
		Endcase
		
		**************************************************************************
		
		*!* Now we position the tip:
		
		*!* Get lParam for TTM_TRACKPOSITION message
		m.lnParam = This._GetTrackPosParam(m.lnLeft, m.lnTop)
		
		*!* Set tooltip position, already activated off screen
		apiSendMessageInteger(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

	PROCEDURE tmrHide.Timer
		If This.Parent.ctlVisible = TRUE Then
		    This.Parent.ctlVisible = FALSE
		    Raiseevent(This.Parent, "ctlHide", 0)
		Endif
		
	ENDPROC

	PROCEDURE tmrShow.Timer
		*!* Disable this timer
		This.Enabled = FALSE
		This.Parent._Show()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_commondialog AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlgetknownfolderidlist
		*m: ctlgetknownfolderpath		&& Gets a special folder path.
		*m: ctlhelprequest		&& Occurs when the user clicks the Help button on a common dialog box.
		*m: ctlhookproc		&& Defines the common dialog box hook procedure that is overridden to add specific functionality to a common dialog box.
		*m: ctlonhelprequest		&& Raises the HelpRequest event.
		*m: ctlreset		&& When overridden in a derived class, resets the properties of a common dialog box to their default values.
		*m: ctlrundialog		&& When overridden in a derived class, specifies a common dialog box.
		*m: ctlshowdialog		&& Runs a common dialog box.
		*m: _createcallback
		*m: _destroycallback
		*m: _initlibrary
		*m: _loadstring
		*m: _resetproperties
		*m: _saveproperties
		*m: _setproperties
		*p: ctltitle		&& Gets or sets the file dialog box title.
		*a: _properties[1,1]
		*p: _callbackpointer
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	ctltitle = 		&& Gets or sets the file dialog box title.
	Height = 23
	Name = "ctl32_commondialog"
	Visible = .F.
	Width = 120
	_callbackpointer = 0

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_commondialog", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 4, ;
		Width = 98
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE ctlgetknownfolderidlist
		*!* ctlGetKnownFolderList(cFolderId|qFolderId)
		
		*!* Vista: SHGetKnownFolderIDList
		*!* Win2K: SHGetFolderLocation
		*!* Win95: SHGetSpecialFolderLocation
		
		Lparameters puFolderId
		
		Local ;
			lqFolderId, ;
			lnCsidl, ;
			lnPIDL, ;
			lnResult, ;
			lnPointer
		
		*!* Initialize variables
		m.lnPIDL = 0
		m.lqFolderId = 0h
		m.lnCsidl = 0xFFFF
		
		If Vartype(m.puFolderId) = "C"
			m.puFolderId = Upper(Alltrim(m.puFolderId))
			*!* Remove prefix
			m.puFolderId = Strtran(m.puFolderId, "FOLDERID_", "", 1, 1)
		Endif
		
		Do Case
		
			Case Vartype(m.puFolderId) = "Q"
				*!* If we have a binary parameter, lets assume its a valid FOLDERID
				m.lqFolderId = m.puFolderId
		
			Case Vartype(m.puFolderId) # "C"
				*!* From here, m.puFolderId can only be of type character
		
			Case m.puFolderId = "ADDNEWPROGRAMS"
				m.lqFolderId = FOLDERID_AddNewPrograms
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "ADMINTOOLS"
				m.lqFolderId = FOLDERID_AdminTools
				m.lnCsidl = CSIDL_ADMINTOOLS
		
			Case m.puFolderId = "APPUPDATES"
				m.lqFolderId = FOLDERID_AppUpdates
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "CDBURNING"
				m.lqFolderId = FOLDERID_CDBurning
				m.lnCsidl = CSIDL_CDBURN_AREA
		
			Case m.puFolderId = "CHANGEREMOVEPROGRAMS"
				m.lqFolderId = FOLDERID_ChangeRemovePrograms
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "COMMONADMINTOOLS"
				m.lqFolderId = FOLDERID_CommonAdminTools
				m.lnCsidl = CSIDL_COMMON_ADMINTOOLS
		
			Case m.puFolderId = "COMMONOEMLINKS"
				m.lqFolderId = FOLDERID_CommonOEMLinks
				m.lnCsidl = CSIDL_COMMON_OEM_LINKS
		
			Case m.puFolderId = "COMMONPROGRAMS"
				m.lqFolderId = FOLDERID_CommonPrograms
				m.lnCsidl = CSIDL_COMMON_PROGRAMS
		
			Case m.puFolderId = "COMMONSTARTMENU"
				m.lqFolderId = FOLDERID_CommonStartMenu
				m.lnCsidl = CSIDL_COMMON_STARTMENU
		
			Case m.puFolderId = "COMMONSTARTUP"
				m.lqFolderId = FOLDERID_CommonStartup
				m.lnCsidl = CSIDL_COMMON_STARTUP
		
			Case m.puFolderId = "COMMONTEMPLATES"
				m.lqFolderId = FOLDERID_CommonTemplates
				m.lnCsidl = CSIDL_COMMON_TEMPLATES
		
			Case m.puFolderId = "COMPUTERFOLDER"
				m.lqFolderId = FOLDERID_ComputerFolder
				m.lnCsidl = CSIDL_DRIVES
		
			Case m.puFolderId = "CONFLICTFOLDER"
				m.lqFolderId = FOLDERID_ConflictFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "CONNECTIONSFOLDER"
				m.lqFolderId = FOLDERID_ConnectionsFolder
				m.lnCsidl = CSIDL_CONNECTIONS
		
			Case m.puFolderId = "CONTACTS"
				m.lqFolderId = FOLDERID_Contacts
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "CONTROLPANELFOLDER"
				m.lqFolderId = FOLDERID_ControlPanelFolder
				m.lnCsidl = CSIDL_CONTROLS
		
			Case m.puFolderId = "COOKIES"
				m.lqFolderId = FOLDERID_Cookies
				m.lnCsidl = CSIDL_COOKIES
		
			Case m.puFolderId = "DESKTOP"
				m.lqFolderId = FOLDERID_Desktop
				m.lnCsidl = CSIDL_DESKTOP
		
			Case m.puFolderId = "DOCUMENTS"
				m.lqFolderId = FOLDERID_Documents
				m.lnCsidl = CSIDL_MYDOCUMENTS
		
			Case m.puFolderId = "DOWNLOADS"
				m.lqFolderId = FOLDERID_Downloads
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "FAVORITES"
				m.lqFolderId = FOLDERID_Favorites
				m.lnCsidl = CSIDL_FAVORITES
		
			Case m.puFolderId = "FONTS"
				m.lqFolderId = FOLDERID_Fonts
				m.lnCsidl = CSIDL_FONTS
		
			Case m.puFolderId = "GAMES"
				m.lqFolderId = FOLDERID_Games
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "GAMETASKS"
				m.lqFolderId = FOLDERID_GameTasks
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "HISTORY"
				m.lqFolderId = FOLDERID_History
				m.lnCsidl = CSIDL_HISTORY
		
			Case m.puFolderId = "INTERNETCACHE"
				m.lqFolderId = FOLDERID_InternetCache
				m.lnCsidl = CSIDL_INTERNET_CACHE
		
			Case m.puFolderId = "INTERNETFOLDER"
				m.lqFolderId = FOLDERID_InternetFolder
				m.lnCsidl = CSIDL_INTERNET
		
			Case m.puFolderId = "LINKS"
				m.lqFolderId = FOLDERID_Links
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "LOCALAPPDATA"
				m.lqFolderId = FOLDERID_LocalAppData
				m.lnCsidl = CSIDL_LOCAL_APPDATA
		
			Case m.puFolderId = "LOCALAPPDATALOW"
				m.lqFolderId = FOLDERID_LocalAppDataLow
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "LOCALIZEDRESOURCESDIR"
				m.lqFolderId = FOLDERID_LocalizedResourcesDir
				m.lnCsidl = CSIDL_RESOURCES_LOCALIZED
		
			Case m.puFolderId = "MUSIC"
				m.lqFolderId = FOLDERID_Music
				m.lnCsidl = CSIDL_MYMUSIC
		
			Case m.puFolderId = "NETHOOD"
				m.lqFolderId = FOLDERID_NetHood
				m.lnCsidl = CSIDL_NETHOOD
		
			Case m.puFolderId = "NETWORKFOLDER"
				m.lqFolderId = FOLDERID_NetworkFolder
				m.lnCsidl = CSIDL_NETWORK
		
			Case m.puFolderId = "ORIGINALIMAGES"
				m.lqFolderId = FOLDERID_OriginalImages
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PHOTOALBUMS"
				m.lqFolderId = FOLDERID_PhotoAlbums
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PICTURES"
				m.lqFolderId = FOLDERID_Pictures
				m.lnCsidl = CSIDL_MYPICTURES
		
			Case m.puFolderId = "PLAYLISTS"
				m.lqFolderId = FOLDERID_Playlists
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PRINTERSFOLDER"
				m.lqFolderId = FOLDERID_PrintersFolder
				m.lnCsidl = CSIDL_PRINTERS
		
			Case m.puFolderId = "PRINTHOOD"
				m.lqFolderId = FOLDERID_PrintHood
				m.lnCsidl = CSIDL_PRINTHOOD
		
			Case m.puFolderId = "PROFILE"
				m.lqFolderId = FOLDERID_Profile
				m.lnCsidl = CSIDL_PROFILE
		
			Case m.puFolderId = "PROGRAMDATA"
				m.lqFolderId = FOLDERID_ProgramData
				m.lnCsidl = CSIDL_COMMON_APPDATA
		
			Case m.puFolderId = "PROGRAMFILES"
				m.lqFolderId = FOLDERID_ProgramFiles
				m.lnCsidl = CSIDL_PROGRAM_FILES
		
			Case m.puFolderId = "PROGRAMFILESX64"
				m.lqFolderId = FOLDERID_ProgramFilesX64
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PROGRAMFILESX86"
				m.lqFolderId = FOLDERID_ProgramFilesX86
				m.lnCsidl = CSIDL_PROGRAM_FILESX86
		
			Case m.puFolderId = "PROGRAMFILESCOMMON"
				m.lqFolderId = FOLDERID_ProgramFilesCommon
				m.lnCsidl = CSIDL_PROGRAM_FILES_COMMON
		
			Case m.puFolderId = "PROGRAMFILESCOMMONX64"
				m.lqFolderId = FOLDERID_ProgramFilesCommonX64
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PROGRAMFILESCOMMONX86"
				m.lqFolderId = FOLDERID_ProgramFilesCommonX86
				m.lnCsidl = CSIDL_PROGRAM_FILES_COMMONX86
		
			Case m.puFolderId = "PROGRAMS"
				m.lqFolderId = FOLDERID_Programs
				m.lnCsidl = CSIDL_PROGRAMS
		
			Case m.puFolderId = "PUBLIC"
				m.lqFolderId = FOLDERID_Public
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PUBLICDESKTOP"
				m.lqFolderId = FOLDERID_PublicDesktop
				m.lnCsidl = CSIDL_COMMON_DESKTOPDIRECTORY
		
			Case m.puFolderId = "PUBLICDOCUMENTS"
				m.lqFolderId = FOLDERID_PublicDocuments
				m.lnCsidl = CSIDL_COMMON_DOCUMENTS
		
			Case m.puFolderId = "PUBLICDOWNLOADS"
				m.lqFolderId = FOLDERID_PublicDownloads
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PUBLICGAMETASKS"
				m.lqFolderId = FOLDERID_PublicGameTasks
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PUBLICMUSIC"
				m.lqFolderId = FOLDERID_PublicMusic
				m.lnCsidl = CSIDL_COMMON_MUSIC
		
			Case m.puFolderId = "PUBLICPICTURES"
				m.lqFolderId = FOLDERID_PublicPictures
				m.lnCsidl = CSIDL_COMMON_PICTURES
		
			Case m.puFolderId = "PUBLICVIDEOS"
				m.lqFolderId = FOLDERID_PublicVideos
				m.lnCsidl = CSIDL_COMMON_VIDEO
		
			Case m.puFolderId = "QUICKLAUNCH"
				m.lqFolderId = FOLDERID_QuickLaunch
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "RECENT"
				m.lqFolderId = FOLDERID_Recent
				m.lnCsidl = CSIDL_RECENT
		
			Case m.puFolderId = "RECORDEDTV"
				m.lqFolderId = FOLDERID_RecordedTV
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "RECYCLEBINFOLDER"
				m.lqFolderId = FOLDERID_RecycleBinFolder
				m.lnCsidl = CSIDL_BITBUCKET
		
			Case m.puFolderId = "RESOURCEDIR"
				m.lqFolderId = FOLDERID_ResourceDir
				m.lnCsidl = CSIDL_RESOURCES
		
			Case m.puFolderId = "ROAMINGAPPDATA"
				m.lqFolderId = FOLDERID_RoamingAppData
				m.lnCsidl = CSIDL_APPDATA
		
			Case m.puFolderId = "SAMPLEMUSIC"
				m.lqFolderId = FOLDERID_SampleMusic
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAMPLEPICTURES"
				m.lqFolderId = FOLDERID_SamplePictures
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAMPLEPLAYLISTS"
				m.lqFolderId = FOLDERID_SamplePlaylists
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAMPLEVIDEOS"
				m.lqFolderId = FOLDERID_SampleVideos
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAVEDGAMES"
				m.lqFolderId = FOLDERID_SavedGames
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAVEDSEARCHES"
				m.lqFolderId = FOLDERID_SavedSearches
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SEARCH_CSC"
				m.lqFolderId = FOLDERID_SEARCH_CSC
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SEARCH_MAPI"
				m.lqFolderId = FOLDERID_SEARCH_MAPI
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SEARCHHOME"
				m.lqFolderId = FOLDERID_SearchHome
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SENDTO"
				m.lqFolderId = FOLDERID_SendTo
				m.lnCsidl = CSIDL_SENDTO
		
			Case m.puFolderId = "SIDEBARDEFAULTPARTS "
				m.lqFolderId = FOLDERID_SidebarDefaultParts
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SIDEBARPARTS "
				m.lqFolderId = FOLDERID_SidebarParts
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "STARTMENU"
				m.lqFolderId = FOLDERID_StartMenu
				m.lnCsidl = CSIDL_STARTMENU
		
			Case m.puFolderId = "STARTUP"
				m.lqFolderId = FOLDERID_Startup
				m.lnCsidl = CSIDL_STARTUP
		
			Case m.puFolderId = "SYNCMANAGERFOLDER"
				m.lqFolderId = FOLDERID_SyncManagerFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SYNCRESULTSFOLDER"
				m.lqFolderId = FOLDERID_SyncResultsFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SYNCSETUPFOLDER"
				m.lqFolderId = FOLDERID_SyncSetupFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SYSTEM"
				m.lqFolderId = FOLDERID_System
				m.lnCsidl = CSIDL_SYSTEM
		
			Case m.puFolderId = "SYSTEMX86"
				m.lqFolderId = FOLDERID_SystemX86
				m.lnCsidl = CSIDL_SYSTEMX86
		
			Case m.puFolderId = "TEMPLATES"
				m.lqFolderId = FOLDERID_Templates
				m.lnCsidl = CSIDL_TEMPLATES
		
			Case m.puFolderId = "TREEPROPERTIES"
				m.lqFolderId = FOLDERID_TreeProperties
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "USERPROFILES"
				m.lqFolderId = FOLDERID_UserProfiles
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "USERSFILES"
				m.lqFolderId = FOLDERID_UsersFiles
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "VIDEOS"
				m.lqFolderId = FOLDERID_Videos
				m.lnCsidl = CSIDL_MYVIDEO
		
			Case m.puFolderId = "WINDOWS"
				m.lqFolderId = FOLDERID_Windows
				m.lnCsidl = CSIDL_WINDOWS
		
		Endcase
		
		If ctlGetOsVersion() >= NTDDI_VISTA Then
		
		Else
		
			If m.lnCsidl # 0xFFFF Then
		
				m.lnCsidl = Bitor(m.lnCsidl, CSIDL_FLAG_CREATE)
				m.lnPIDL = 0
		
				If apiSHGetFolderLocation(0, m.lnCsidl, 0, 0, @m.lnPIDL) = ERROR_FILE_NOT_FOUND Then
		
					*!* call apiSHGetFolderPath so folder gets created
					m.lcFolderPath = Replicate(Chr(0), MAX_PATH)
					apiSHGetFolderPath(0, m.lnCsidl, 0, SHGFP_TYPE_CURRENT, @m.lcFolderPath)
		
					*!* Try again
					apiSHGetFolderLocation(0, m.lnCsidl, 0, 0, @m.lnPIDL)
		
				Endif
		
			Endif
		
		Endif
		
		Return m.lnPIDL
		
		
		
	ENDPROC

	PROCEDURE ctlgetknownfolderpath		&& Gets a special folder path.
		*!* ctlGetKnownFolderPath(cFolderId|qFolderId)
		
		*!* Vista: SHGetKnownFolderPath
		*!* Win2K: SHGetFolderPath
		*!* Win95: SHGetSpecialFolderPath
		
		Lparameters puFolderId
		
		Local ;
			lqFolderId, ;
			lnCsidl, ;
			lcFolderPath, ;
			lnResult, ;
			lnPointer
		
		*!* Initialize variables
		m.lcFolderPath 	= ""
		m.lqFolderId = 0h
		m.lnCsidl = 0xFFFF
		
		If Vartype(m.puFolderId) = "C"
			m.puFolderId = Upper(Alltrim(m.puFolderId))
			*!* Remove prefix
			m.puFolderId = Strtran(m.puFolderId, "FOLDERID_", "", 1, 1)
		Endif
		
		Do Case
		
			Case Vartype(m.puFolderId) = "Q"
				*!* If we have a binary parameter, lets assume its a valid FOLDERID
				m.lqFolderId = m.puFolderId
		
			Case Vartype(m.puFolderId) # "C"
				*!* From here, m.puFolderId can only be of type character
		
			Case m.puFolderId = "ADDNEWPROGRAMS"
				m.lqFolderId = FOLDERID_AddNewPrograms
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "ADMINTOOLS"
				m.lqFolderId = FOLDERID_AdminTools
				m.lnCsidl = CSIDL_ADMINTOOLS
		
			Case m.puFolderId = "APPUPDATES"
				m.lqFolderId = FOLDERID_AppUpdates
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "CDBURNING"
				m.lqFolderId = FOLDERID_CDBurning
				m.lnCsidl = CSIDL_CDBURN_AREA
		
			Case m.puFolderId = "CHANGEREMOVEPROGRAMS"
				m.lqFolderId = FOLDERID_ChangeRemovePrograms
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "COMMONADMINTOOLS"
				m.lqFolderId = FOLDERID_CommonAdminTools
				m.lnCsidl = CSIDL_COMMON_ADMINTOOLS
		
			Case m.puFolderId = "COMMONOEMLINKS"
				m.lqFolderId = FOLDERID_CommonOEMLinks
				m.lnCsidl = CSIDL_COMMON_OEM_LINKS
		
			Case m.puFolderId = "COMMONPROGRAMS"
				m.lqFolderId = FOLDERID_CommonPrograms
				m.lnCsidl = CSIDL_COMMON_PROGRAMS
		
			Case m.puFolderId = "COMMONSTARTMENU"
				m.lqFolderId = FOLDERID_CommonStartMenu
				m.lnCsidl = CSIDL_COMMON_STARTMENU
		
			Case m.puFolderId = "COMMONSTARTUP"
				m.lqFolderId = FOLDERID_CommonStartup
				m.lnCsidl = CSIDL_COMMON_STARTUP
		
			Case m.puFolderId = "COMMONTEMPLATES"
				m.lqFolderId = FOLDERID_CommonTemplates
				m.lnCsidl = CSIDL_COMMON_TEMPLATES
		
			Case m.puFolderId = "COMPUTERFOLDER"
				m.lqFolderId = FOLDERID_ComputerFolder
				m.lnCsidl = CSIDL_DRIVES
		
			Case m.puFolderId = "CONFLICTFOLDER"
				m.lqFolderId = FOLDERID_ConflictFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "CONNECTIONSFOLDER"
				m.lqFolderId = FOLDERID_ConnectionsFolder
				m.lnCsidl = CSIDL_CONNECTIONS
		
			Case m.puFolderId = "CONTACTS"
				m.lqFolderId = FOLDERID_Contacts
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "CONTROLPANELFOLDER"
				m.lqFolderId = FOLDERID_ControlPanelFolder
				m.lnCsidl = CSIDL_CONTROLS
		
			Case m.puFolderId = "COOKIES"
				m.lqFolderId = FOLDERID_Cookies
				m.lnCsidl = CSIDL_COOKIES
		
			Case m.puFolderId = "DESKTOP"
				m.lqFolderId = FOLDERID_Desktop
				m.lnCsidl = CSIDL_DESKTOP
		
			Case m.puFolderId = "DOCUMENTS"
				m.lqFolderId = FOLDERID_Documents
				m.lnCsidl = CSIDL_MYDOCUMENTS
		
			Case m.puFolderId = "DOWNLOADS"
				m.lqFolderId = FOLDERID_Downloads
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "FAVORITES"
				m.lqFolderId = FOLDERID_Favorites
				m.lnCsidl = CSIDL_FAVORITES
		
			Case m.puFolderId = "FONTS"
				m.lqFolderId = FOLDERID_Fonts
				m.lnCsidl = CSIDL_FONTS
		
			Case m.puFolderId = "GAMES"
				m.lqFolderId = FOLDERID_Games
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "GAMETASKS"
				m.lqFolderId = FOLDERID_GameTasks
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "HISTORY"
				m.lqFolderId = FOLDERID_History
				m.lnCsidl = CSIDL_HISTORY
		
			Case m.puFolderId = "INTERNETCACHE"
				m.lqFolderId = FOLDERID_InternetCache
				m.lnCsidl = CSIDL_INTERNET_CACHE
		
			Case m.puFolderId = "INTERNETFOLDER"
				m.lqFolderId = FOLDERID_InternetFolder
				m.lnCsidl = CSIDL_INTERNET
		
			Case m.puFolderId = "LINKS"
				m.lqFolderId = FOLDERID_Links
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "LOCALAPPDATA"
				m.lqFolderId = FOLDERID_LocalAppData
				m.lnCsidl = CSIDL_LOCAL_APPDATA
		
			Case m.puFolderId = "LOCALAPPDATALOW"
				m.lqFolderId = FOLDERID_LocalAppDataLow
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "LOCALIZEDRESOURCESDIR"
				m.lqFolderId = FOLDERID_LocalizedResourcesDir
				m.lnCsidl = CSIDL_RESOURCES_LOCALIZED
		
			Case m.puFolderId = "MUSIC"
				m.lqFolderId = FOLDERID_Music
				m.lnCsidl = CSIDL_MYMUSIC
		
			Case m.puFolderId = "NETHOOD"
				m.lqFolderId = FOLDERID_NetHood
				m.lnCsidl = CSIDL_NETHOOD
		
			Case m.puFolderId = "NETWORKFOLDER"
				m.lqFolderId = FOLDERID_NetworkFolder
				m.lnCsidl = CSIDL_NETWORK
		
			Case m.puFolderId = "ORIGINALIMAGES"
				m.lqFolderId = FOLDERID_OriginalImages
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PHOTOALBUMS"
				m.lqFolderId = FOLDERID_PhotoAlbums
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PICTURES"
				m.lqFolderId = FOLDERID_Pictures
				m.lnCsidl = CSIDL_MYPICTURES
		
			Case m.puFolderId = "PLAYLISTS"
				m.lqFolderId = FOLDERID_Playlists
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PRINTERSFOLDER"
				m.lqFolderId = FOLDERID_PrintersFolder
				m.lnCsidl = CSIDL_PRINTERS
		
			Case m.puFolderId = "PRINTHOOD"
				m.lqFolderId = FOLDERID_PrintHood
				m.lnCsidl = CSIDL_PRINTHOOD
		
			Case m.puFolderId = "PROFILE"
				m.lqFolderId = FOLDERID_Profile
				m.lnCsidl = CSIDL_PROFILE
		
			Case m.puFolderId = "PROGRAMDATA"
				m.lqFolderId = FOLDERID_ProgramData
				m.lnCsidl = CSIDL_COMMON_APPDATA
		
			Case m.puFolderId = "PROGRAMFILES"
				m.lqFolderId = FOLDERID_ProgramFiles
				m.lnCsidl = CSIDL_PROGRAM_FILES
		
			Case m.puFolderId = "PROGRAMFILESX64"
				m.lqFolderId = FOLDERID_ProgramFilesX64
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PROGRAMFILESX86"
				m.lqFolderId = FOLDERID_ProgramFilesX86
				m.lnCsidl = CSIDL_PROGRAM_FILESX86
		
			Case m.puFolderId = "PROGRAMFILESCOMMON"
				m.lqFolderId = FOLDERID_ProgramFilesCommon
				m.lnCsidl = CSIDL_PROGRAM_FILES_COMMON
		
			Case m.puFolderId = "PROGRAMFILESCOMMONX64"
				m.lqFolderId = FOLDERID_ProgramFilesCommonX64
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PROGRAMFILESCOMMONX86"
				m.lqFolderId = FOLDERID_ProgramFilesCommonX86
				m.lnCsidl = CSIDL_PROGRAM_FILES_COMMONX86
		
			Case m.puFolderId = "PROGRAMS"
				m.lqFolderId = FOLDERID_Programs
				m.lnCsidl = CSIDL_PROGRAMS
		
			Case m.puFolderId = "PUBLIC"
				m.lqFolderId = FOLDERID_Public
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PUBLICDESKTOP"
				m.lqFolderId = FOLDERID_PublicDesktop
				m.lnCsidl = CSIDL_COMMON_DESKTOPDIRECTORY
		
			Case m.puFolderId = "PUBLICDOCUMENTS"
				m.lqFolderId = FOLDERID_PublicDocuments
				m.lnCsidl = CSIDL_COMMON_DOCUMENTS
		
			Case m.puFolderId = "PUBLICDOWNLOADS"
				m.lqFolderId = FOLDERID_PublicDownloads
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PUBLICGAMETASKS"
				m.lqFolderId = FOLDERID_PublicGameTasks
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "PUBLICMUSIC"
				m.lqFolderId = FOLDERID_PublicMusic
				m.lnCsidl = CSIDL_COMMON_MUSIC
		
			Case m.puFolderId = "PUBLICPICTURES"
				m.lqFolderId = FOLDERID_PublicPictures
				m.lnCsidl = CSIDL_COMMON_PICTURES
		
			Case m.puFolderId = "PUBLICVIDEOS"
				m.lqFolderId = FOLDERID_PublicVideos
				m.lnCsidl = CSIDL_COMMON_VIDEO
		
			Case m.puFolderId = "QUICKLAUNCH"
				m.lqFolderId = FOLDERID_QuickLaunch
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "RECENT"
				m.lqFolderId = FOLDERID_Recent
				m.lnCsidl = CSIDL_RECENT
		
			Case m.puFolderId = "RECORDEDTV"
				m.lqFolderId = FOLDERID_RecordedTV
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "RECYCLEBINFOLDER"
				m.lqFolderId = FOLDERID_RecycleBinFolder
				m.lnCsidl = CSIDL_BITBUCKET
		
			Case m.puFolderId = "RESOURCEDIR"
				m.lqFolderId = FOLDERID_ResourceDir
				m.lnCsidl = CSIDL_RESOURCES
		
			Case m.puFolderId = "ROAMINGAPPDATA"
				m.lqFolderId = FOLDERID_RoamingAppData
				m.lnCsidl = CSIDL_APPDATA
		
			Case m.puFolderId = "SAMPLEMUSIC"
				m.lqFolderId = FOLDERID_SampleMusic
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAMPLEPICTURES"
				m.lqFolderId = FOLDERID_SamplePictures
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAMPLEPLAYLISTS"
				m.lqFolderId = FOLDERID_SamplePlaylists
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAMPLEVIDEOS"
				m.lqFolderId = FOLDERID_SampleVideos
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAVEDGAMES"
				m.lqFolderId = FOLDERID_SavedGames
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SAVEDSEARCHES"
				m.lqFolderId = FOLDERID_SavedSearches
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SEARCH_CSC"
				m.lqFolderId = FOLDERID_SEARCH_CSC
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SEARCH_MAPI"
				m.lqFolderId = FOLDERID_SEARCH_MAPI
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SEARCHHOME"
				m.lqFolderId = FOLDERID_SearchHome
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SENDTO"
				m.lqFolderId = FOLDERID_SendTo
				m.lnCsidl = CSIDL_SENDTO
		
			Case m.puFolderId = "SIDEBARDEFAULTPARTS "
				m.lqFolderId = FOLDERID_SidebarDefaultParts
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SIDEBARPARTS "
				m.lqFolderId = FOLDERID_SidebarParts
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "STARTMENU"
				m.lqFolderId = FOLDERID_StartMenu
				m.lnCsidl = CSIDL_STARTMENU
		
			Case m.puFolderId = "STARTUP"
				m.lqFolderId = FOLDERID_Startup
				m.lnCsidl = CSIDL_STARTUP
		
			Case m.puFolderId = "SYNCMANAGERFOLDER"
				m.lqFolderId = FOLDERID_SyncManagerFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SYNCRESULTSFOLDER"
				m.lqFolderId = FOLDERID_SyncResultsFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SYNCSETUPFOLDER"
				m.lqFolderId = FOLDERID_SyncSetupFolder
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "SYSTEM"
				m.lqFolderId = FOLDERID_System
				m.lnCsidl = CSIDL_SYSTEM
		
			Case m.puFolderId = "SYSTEMX86"
				m.lqFolderId = FOLDERID_SystemX86
				m.lnCsidl = CSIDL_SYSTEMX86
		
			Case m.puFolderId = "TEMPLATES"
				m.lqFolderId = FOLDERID_Templates
				m.lnCsidl = CSIDL_TEMPLATES
		
			Case m.puFolderId = "TREEPROPERTIES"
				m.lqFolderId = FOLDERID_TreeProperties
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "USERPROFILES"
				m.lqFolderId = FOLDERID_UserProfiles
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "USERSFILES"
				m.lqFolderId = FOLDERID_UsersFiles
				m.lnCsidl = 0xFFFF
		
			Case m.puFolderId = "VIDEOS"
				m.lqFolderId = FOLDERID_Videos
				m.lnCsidl = CSIDL_MYVIDEO
		
			Case m.puFolderId = "WINDOWS"
				m.lqFolderId = FOLDERID_Windows
				m.lnCsidl = CSIDL_WINDOWS
		
		Endcase
		
		If ctlGetOsVersion() >= NTDDI_VISTA Then
		
			m.lnPointer = 0
			m.lnResult = apiSHGetKnownFolderPath(m.lqFolderId, KF_FLAG_CREATE, 0, @m.lnPointer)
		
			If m.lnResult = S_OK Then
				m.lcFolderPath = Sys(2600, m.lnPointer, apiHeapSize(apiGetProcessHeap(), 0, m.lnPointer))
				m.lcFolderPath = Strconv(m.lcFolderPath, 6)
				apiCoTaskMemFree(m.lnPointer)
			Endif
		
		Else
		
			If m.lnCsidl # 0xFFFF Then
				m.lnCsidl = Bitor(m.lnCsidl, CSIDL_FLAG_CREATE)
				m.lcFolderPath = Replicate(Chr(0), MAX_PATH)
				apiSHGetFolderPath(0, m.lnCsidl, 0, SHGFP_TYPE_CURRENT, @m.lcFolderPath)
				m.lcFolderPath = Left(m.lcFolderPath, At(NULW, m.lcFolderPath) - 1)
			Endif
		
		Endif
		
		Return m.lcFolderPath
		
		
		
	ENDPROC

	PROCEDURE ctlhelprequest		&& Occurs when the user clicks the Help button on a common dialog box.
		*!* ctlHelpRequest()
	ENDPROC

	PROCEDURE ctlhookproc		&& Defines the common dialog box hook procedure that is overridden to add specific functionality to a common dialog box.
		*!* ctlHookProc
		
		Lparameters hdlg As Integer, uiMsg As Integer, wParam As Integer, Lparam As Integer
		
		Return 0
	ENDPROC

	PROCEDURE ctlonhelprequest		&& Raises the HelpRequest event.
		*!* ctlOnHelpRequest()
	ENDPROC

	PROCEDURE ctlreset		&& When overridden in a derived class, resets the properties of a common dialog box to their default values.
		*!* ctlReset()
	ENDPROC

	PROCEDURE ctlrundialog		&& When overridden in a derived class, specifies a common dialog box.
		*!* ctlRunDialog()
	ENDPROC

	PROCEDURE ctlshowdialog		&& Runs a common dialog box.
		*!* ctlShowDialog()
	ENDPROC

	PROCEDURE Init
		*!* Init()
		
		*!* This parameter is passed from host ctl32 control
		*!* Lparameters m.tnParam
		
		This.Visible = FALSE
		
		This._InitLibrary()
		This._SetProperties()
		*!*	This._AddObjects()
		*!*	This._SetControlSource()
		*!*	This._SetEnabled()
		*!*	This._BindEvents()
		
		*!* If we have a parameter, some other ctl32 control is parent, do no create control
		*!* Let parent call ctlCreate()
		
		*!*	If Vartype(m.tnParam) = T_LOGICAL Then
		*!*		This._Create()
		*!*	Endif
		
		*!*	Raiseevent(This, "ctlInit")
		
		This._SaveProperties()
	ENDPROC

	PROCEDURE _createcallback
		*!* _CreateCallback()
		
		Local lcVarString As String
		
		m.lcVarString = "INTEGER,INTEGER,INTEGER,INTEGER"
		
		This. _CallBackPointer = CreateCallBackFunc("ctlhookproc","INTEGER", m.lcVarString, This)
		
	ENDPROC

	PROCEDURE _destroycallback
		*!* _DestroyCallback()
		
		DestroyCallbackFunc(This. _CallBackPointer)
		
	ENDPROC

	PROCEDURE _initlibrary
		*!* _InitLibrary()
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
	ENDPROC

	PROCEDURE _loadstring
		Lparameters pcResource, pnStringId As Integer
		
		Local ;
			lnModule As Integer, ;
			llReleaseLibrary As Boolean, ;
			lcString As String
		
		*!* Get module handle of user32 if it is loaded
		m.lnModule = apiGetModuleHandle(m.pcResource)
		
		*!* If not loaded, load it
		If m.lnModule = 0 Then
			m.llReleaseLibrary = TRUE
			m.lnModule = apiLoadLibrary(m.pcResource)
		Else
			m.llReleaseLibrary = FALSE
		Endif
		
		m.lcString = Replicate(NULA, 1024)
		
		m.lnStringLen = apiLoadString(m.lnModule, m.pnStringId, @m.lcString, Len(m.lcString))
		
		m.lcString = Left(m.lcString, m.lnStringLen)
		
		If m.llReleaseLibrary = TRUE Then
			apiFreeLibrary(m.lnModule)
		Endif
		
		Return m.lcString
		
	ENDPROC

	PROCEDURE _resetproperties
		Local lcProperty
		
		With This
			For m.lnx = 1 To Alen(This._Properties, 1)
				If Left(This._Properties(m.lnx,1), 3) = "CTL" Then
					.AddProperty(This._Properties(m.lnx,1), ._Properties(m.lnx, 2))
				Endif
			Endfor
		Endwith
		
		
	ENDPROC

	PROCEDURE _saveproperties
		Local lnPropertyCount, lnx
		
		Local Array aProperties(1)
		
		m.lnPropertyCount = Amembers(m.aProperties, This, 0)
		
		Dimension This._Properties(m.lnPropertyCount, 2)
		
		With This
			For m.lnx = 1 To m.lnPropertyCount
				._Properties(m.lnx,1) = m.aProperties(m.lnx)
				If Left(._Properties(m.lnx,1), 3) = "CTL" Then
					._Properties(m.lnx,2) = Getpem(This, m.aProperties(m.lnx))
				Endif
			Endfor
		Endwith
		
	ENDPROC

	PROCEDURE _setproperties
		*!* _SetProperties()
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_contextmenu AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_contextmenu.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: add		&& Adds a new member to a Collection.
		*m: clear		&& Clears all menus and menu items.
		*m: getsystemmenucaptions
		*m: onwmdrawitem		&& Bindevent to form WM_DRAWITEM
		*m: onwmmeasureitem		&& Bindevent to form WM_MEASUREITEM
		*m: show		&& Displays a Form and specifies if the Form is modal or modeless.
		*m: showcontrolmenu
		*m: showeditmenu
		*m: _addmenu
		*m: _addmenuitem
		*m: _addmenuitemtocollection
		*m: _bindevents
		*m: _setbitmap
		*m: _setmenuiteminfo_hbmpitem
		*m: _setmenuiteminfo_miim_checkmarks
		*p: formhwnd
		*p: menuitems
		*p: menus
		*p: ownerdrawn
		*p: parenthwnd
		*p: showflags		&& http://msdn2.microsoft.com/en-us/library/ms648003.aspx
		*p: _bitmapcanvasheight		&& Item bitmap space height
		*p: _bitmapcanvaswidth		&& Item bitmap space width
		*p: _bitmapheight		&& Bitmap height
		*p: _bitmapwidth		&& Bitmap width
		*p: _brush
		*p: _controlmenubuilt
		*p: _drawitemstruct
		*p: _editmenubuilt
		*p: _lookuptable
		*p: _mainhandle		&& The handle to the top menu in the chain is saved here.
		*p: _measureitemstruct
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _nextmenuitemid
		*p: _windowprocedure
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	formhwnd = .F.
	Height = 21
	menuitems = 
	menus = 
	Name = "ctl32_contextmenu"
	parenthwnd = 0
	showflags = 0		&& http://msdn2.microsoft.com/en-us/library/ms648003.aspx
	Visible = .F.
	Width = 108
	_bitmapcanvasheight = 0		&& Item bitmap space height
	_bitmapcanvaswidth = 0		&& Item bitmap space width
	_bitmapheight = 0		&& Bitmap height
	_bitmapwidth = 0		&& Bitmap width
	_brush = 0
	_controlmenubuilt = .F.
	_drawitemstruct = .F.
	_editmenubuilt = .F.
	_lookuptable = .F.
	_mainhandle = 0		&& The handle to the top menu in the chain is saved here.
	_measureitemstruct = .F.
	_nextmenuitemid = 0
	_windowprocedure = 0

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_contextmenu", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 4, ;
		Width = 94
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE add		&& Adds a new member to a Collection.
		*!* Add
		
		*!* This method adds menu bars, menu popups, menu items,
		*!* and menu items with sub menu popups
		
		Lparameters m.peItemKey1, m.peItemKey2, m.pcCaption, m.pePicture
		
		If Pcount() = 0 Then
			Return
		Endif
		
		If Pcount() = 1 Or Empty(m.peItemKey2) Then
			This._AddMenu(m.peItemKey1)
		Else
			This._AddMenuItem(m.peItemKey1, m.peItemKey2, m.pcCaption, m.pePicture)
		Endif
		
		
		
	ENDPROC

	PROCEDURE clear		&& Clears all menus and menu items.
		*!* Clear
		
		*!* Release all menu popups and ctlMenuPopUp objects
		Do While This.Menus.Count > 0
			apiDestroyMenu(This.Menus(This.Menus.Count).MenuId)
			This.Menus.Remove(This.Menus.Count)
		Enddo
		
		*!* Release ctlMenuItem objects
		Do While This.MenuItems.Count > 0
			If This.MenuItems(This.MenuItems.Count).PictureId <> 0 Then
				apiDeleteObject(This.MenuItems(This.MenuItems.Count).PictureId)
			Endif
			This.MenuItems.Remove(This.MenuItems.Count)
		Enddo
		
		*!* Reset flags that indicate that certain menus have been created
		This._EditMenuBuilt = FALSE
		This._ControlMenuBuilt = FALSE
		
		This._NextMenuItemId = 1
		
	ENDPROC

	PROCEDURE Destroy
		*!* Destroy
		
		This.Clear()
		
		
		
	ENDPROC

	PROCEDURE getsystemmenucaptions
		********************************************************************************
		*!* GetSystemMenuCaptions(m.pnMenuId)
		********************************************************************************
		*!*	This method creates a menu from a specified menu resource id in user32.dll,
		*!* reads all the menu item Texts of the created menu, destroys the menu, and
		*!* returns the Texts as a "|" delimited string
		********************************************************************************
		
		*!* Menu Resource Id 1 in user32.dll:
		*!*	  MENUITEM "&Deshacer", 772
		*!*	  MENUITEM "", 0, MFT_SEPARATOR
		*!*	  MENUITEM "Cor&tar", 768
		*!*	  MENUITEM "&Copiar", 769
		*!*	  MENUITEM "&Pegar", 770
		*!*	  MENUITEM "&Eliminar", 771
		*!*	  MENUITEM "", 0, MFT_SEPARATOR
		*!*	  MENUITEM "Seleccion&ar todo", 177
		*!*	  MENUITEM "", 0, MFT_SEPARATOR
		*!*	  MENUITEM "Lectu&ra de derecha a izquierda", 32768, MFS_GRAYED
		*!*	  MENUITEM "Mo&strar caracteres de control Unicode", 32769, MFS_GRAYED
		
		*!* Menu Resource Id 16 in user32.dll:
		*!*	  MENUITEM "&Restaurar", 61728
		*!*	  MENUITEM "&Mover", 61456
		*!*	  MENUITEM "&Tamaño", 61440
		*!*	  MENUITEM "Mi&nimizar", 61472
		*!*	  MENUITEM "Ma&ximizar", 61488
		*!*	  MENUITEM SEPARATOR
		*!*	  MENUITEM "&Cerrar\tAlt+F4", 61536
		
		
		Lparameters m.pnMenuId As Integer
		
		Local ;
			lnModule As Integer, ;
			llReleaseLibrary As Boolean, ;
			lnMenu As Integer, ;
			lnPopPup As Integer
		
		*!* Get module handle of user32 if it is loaded
		m.lnModule = apiGetModuleHandle("user32.dll")
		
		*!* If not loaded, load it
		If m.lnModule = 0 Then
			m.llReleaseLibrary = TRUE
			m.lnModule = apiLoadLibrary("user32.dll")
		Else
			m.llReleaseLibrary = FALSE
		Endif
		
		*!* Now create a menu from a menu resource
		m.lnMenu = apiLoadMenu(m.lnModule, m.pnMenuId)
		
		*!* Now get the first menu popup of the menubar
		m.lnPopUp = apiGetSubMenu(m.lnMenu, 0)
		
		Local ;
			lnMenuItemCount As Integer, ;
			lnBufferLen As Integer, ;
			lcBuffer As String, ;
			lnMenuTextLen As Integer, ;
			lcMenuCaptions As String
		
		*!* Get number of menu items in menu
		m.lnMenuItemCount = apiGetMenuItemCount(m.lnPopUp)
		m.lnBufferLen = 0xff
		
		*!* Get a string with all the menu item Texts, like: "&Undo|-|&Copy|Cu&t|&Paste|...."
		m.lcMenuCaptions = ""
		For m.lnx = 0 To m.lnMenuItemCount - 1
			m.lcBuffer = Space(m.lnBufferLen)
			m.lnMenuTextLen = apiGetMenuString(m.lnPopUp, m.lnx, @m.lcBuffer, m.lnBufferLen, MF_BYPOSITION)
			If m.lnMenuTextLen = 0 Then
				m.lcMenuCaptions = m.lcMenuCaptions + "-"
			Else
				m.lcMenuCaptions = m.lcMenuCaptions + Left(m.lcBuffer, m.lnMenuTextLen)
			Endif
			If m.lnx < m.lnMenuItemCount - 1 Then
				m.lcMenuCaptions = m.lcMenuCaptions + "|"
			Endif
		Endfor
		
		apiDestroyMenu(m.lnMenu)
		
		If m.llReleaseLibrary = TRUE Then
			apiFreeLibrary(m.lnModule)
		Endif
		
		Return m.lcMenuCaptions
		
	ENDPROC

	PROCEDURE Init
		*!* Init
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		This.MenuItems = Createobject("Collection")
		This.Menus     = Createobject("Collection")
		*This.MenuKeys  = Createobject("Collection")
		
		This._DrawItemStruct    = Createobject("_DRAWITEMSTRUCT", 0)
		This._MeasureItemStruct = Createobject("_MEASUREITEMSTRUCT", 0)
		
		This._NextMenuItemId = 1
		
	ENDPROC

	HIDDEN PROCEDURE onwmdrawitem		&& Bindevent to form WM_DRAWITEM
		*!* OnWmDrawItem
		
		Lparameters m.pnHwnd As Integer, m.pnMsg As Integer, m.pnWparam As Integer, m.pnLparam As Integer
		
		Local ;
			lnLeft, ;
			lnTop, ;
			lnWidth, ;
			lnHeight, ;
			loMenuItem As ctl32_menuitem, ;
			llFound As Boolean, ;
			llDisabled as Boolean, ;
			llHighlighted as Boolean
		
		*!* m.pnlParam is a pointer to a DrawItemStruct structure
		This._DrawItemStruct.Address = m.pnLparam
		
		*!*	With This._DrawItemStruct
		*!*		Debugout .CtlType, .CtlID, .ItemID, .itemAction, .itemState, .hwndItem, .hDC, .ItemData
		*!*	Endwith
		
		********************************************************************************
		*!*	typedef struct tagDRAWITEMSTRUCT {
		*!*	  UINT CtlType;
		*!*	  UINT CtlID;
		*!*	  UINT itemID;
		*!*	  UINT itemAction;
		*!*	  UINT itemState;
		*!*	  HWND hwndItem;
		*!*	  HDC hDC;
		*!*	  RECT rcItem;
		*!*	  ULONG_PTR itemData;
		*!*	} DRAWITEMSTRUCT;
		********************************************************************************
		
		*!* We have a menu item in lnItemID, we are going to look it up in the menu items
		*!* collection. This value is arbitrary, and is set in _AddMenuItemToCollection
		
		m.llFound = FALSE
		
		For m.lnIndex = 1 To This.MenuItems.Count
			If This.MenuItems(m.lnIndex).ItemId = This._DrawItemStruct.ItemID
				m.loMenuItem = This.MenuItems(m.lnIndex)
				m.llFound = TRUE
				Exit
			Endif
		Endfor
		
		*!* If menu item not found, pass message along and return
		If m.llFound = FALSE Then
			Return apiCallWindowProc(This._WindowProcedure, m.pnHwnd, m.pnMsg, m.pnWparam, m.pnLparam)
		Endif
		
		*!* If no picture Id, just return
		If m.loMenuItem.PictureId = 0 Then
			m.loMenuItem = Null
			Return TRUE
		Endif
		
		*m.lPictureObject = m.loMenuItem.PictureObject
		
		*!* Convert HIMETRIC of iPicture to pixels:
		*!* :http://www.experts-exchange.com/Programming/Languages/Visual_Basic/Q_20024530.html
		
		*!*	m.lnHeight 	= ctlHiMetricToPixelsY(m.loMenuItem.PictureObject.Height)
		*!*	m.lnWidth 	= ctlHiMetricToPixelsX(m.loMenuItem.PictureObject.Width)
		
		m.lnHeight = Max(16, apiGetSystemMetrics(SM_CYMENUCHECK))
		m.lnWidth  = Max(16, apiGetSystemMetrics(SM_CXMENUCHECK))
		
		m.lnLeft   	= (This._DrawItemStruct.rcItem.Right - This._DrawItemStruct.rcItem.Left - m.lnWidth) / 2 + This._DrawItemStruct.rcItem.Left
		m.lnTop    	= (This._DrawItemStruct.rcItem.Bottom - This._DrawItemStruct.rcItem.Top - m.lnHeight) / 2 + This._DrawItemStruct.rcItem.Top
		
		ApiDrawIconEx( ;
			This._DrawItemStruct.hDC, ;
			m.lnLeft, ;
			m.lnTop, ;
			m.loMenuItem.PictureId, ;
			m.lnWidth, ;
			m.lnHeight, ;
			0, ;
			0, ;
			DI_NORMAL)
		
		
		*!*	With This._DrawItemStruct
		*!*		?.ctlType, .ctlId, .ItemID, .ItemAction, .ItemState, .hwndItem, .hDC, .rcItem.Left, .rcItem.Top, .rcItem.Right, .rcItem.Bottom
		*!*	Endwith
		
		*!*	m.loGraphics =  _Screen.System.Drawing.Graphics.FromHdc(This._DrawItemStruct.hDC)
		
		*!*	If m.loMenuItem.Enabled = TRUE Then
		*!*		*!* This is Color:
		*!*		m.loGraphics.DrawImage(m.lPictureObject, m.lnLeft, m.lnTop)
		*!*	Else
		*!*		*!* Draw disabled version of bitmap
		*!*		*!* System.Drawing.Graphics.FromHdc FAILS in Vista when the item is disabled, so
		*!*		*!* we check if we have an object
		*!*		*!* TODO: clean up this code, better "disabled" version of bitmap, grayscale, but change tone
		*!*		*!* emulate disabled bitmaps as much as possible maybe use the button face color
		
		*!*		If Vartype(m.loGraphics) ="O" Then
		
		*!*			*!* http://groups.google.kg/group/comp.lang.smalltalk.dolphin/browse_thread/thread/4ab6c6e5cf89cfad/d9a7bbe56adda9ee
		*!*			#Define COLORMATRIX_DISABLED 0.2125, 0.2125, 0.2125, 0, 0, 0.2577, 0.2577, 0.2577, 0, 0, 0.0361, 0.0361, 0.0361, 0, 0, 0, 0, 0, 1, 0, 0.38, 0.38, 0.38, 0, 1
		
		*!*			*!* http://www.codeproject.com/vb/net/colormatrix.asp North America Television Standards Committee values
		*!*			*#define COLORMATRIX_DISABLED 0.299, 0.299, 0.299, 0, 0, 0.587, 0.587, 0.587, 0, 0, 0.114, 0.114, 0.114, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1
		
		*!*			m.loClrMatrix = _Screen.System.Drawing.Imaging.ColorMatrix.New(COLORMATRIX_DISABLED)
		*!*			m.loAttr = _Screen.System.Drawing.Imaging.ImageAttributes.New()
		*!*			m.loAttr.SetColorMatrix(m.loClrMatrix)
		*!*			m.loPixel = _Screen.System.Drawing.GraphicsUnit.Pixel
		*!*			m.loCanvasRect =  _Screen.System.Drawing.Rectangle.New(m.lnLeft, m.lnTop, m.lPictureObject.Width, m.lPictureObject.Height)
		*!*			m.loGraphics.DrawImage(m.lPictureObject, m.loCanvasRect, m.lPictureObject.GetBounds() , m.loPixel, m.loAttr)
		
		*!*		Endif
		*!*	Endif
		
		Return TRUE
		
		
		
	ENDPROC

	HIDDEN PROCEDURE onwmmeasureitem		&& Bindevent to form WM_MEASUREITEM
		*!* OnWmMeasureItem
		Lparameters m.pnHwnd, m.pnMsg, m.pnWparam, m.pnLparam
		
		*!* m.pnWparam contains the value of the CtlID member of the MEASUREITEMSTRUCT
		*!* structure pointed to by the lpMeasureItem parameter. This value identifies
		*!* the control that sent the WM_MEASUREITEM message. If the value is zero,
		*!* the message was sent by a menu.
		
		*!* Some measurements I have done in Windows XP:
		*!*	Menu font size in points-SM_CYMENUCHECK-Height of item w/o pic-height of item w/ pic
		*!*	6-9-17-20
		*!*	8-13-17-20
		*!*	9-13-18-20
		*!*	10-15-20-20
		*!*	11-17-22-22
		*!*	12-19-23-23
		*!*	13-21-25-25
		*!*	14-23-27-27
		
		Local ;
			lnHeight As Integer, ;
			lnWidth As Integer, ;
			lnBorder As Integer
		
		*!* m.pnlParam is a pointer to a MeasureItemStruct structure
		This._MeasureItemStruct.Address = m.pnLparam
		
		With This._MeasureItemStruct
			Debugout .CtlType, .CtlID, .ItemID, .itemWidth, .itemHeight, .ItemData
		Endwith
		********************************************************************************
		*!*	typedef struct tagMEASUREITEMSTRUCT {
		*!*	  UINT CtlType;
		*!*	  UINT CtlID;
		*!*	  UINT itemID;
		*!*	  UINT itemWidth;
		*!*   UINT itemHeight;
		*!*   DWORD itemData
		*!*	} MEASUREITEMSTRUCT;
		********************************************************************************
		
		Local loMenuItem As Object, llFound As Boolean
		
		*!*	m.llFound = FALSE
		*!*	For m.lnIndex = 1 To This.MenuItems.Count
		*!*		If This.MenuItems(m.lnIndex).ItemID = This._MeasureItemStruct.ItemID
		*!*			m.loMenuItem = This.MenuItems(m.lnIndex)
		*!*			m.llFound = TRUE
		*!*			Exit
		*!*		Endif
		*!*	Endfor
		
		If This._MeasureItemStruct.ItemID <= This.MenuItems.Count Then
			m.loMenuItem = This.MenuItems(This._MeasureItemStruct.ItemID)
		Else
			Return apiCallWindowProc(This._WindowProcedure, m.pnHwnd, m.pnMsg, m.pnWparam, m.pnLparam)
		Endif
		
		*!* If menu item not found, pass message along and return
		*!*	If m.llFound = FALSE Then
		*!*		Return apiCallWindowProc(This._WindowProcedure, m.pnHWnd, m.pnMsg, m.pnwParam, m.pnlParam)
		*!*	Endif
		
		*!* For SM_CYMENUCHECK/SM_CXMENUCHECK lower than 15 we have to compensate
		*!* 18 gives us a 20 pixel tall menu item
		
		Local lnHeight As Integer, lnWidth As Integer
		
		m.lnHeight = apiGetSystemMetrics(SM_CYMENUCHECK)
		
		If m.lnHeight <= 15
			m.lnHeight = 18
		Endif
		
		m.lnWidth  = apiGetSystemMetrics(SM_CXMENUCHECK)
		
		If m.lnWidth  <= 15
			m.lnWidth  = 18
		Endif
		
		If ctlGetOsVersion() <= NTDDI_VISTA Or This.OwnerDrawn Then
			This._MeasureItemStruct.itemWidth  = Max(m.lnWidth, This._MeasureItemStruct.itemWidth  - 1)
			This._MeasureItemStruct.itemHeight = Max(m.lnHeight, This._MeasureItemStruct.itemHeight - 1)
		Else
			This._MeasureItemStruct.itemWidth  = Max(m.lnWidth, This._MeasureItemStruct.itemWidth )
			This._MeasureItemStruct.itemHeight = Max(m.lnHeight, This._MeasureItemStruct.itemHeight)
		Endif
		
		m.loMenuItem = Null
		
		Return TRUE
		
	ENDPROC

	PROCEDURE show		&& Displays a Form and specifies if the Form is modal or modeless.
		*!* Show()
		*!* Show(nx, ny)
		*!* Show(nStyle)
		
		Lparameters m.pnX As Integer, m.pnY As Integer, m.plAlreadyScreenCoordinates As Logical
		
		*!* m.pnX and m.pnY specifies the point where menu should be
		*!* positioned, in form coordinates! Should transform to
		*!* screen coordinates
		
		Local ;
			lnFlags As Integer, ;
			lnScreenX As Integer, ;
			lnScreenY As Integer, ;
			lnItemId As Integer
		
		m.lnScreenX = 0
		m.lnScreenY = 0
		
		Do Case
		
				*!* No parameters, show at mouse cursor pos
			Case Pcount() = 0
				ctlGetCursorPos(@m.lnScreenX, @m.lnScreenY)
		
				*!* One parameter = 0 means show at mouse cursor, 1 means show at caret
			Case Pcount() = 1 And Vartype(m.pnX) = "N"
		
				If m.pnX = 0 Then
					*!* Use mouse pointer position
					ctlGetCursorPos(@m.lnScreenX, @m.lnScreenY)
				Else
					*!* Use caret position
					ctlGetCaretPos(@m.lnScreenX, @m.lnScreenY)
					ctlClientToScreen(This.FormHwnd, @m.lnScreenX, @m.lnScreenY)
					*!* add some pixels here
					m.lnScreenX = m.lnScreenX + 4
					m.lnScreenY = m.lnScreenY + 8
				Endif
		
				*!* At least two numeric parameters: x,y coordinates
			Case Vartype(m.pnX) + Vartype(m.pnY) = "NN"
				m.lnScreenX = m.pnX
				m.lnScreenY = m.pnY
		
				*!* If we don´t have a third parameter, this are form coordinates,
				*!* otherwise they are already screen coordinates
				If Pcount() < 3 Then
					ctlClientToScreen(This.FormHwnd, @m.lnScreenX, @m.lnScreenY)
				Endif
		
				*!* show at mouse cursor pos
			Otherwise
				ctlGetCursorPos(@m.lnScreenX, @m.lnScreenY)
		
		Endcase
		
		If Vartype(This.ShowFlags) = "N" Then
			m.lnFlags = Bitor(This.ShowFlags, TPM_RETURNCMD)
		Else
			m.lnFlags = TPM_RETURNCMD
		Endif
		
		m.lnItemId = apiTrackPopupMenuEx(This.Menus(1).MenuId, m.lnFlags, m.lnScreenX, m.lnScreenY, This.FormHwnd, Null)
		
		For m.lnIndex = 1 To This.MenuItems.Count
			If This.MenuItems(m.lnIndex).ItemID = m.lnItemId
				Return This.MenuItems.GetKey(m.lnIndex)
				Exit
			Endif
		Endfor
		
		Return ""
		
		
	ENDPROC

	PROCEDURE showcontrolmenu
		*!* ShowControlMenu
		Lparameters m.pnX As Integer, m.pnY As Integer
		
		Local lcCommand As String
		
		*!* Only build menu if it is not already built
		If This._ControlMenuBuilt = FALSE Then
			This.Clear
		
			If Pemstatus(This, "_ControlTexts", 5) = FALSE Then
				Local lcCaptions As String, lnCaptionsCount As Integer, lnx As Integer
				m.lcCaptions = This.GetSystemMenuCaptions(16)
				m.lnCaptionsCount = Getwordcount(m.lcCaptions,"|")
				This.AddProperty("_ControlTexts(" + Alltrim(Str(m.lnCaptionsCount)) + ")", "")
				For m.lnx = 1 To m.lnCaptionsCount
					This._ControlTexts(m.lnx) = Getwordnum(m.lcCaptions, m.lnx, "|")
				Endfor
			Endif
		
			This.Add("SMENU")
		
		*!* Using OS images
		
			This.Add("SMENU", "RESTORE", 	This._ControlTexts(1), HBMMENU_POPUP_RESTORE)
			This.Add("SMENU", "MOVE",		This._ControlTexts(2))
			This.Add("SMENU", "SIZE",		This._ControlTexts(3))
		
			If _Screen.Activeform.MinButton Then
				This.Add("SMENU", "MINIMIZE", This._ControlTexts(4), HBMMENU_POPUP_MINIMIZE)
			Endif
		
			If _Screen.Activeform.MaxButton Then
				This.Add("SMENU", "MAXIMIZE", This._ControlTexts(5), HBMMENU_POPUP_MAXIMIZE)
			Endif
		
			If _Screen.Activeform.Closable Then
				This.Add("SMENU", "SEPARATOR1", This._ControlTexts(6))
		
		*!* Modify Shortcut key label:
				If _Screen.Activeform.ShowWindow = 2 Then
					This.Add("SMENU", "CLOSE", This._ControlTexts(7), HBMMENU_POPUP_CLOSE)
				Else
					This.Add("SMENU", "CLOSE", Getwordnum(This._ControlTexts(7), 1, TABCHAR) + TABCHAR + "Ctrl+F4", HBMMENU_POPUP_CLOSE)
				Endif
		
				This.MenuItems("CLOSE").DefaultItem = TRUE
			Endif
		
			This._ControlMenuBuilt = TRUE
		Endif
		
		*!* Set menu items state:
		
		Do Case
			Case _Screen.Activeform.WindowState = 0
				This.MenuItems("RESTORE").Enabled = FALSE
				This.MenuItems("MOVE").Enabled = TRUE
				This.MenuItems("SIZE").Enabled = TRUE
				If _Screen.Activeform.MinButton Then
					This.MenuItems("MINIMIZE").Enabled = TRUE
				Endif
				If _Screen.Activeform.MaxButton Then
					This.MenuItems("MAXIMIZE").Enabled = TRUE
				Endif
		
			Case _Screen.Activeform.WindowState = 1
				This.MenuItems("RESTORE").Enabled = TRUE
				This.MenuItems("MOVE").Enabled = FALSE
				This.MenuItems("SIZE").Enabled = FALSE
				If _Screen.Activeform.MinButton Then
					This.MenuItems("MINIMIZE").Enabled = FALSE
				Endif
				If _Screen.Activeform.MaxButton Then
					This.MenuItems("MAXIMIZE").Enabled = TRUE
				Endif
		
			Case _Screen.Activeform.WindowState = 2
				This.MenuItems("RESTORE").Enabled = TRUE
				This.MenuItems("MOVE").Enabled = FALSE
				This.MenuItems("SIZE").Enabled = FALSE
				If _Screen.Activeform.MinButton Then
					This.MenuItems("MINIMIZE").Enabled = TRUE
				Endif
				If _Screen.Activeform.MaxButton Then
					This.MenuItems("MAXIMIZE").Enabled = FALSE
				Endif
		
		Endcase
		
		m.lcCommand = This.Show(m.pnX, m.pnY)
		
		Do Case
			Case m.lcCommand = "RESTORE"
				apiSendMessageInteger(This.FormHwnd, WM_SYSCOMMAND, SC_RESTORE, 0)
			Case m.lcCommand = "MOVE"
				apiSendMessageInteger(This.FormHwnd, WM_SYSCOMMAND, SC_MOVE, 0)
			Case m.lcCommand = "SIZE"
				apiSendMessageInteger(This.FormHwnd, WM_SYSCOMMAND, SC_SIZE, 0)
			Case m.lcCommand = "MINIMIZE"
				apiSendMessageInteger(This.FormHwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0)
			Case m.lcCommand = "MAXIMIZE"
				apiSendMessageInteger(This.FormHwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0)
			Case m.lcCommand = "CLOSE"
				apiSendMessageInteger(This.FormHwnd, WM_SYSCOMMAND, SC_CLOSE, 0)
			Otherwise
		Endcase
		
		
		
		
		
	ENDPROC

	PROCEDURE showeditmenu
		*!* ShowEditMenu
		Lparameters m.pnX As Integer, m.pnY As Integer
		
		Local lcCommand As String
		
		This.Clear
		
		If This._EditMenuBuilt = FALSE Then
		
			This.Clear
		
			*!* Get Edit menu Texts from Windows if we have not done it already:
			If Pemstatus(This, "_EditTexts", 5) = FALSE Then
		
				Local ;
					lcCaptions As String, ;
					lnCaptionsCount As Integer, ;
					lnx As Integer
		
				m.lcCaptions = This.GetSystemMenuCaptions(1)
				m.lnCaptionsCount = Getwordcount(m.lcCaptions,"|")
		
				This.AddProperty("_EditTexts(" + Alltrim(Str(m.lnCaptionsCount)) + ")", "")
		
				For m.lnx = 1 To m.lnCaptionsCount
					This._EditTexts(m.lnx) = Alltrim(Getwordnum(m.lcCaptions, m.lnx, "|"))
				Endfor
			Endif
		
			*!* Add main popup
			This.Add("_MEDIT")
		
			This.Add("_MEDIT", "_MED_UNDO",  This._EditTexts(1), "edit_undo_16x16.ico")
			This.Add("_MEDIT", "SEPARATOR1", This._EditTexts(2))
			This.Add("_MEDIT", "_MED_CUT", 	 This._EditTexts(3), "edit_cut_16x16.ico")
			This.Add("_MEDIT", "_MED_COPY",	 This._EditTexts(4), "edit_copy_16x16.ico")
			This.Add("_MEDIT", "_MED_PASTE", This._EditTexts(5), "edit_paste_16x16.ico")
			This.Add("_MEDIT", "_MED_CLEAR", This._EditTexts(6))
			This.Add("_MEDIT", "SEPARATOR2", This._EditTexts(7))
			This.Add("_MEDIT", "_MED_SLCTA", This._EditTexts(8))
		
			This._EditMenuBuilt = TRUE
		
		Endif
		
		*!* Set menu items state:
		If _Screen.ActiveForm.ActiveControl.BaseClass = "Olecontrol" Then
			If apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, EM_CANUNDO, 0, 0) = 0 Then
				This.MenuItems("_MED_UNDO").Enabled = .F.
			Else
				This.MenuItems("_MED_UNDO").Enabled = .T.
			Endif
			If apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, EM_CANPASTE, 0, 0) = 0 Then
				This.MenuItems("_MED_PASTE").Enabled = .F.
			Else
				This.MenuItems("_MED_PASTE").Enabled = .T.
			Endif
		
		Else
			This.MenuItems("_MED_UNDO").Enabled = Not Skpbar("_MEDIT", _Med_undo)
			This.MenuItems("_MED_PASTE").Enabled = Not Empty(_Cliptext)
		Endif
		
		*!* Skpbar(...) fails when you right click in a control that does not have the focus
		*!* Skpbar still reflects the state of the previous active control
		
		If Type("_Screen.Activeform.ActiveControl.SelLength") = "N" Then
			This.MenuItems("_MED_CUT").Enabled = _Screen.ActiveForm.ActiveControl.SelLength > 0
			This.MenuItems("_MED_COPY").Enabled = _Screen.ActiveForm.ActiveControl.SelLength > 0
			This.MenuItems("_MED_CLEAR").Enabled = _Screen.ActiveForm.ActiveControl.SelLength > 0
		Endif
		
		If Pemstatus(_Screen.ActiveForm.ActiveControl, "ReadOnly", 5) Then
			If	_Screen.ActiveForm.ActiveControl.ReadOnly = TRUE Then
				This.MenuItems("_MED_CUT").Enabled = FALSE
				This.MenuItems("_MED_CLEAR").Enabled = FALSE
				This.MenuItems("_MED_PASTE").Enabled = FALSE
			Endif
		Endif
		
		m.lcCommand = This.Show(m.pnX, m.pnY)
		
		If _Screen.ActiveForm.ActiveControl.BaseClass = "Olecontrol" Then
			Do Case
				Case m.lcCommand = "_MED_UNDO"
					apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, WM_UNDO, 0, 0)
				Case m.lcCommand = "_MED_CUT"
					apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, WM_CUT, 0, 0)
				Case m.lcCommand = "_MED_COPY"
					apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, WM_COPY, 0, 0)
				Case m.lcCommand = "_MED_PASTE"
					apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, WM_PASTE, 0, 0)
				Case m.lcCommand = "_MED_CLEAR"
					apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, WM_CLEAR, 0, 0)
				Case m.lcCommand = "_MED_SLCTA"
					apiSendMessageInteger(_Screen.ActiveForm.ActiveControl.HWnd, EM_SETSEL, 0, -1)
			Endcase
		Else
			Do Case
				Case m.lcCommand = "_MED_UNDO"
					Sys(1500, '_MED_UNDO', '_MEDIT')
				Case m.lcCommand = "_MED_CUT"
					Sys(1500, '_MED_CUT', '_MEDIT')
				Case m.lcCommand = "_MED_COPY"
					Sys(1500, '_MED_COPY', '_MEDIT')
				Case m.lcCommand = "_MED_PASTE"
					Sys(1500, '_MED_PASTE', '_MEDIT')
				Case m.lcCommand = "_MED_CLEAR"
					Sys(1500, '_MED_CLEAR', '_MEDIT')
				Case m.lcCommand = "_MED_SLCTA"
					Sys(1500, '_MED_SLCTA', '_MEDIT')
			Endcase
		Endif
		
		
	ENDPROC

	PROCEDURE _addmenu
		*!* _AddMenu(ItemKey)
		
		*!* This method is used to add menus, menu pop-ups and submenus
		*!* When adding the first menu, the MenuKey must be the owner form Hwnd
		
		Lparameters m.peItemKey
		
		Local lcItemKey As String
		
		*!* Transform has issues
		If Vartype(m.peItemKey) = "N" Then
			m.lcItemKey = Alltrim(Str(m.peItemKey))
		Else
			m.lcItemKey = m.peItemKey
		Endif
		
		If This.Menus.Count = 0 Then
			This.FormHwnd = _Screen.ActiveForm.HWnd
			This._BindEvents()
		Endif
		
		This.Menus.Add(Createobject("ctl32_menu"), m.lcItemKey)
		
		This.Menus(m.lcItemKey).MenuID = apiCreatePopupMenu()
		
		Local ;
			lcMenuInfo As String, ;
			loMenuInfo As _MENUINFO
		
		m.loMenuInfo = Createobject("_MENUINFO")
		
		m.loMenuInfo.fMask = Bitor(MIM_BACKGROUND, MIM_MAXHEIGHT, MIM_STYLE, MIM_MENUDATA)
		m.loMenuInfo.dwStyle = Bitor(MNS_AUTODISMISS, MNS_CHECKORBMP)
		m.loMenuInfo.cyMax = This.Menus(m.lcItemKey).Height
		m.loMenuInfo.hbrBack = 0
		m.loMenuInfo.dwContextHelpID = 0
		m.loMenuInfo.dwMenuData = 0
		
		m.lcMenuInfo = m.loMenuInfo.Value
		apiSetMenuInfo(This.Menus(m.lcItemKey).MenuID, @m.lcMenuInfo)
		
		Return This.Menus(m.lcItemKey).MenuID
		
	ENDPROC

	PROCEDURE _addmenuitem
		*!* _AddMenuItem
		
		Lparameters m.peItemKey1, m.peItemKey2, m.pcCaption As String, m.pePicture
		
		Local ;
			lcItemKey1 As String, ;
			lcItemKey2 As String, ;
			loMenuItem As ctl32_menuitem
		
		If Vartype(m.peItemKey1) = "N" Then
			m.lcItemKey1 = Alltrim(Str(m.peItemKey1))
		Else
			m.lcItemKey1 = m.peItemKey1
		Endif
		
		If Vartype(m.peItemKey2) = "N" Then
			m.lcItemKey2 = Alltrim(Str(m.peItemKey2))
		Else
			m.lcItemKey2 = m.peItemKey2
		Endif
		
		*!* Check if this menuitem has a parent menu:
		If Empty(This.Menus.GetKey(m.lcItemKey1))
			If Empty(This.MenuItems.GetKey(m.lcItemKey1))
				*!* There is no parent with the passed m.lcItemKey1
				Return
			Else
				*!* Create a menu for the parent menuitem if needed
				If This.MenuItems(m.lcItemKey1).SubMenuId = 0 Then
					This.MenuItems(m.lcItemKey1).SubMenuId = This._AddMenu(m.lcItemKey1)
				Endif
			Endif
		Endif
		
		*!* Add menu item object to MenuItems collection
		This.MenuItems.Add(Createobject("ctl32_menuitem"), m.peItemKey2)
		
		*!* Assign values to all the menu item properties:
		m.loMenuItem =  This.MenuItems(m.peItemKey2)
		
		m.loMenuItem.Caption = m.pcCaption
		
		*!* ID of the menu that contains this menu item
		m.loMenuItem.MenuId = This.Menus(m.lcItemKey1).MenuId
		
		m.loMenuItem.ItemId = This._NextMenuItemId
		This._NextMenuItemId = This._NextMenuItemId + 1
		
		*!* Proceed with API:
		
		Local ;
			lcMenuItemInfo As String,;
			loMenuItemInfo As _MENUITEMINFO
		
		********************************************************************************
		*!*	typedef struct tagMENUITEMINFO {
		*!*	  UINT    cbSize;
		*!*	  UINT    fMask;
		*!*	  UINT    fType;
		*!*	  UINT    fState;
		*!*	  UINT    wID;
		*!*	  HMENU   hSubMenu;
		*!*	  HBITMAP hbmpChecked;
		*!*	  HBITMAP hbmpUnchecked;
		*!*	  ULONG_PTR dwItemData;
		*!*	  LPTSTR  dwTypeData;
		*!*	  UINT    cch;
		*!*	  HBITMAP hbmpItem;
		*!*	} MENUITEMINFO, *LPMENUITEMINFO;
		********************************************************************************
		
		m.loMenuItemInfo = Createobject("_MENUITEMINFO")
		
		*!*	*!* cbSize: Size of structure, in bytes.
		*!*	m.loMenuItemInfo.cbSize = 12*4
		
		*!* fMask: Members to retrieve or set
		m.loMenuItemInfo.fMask = Bitor(MIIM_FTYPE, MIIM_ID, MIIM_STRING, MIIM_DATA)
		
		m.loMenuItemInfo.fType = MFT_STRING
		
		If m.loMenuItem.Caption = "-" Then
			m.loMenuItemInfo.fType = Bitor(m.loMenuItemInfo.fType, MF_SEPARATOR)
		Endif
		
		If ctlGetOsVersion() < NTDDI_VISTA
			m.loMenuItemInfo.fMask = Bitor(m.loMenuItemInfo.fMask, MIIM_BITMAP)
			m.loMenuItemInfo.hbmpItem = HBMMENU_CALLBACK
		Else
			m.loMenuItemInfo.hbmpItem = 0
		Endif
		
		m.loMenuItemInfo.fState = 0
		
		*!* wID: Application-defined 16-bit value that identifies the menu item.
		*!* Set fMask to MIIM_ID to use wID.
		m.loMenuItemInfo.wID = m.loMenuItem.ItemId
		
		m.loMenuItemInfo.hSubMenu = 0
		m.loMenuItemInfo.hbmpChecked = 0
		m.loMenuItemInfo.hbmpUnchecked = 0
		
		*!* dwItemData: Application-defined value associated with the menu item.
		*!* Set fMask to MIIM_DATA to use dwItemData.
		m.loMenuItemInfo.dwItemData = 0
		
		*!* Pointer to Text string
		Local lcCaption As String
		
		m.lcCaption = Strtran(m.loMenuItem.Caption, "\t", TABCHAR)
		m.lcCaption = Strtran(m.lcCaption, "\<", "&")
		m.loMenuItemInfo.dwTypeData =  m.lcCaption  + NULA
		
		*!* cch: Length of the menu item text, in TCHARs, when information is received
		*!* about a menu item of the MFT_STRING type. Ignored when the content of a menu
		*!* item is set by calling SetMenuItemInfo.
		
		m.loMenuItemInfo.cch = Len(m.loMenuItemInfo.dwTypeData)
		
		*!* Structure members have been set, now create structure string:
		
		m.lcMenuItemInfo = m.loMenuItemInfo.Value
		
		*!* Count number of menu items of menu, to insert new menu item at the end
		apiInsertMenuItem( ;
			m.loMenuItem.MenuId, ;
			apiGetMenuItemCount(m.loMenuItem.MenuId), ;
			MF_BYPOSITION, ;
			@m.lcMenuItemInfo)
		
		m.loMenuItem.Picture = m.pePicture
		
		m.loMenuItem = .Null.
		m.loMenuItemInfo = .Null.
		
		
		
		Return
		
		
		*!*	*!* fType: Menu item type: MFT_RADIOCHECK MFT_SEPARATOR MFT_STRING ...;
		*!*	*!* Set fMask to MIIM_TYPE to use fType.
		
		*!*	If m.loMenuItem.RadioCheck = TRUE Then
		*!*		m.loMenuItemInfo.fType = Bitor(m.loMenuItemInfo.fType, MFT_RADIOCHECK)
		*!*	Endif
		
		*!*	*!* fState: Menu item state... MFS_CHECKED MFS_DEFAULT MFS_GRAYED ...
		*!*	*!* Set fMask to MIIM_STATE to use fState
		
		
		*!*	If m.loMenuItem.Checked = TRUE Then
		*!*		m.loMenuItemInfo.fState = Bitor(m.loMenuItemInfo.fState, MFS_CHECKED)
		*!*	Endif
		
		*!*	If m.loMenuItem.DefaultItem = TRUE Then
		*!*		m.loMenuItemInfo.fState = Bitor(m.loMenuItemInfo.fState, MFS_DEFAULT)
		*!*	Endif
		
		*!*	If m.loMenuItem.Enabled = FALSE Then
		*!*		m.loMenuItemInfo.fState = Bitor(m.loMenuItemInfo.fState, MFS_GRAYED)
		*!*	Endif
		
		
		
		*!* hbmpChecked: Handle to the bitmap to display next to the item if it is selected.
		*!* If this member is NULL, a default bitmap is used.
		*!* If the MFT_RADIOCHECK type value is specified, the default bitmap is a bullet.
		*!"* Otherwise, it is a check mark.
		*!* Set fMask to MIIM_CHECKMARKS to use hbmpChecked.
		
		*!* 20080324
		
		*!* hbmpUnchecked: Handle to the bitmap to display next to the item if it is not selected.
		*!* If this member is NULL, no bitmap is used.
		*!* Set fMask to MIIM_CHECKMARKS to use hbmpUnchecked.
		
		*!* 20080324
		
		
		
		*!* Reset structure
		*!*m.loMenuItemInfo = Createobject("_MENUITEMINFO")
		
		*!* Set callback so we process wm_measureitem and can fix the menu item height
		If ctlGetOsVersion() < NTDDI_VISTA
			m.loMenuItemInfo.fMask = MIIM_BITMAP
			m.loMenuItemInfo.hbmpItem = HBMMENU_CALLBACK
			m.lcMenuItemInfo = m.loMenuItemInfo.Value
			apiSetMenuItemInfo(m.loMenuItem.MenuId, m.loMenuItem.ItemId, MF_BYCOMMAND, @m.lcMenuItemInfo)
		Else
			*!* should create and add a blank transparent bitmap in Vista
			*!* of m.loMenuItem.PictureHeight width and height and then assign it:
			*!* m.loMenuItem.PictureId = m.loMenuItem.PictureObject.GetHBitmap(m.loColor)
			*!* This._SetMenuItemInfo_hbmpItem(m.loMenuItem.MenuId, m.loMenuItem.ItemId, m.loMenuItem.PictureId)
		Endif
		
		m.loMenuItem.Picture = m.puPicture
		
		
		
		
		
	ENDPROC

	PROCEDURE _addmenuitemtocollection
		*!* _AddMenuItemToCollection
		
		Lparameters ;
			m.pcMenuKey, ;
			m.pItemKey, ;
			m.pnType, ;
			m.pcCaption, ;
			m.puPicture, ;
			m.plChecked, ;
			m.plRadioCheck, ;
			m.plDisabled, ;
			m.plDefaultItem, ;
			m.pcStatusBarText
		
		Local loMenuItem as ctl32_menuitem
		
		*!* Add menu item object to MenuItems collection
		This.MenuItems.Add(Createobject("ctl32_menuitem"), m.pItemKey)
		
		*!* Assign values to all the menu item properties:
		m.loMenuItem =  This.MenuItems(m.pItemKey)
		
		m.loMenuItem.Caption = m.pcCaption
		m.loMenuItem.DefaultItem = m.plDefaultItem
		m.loMenuItem.Enabled = Not m.plDisabled
		
		*!* ID of the menu that contains this menu item
		m.loMenuItem.MenuId = This.Menus(m.pcMenuKey).MenuId
		
		m.loMenuItem.Shortcut = ""
		m.loMenuItem.Checked = m.plChecked
		m.loMenuItem.RadioCheck = m.plRadioCheck
		m.loMenuItem.MenuPKey = m.pcMenuKey
		
		*!* if puPicture is numeric, it represents a picture handle
		
		m.loMenuItem.Picture = ""
		
		If Vartype(m.puPicture) = "N" Then
			m.loMenuItem.Picture =  ""
			m.loMenuItem.PictureId = m.puPicture
		Endif
		
		If Vartype(m.puPicture) = "C" And File(m.puPicture) Then
			m.loMenuItem.Picture = m.puPicture
		Endif
		
		m.loMenuItem.ItemKey = m.pItemKey
		
		*!* ItemId is a random value
		m.loMenuItem.ItemId = This.MenuItems.GetKey(m.pItemKey)
		
		m.loMenuItem.StatusBarText = Iif(Vartype(m.pcStatusBarText) = "C", m.pcStatusBarText, "")
		
		*!* ID of the submenu called by this menu item
		If m.pnType = 3
			m.loMenuItem.SubMenuId = This.Menus(m.pItemKey).MenuId
		Else
			m.loMenuItem.SubMenuId = 0
		Endif
		
		m.loMenuItem = .Null.
		
		Return m.pItemKey
		
		
		*!* hbmpItem: Handle to the bitmap to be displayed,
		*!* or it can be one of the values in the following table.
		*!* It is used when the MIIM_BITMAP flag is set in the fMask member.
		*!* HBMMENU_CALLBACK
		*!*	HBMMENU_POPUP_CLOSE
		*!*	HBMMENU_POPUP_MAXIMIZE
		*!*	HBMMENU_POPUP_MINIMIZE
		*!*	HBMMENU_POPUP_RESTORE
		*!*	HBMMENU_SYSTEM
	ENDPROC

	PROCEDURE _bindevents
		*!* _BindEvents()
		If ctlGetOsVersion() < NTDDI_VISTA Or This.OwnerDrawn Then
			This._WindowProcedure = ctlGetWindowProcedure(This.FormHwnd)
			Bindevent(This.FormHwnd, WM_MEASUREITEM,  This, "OnWmMeasureItem")
			Bindevent(This.FormHwnd, WM_DRAWITEM,     This, "OnWmDrawItem")
		Endif
		
	ENDPROC

	PROCEDURE _setbitmap
	ENDPROC

	PROCEDURE _setmenuiteminfo_hbmpitem
		*!* _SetMenuItemInfo_hBmpItem
		
		Lparameters pnHostId, pnItemId, pnBitmapId
		
		Local ;
			lcMenuItemInfo As String, ;
			loMenuItemInfo As _MENUITEMINFO
		
		m.loMenuItemInfo = Createobject("_MENUITEMINFO")
		
		m.loMenuItemInfo.fMask = MIIM_BITMAP
		m.loMenuItemInfo.hbmpItem = m.pnBitmapId
		m.lcMenuItemInfo = m.loMenuItemInfo.Value
		
		apiSetMenuItemInfo(m.pnHostId, m.pnItemId, MF_BYCOMMAND, @m.lcMenuItemInfo)
		
		m.loMenuItemInfo = Null
		
	ENDPROC

	PROCEDURE _setmenuiteminfo_miim_checkmarks
		*!* _SetMenuItemInfo_miim_checkmarks
		
		Lparameters pnHostId, pnItemId, pnBitmapId
		
		Local ;
			lcMenuItemInfo As String, ;
			loMenuItemInfo As _MENUITEMINFO
		
		m.loMenuItemInfo = Createobject("_MENUITEMINFO")
		
		m.loMenuItemInfo.fMask = MIIM_CHECKMARKS
		
		m.loMenuItemInfo.hbmpChecked = m.pnBitmapId
		m.loMenuItemInfo.hbmpUnchecked = m.pnBitmapId
		
		m.lcMenuItemInfo = m.loMenuItemInfo.Value
		
		apiSetMenuItemInfo(m.pnHostId, m.pnItemId, MF_BYCOMMAND, @m.lcMenuItemInfo)
		
		m.loMenuItemInfo = Null
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_controlbase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ctlTextBox" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlautosize_assign
		*m: ctlbackcolor_assign
		*m: ctlbackgroundimagelayout_assign
		*m: ctlbackgroundimage_assign
		*m: ctlbackstyle_assign
		*m: ctlbordercolor_assign
		*m: ctlbottom_access
		*m: ctlcontrolsource_assign
		*m: ctlcreatecontrol		&& Forces the creation of the control, including the creation of the handle and any child controls.
		*m: ctlcreated_access
		*m: ctldefaultbackcolor_access
		*m: ctldefaultbordercolor_access
		*m: ctldefaultforecolor_access
		*m: ctldefaultheight_access
		*m: ctldefaultwidth_access
		*m: ctldispose		&& Releases all resources used by the control.
		*m: ctlenabled_assign
		*m: ctlfocused_access
		*m: ctlfontbold_assign
		*m: ctlfontcharset_assign
		*m: ctlfontitalic_assign
		*m: ctlfontname_assign
		*m: ctlfontsize_assign
		*m: ctlfontstrikethru_assign
		*m: ctlfontunderline_assign
		*m: ctlforecolor_assign
		*m: ctlhandle_access
		*m: ctlhide		&& Conceals the control from the user.
		*m: ctlhostformhwnd_access
		*m: ctlhosthwnd_access
		*m: ctlhwnd_access
		*m: ctlinit		&& Occurs when anobject is created, after the Init event.
		*m: ctlishandlecreated_access
		*m: ctllocationleft_access
		*m: ctllocationtop_access
		*m: ctlorientation_assign
		*m: ctlrecreatinghandle_access
		*m: ctlrefresh		&& Forces the control to invalidate its client area and immediately redraw itself and any child controls.
		*m: ctlresetbackcolor		&& Resets the ctlBackColor property to its default value.
		*m: ctlresetbordercolor		&& Resets the ctlBorderColor property to its default value.
		*m: ctlresetfont		&& Resets the Font... properties to its default values.
		*m: ctlresetforecolor		&& Resets the ctlForeColor property to its default value.
		*m: ctlright_access
		*m: ctlshow		&& Displays the control to the user. Showing the control is equivalent to setting the ctlVisible property to true.
		*m: ctlshowfocuscues_assign
		*m: ctlthemes_assign
		*m: ctlvaluechanged		&& Occurs when the ctlValue property changes.
		*m: ctlvalue_assign
		*m: ctlvisible_assign
		*m: _addobjects		&& Adds objects used by the class.
		*m: _bindevents		&& Binds to events used by the class.
		*m: _callbackproc
		*m: _create		&& Creates the windows control
		*m: _createbackgroundbrush		&& Creates a brush.
		*m: _createcallback
		*m: _destroycallback
		*m: _drawfocusrect		&& Draws a focus rectangle for controls that do not have one.
		*m: _formmessagehandler
		*m: _getdefaultfont
		*m: _getdefaultsize
		*m: _getdwexstyle
		*m: _getdwstyle
		*m: _getlpclassname
		*m: _getlpwindowname
		*m: _getpage		&& Returns an object reference to the page that contains this control.
		*m: _getpageframe
		*m: _initcommoncontrols
		*m: _initlibrary
		*m: _iscontrolinpage		&& Returns TRUE if the control is contained in a page.
		*m: _objtoclient		&& Replaces OBJTOCLIENT that has bugs.
		*m: _onformborderstyle
		*m: _onformpaint
		*m: _onformresize
		*m: _onmoved		&& Bindevent(This, "Moved", This, "_OnMoved", 1)
		*m: _onpageactivate		&& Bindevent(m.loControl, "Activate", This, "_OnPageActivate", 1)
		*m: _onpagedeactivate		&& Bindevent(m.loControl, "Deactivate", This, "_OnPageDeactivate", 1)
		*m: _onparentbackcolor
		*m: _onresize		&& Bindevent(This, "Resize", This, "_OnResize", 1)
		*m: _onthemes		&& Bindevent(_Screen, "Themes", This, "_OnThemes", 1) / Bindevent(Thisform, "Themes", This, "_OnThemes", 1)
		*m: _onvalue
		*m: _postcreate
		*m: _precreate
		*m: _reparent
		*m: _setautosize
		*m: _setbackcolor
		*m: _setbackstyle
		*m: _setbordercolor
		*m: _setcontrolsource
		*m: _setenabled
		*m: _setfont
		*m: _setforecolor
		*m: _setorientation
		*m: _setproperties
		*m: _setshowfocuscues
		*m: _setthemes
		*m: _setvalue
		*m: _setvisible
		*m: _updatecolors
		*m: _vfpmessagehandler
		*p: builderx
		*p: ctlautosize		&& Gets or sets a value indicating whether the height and/or width of the control is automatically sized.
		*p: ctlbackcolor		&& Gets or sets the background color for the control.
		*p: ctlbackgroundimage		&& Gets or sets the background image displayed in the control.
		*p: ctlbackgroundimagelayout		&& Gets or sets the background image layout.
		*p: ctlbackstyle		&& Specifies if the background of an object is transparent or opaque.
		*p: ctlbordercolor		&& Gets or sets the border color of the control.
		*p: ctlbottom		&& Gets the distance, in pixels, between the bottom edge of the control and the top edge of its container's client area.
		*p: ctlcanfocus		&& Specifies whether the control can receive focus.
		*p: ctlcontrolsource		&& Specifies the source of data to which an object is bound.
		*p: ctlcreated		&& Gets a value indicating whether the control has been created.
		*p: ctldefaultbackcolor		&& Gets the default background color of the control.
		*p: ctldefaultbordercolor		&& Gets the default border color of the control.
		*p: ctldefaultforecolor		&& Gets the default foreground color of the control.
		*p: ctldefaultheight		&& Gets the default height of the control.
		*p: ctldefaultwidth		&& Gets the default width of the control.
		*p: ctlenabled		&& Gets or sets a value indicating whether the control can respond to user interaction.
		*p: ctlfocused		&& Gets a value indicating whether the control has input focus.
		*p: ctlfontbold		&& Specifies if the text is bold.
		*p: ctlfontcharset		&& Specifies the character set, or language script, of the font.
		*p: ctlfontitalic		&& Specifies if the text is italic.
		*p: ctlfontname		&& Specifies the name of the font.
		*p: ctlfontsize		&& Specifies the size of the font
		*p: ctlfontstrikethru		&& Specifies if the text is strikethru.
		*p: ctlfontunderline		&& Specifies if the text is underline.
		*p: ctlforecolor		&& Gets or sets the foreground color of the control.
		*p: ctlhandle		&& Gets the window handle that the control is bound to.
		*p: ctlhostformhwnd		&& Specifies the window handle of the inner window of the parent form.
		*p: ctlhosthwnd		&& Gets the windows handle of the parent object of this control, if there is one.
		*p: ctlhwnd		&& DEPRECATED. Replaced by the .NET ctlHandle property.
		*p: ctlishandlecreated		&& Gets a value indicating whether the control has a handle associated with it.
		*p: ctllocationleft		&& Gets or sets the Left coordinate of the upper-left corner of the control relative to the upper-left corner of its container. (ObjToClient)
		*p: ctllocationtop		&& Gets or sets the Top coordinate of the upper-left corner of the control relative to the upper-left corner of its container. (ObjToClient)
		*p: ctlorientation		&& Gets or sets a value indicating the horizontal or vertical orientation of the control.
		*p: ctlrecreatinghandle		&& Gets a value indicating whether the control is currently re-creating its handle.
		*p: ctlright		&& Gets the distance, in pixels, between the right edge of the control and the left edge of its container's client area. (Left + Width)
		*p: ctlshowfocuscues		&& Gets or sets a value indicating whether the control should display focus rectangles.
		*p: ctlthemes		&& Specifies if themes are used for the control.
		*p: ctlvalue		&& Specifies the current value or state of the control.
		*p: ctlvisible		&& Gets or sets a value indicating whether the control is displayed.
		*p: _backgroundbrush		&& Handle to a GDI brush, passed to the control.
		*p: _callbackprocaddress
		*p: _clicktime		&& Stores seconds() for click event to detect double clicks.
		*p: _controlhasownfocuscue
		*p: _controlhwnd		&& hwnd of the control window.
		*p: _controlwindowprocaddress
		*p: _defaultheight
		*p: _defaultwidth
		*p: _enableupdates
		*p: _focused		&& Specifies if the control has the focus.
		*p: _focusstart		&& Specifies the time the control got focus, used by _FocusTimerTick.
		*p: _fontdefaultlogfont
		*p: _fonthandle
		*p: _hostformhwnd
		*p: _inpage		&& Specifies if the control is in a page, somewhere in its object tree. Used to show/hide the control when the page becomes active/inactive.
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _onvaluefired
		*p: _pageactive
		*p: _popup
		*p: _recreatinghandle
		*p: _visible		&& Set to FALSE to make container NEVER Visible
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	builderx = 
	ctlautosize = .T.		&& Gets or sets a value indicating whether the height and/or width of the control is automatically sized.
	ctlbackcolor = -1		&& Gets or sets the background color for the control.
	ctlbackgroundimage = 		&& Gets or sets the background image displayed in the control.
	ctlbackgroundimagelayout = 0		&& Gets or sets the background image layout.
	ctlbackstyle = 1		&& Specifies if the background of an object is transparent or opaque.
	ctlbordercolor = -1		&& Gets or sets the border color of the control.
	ctlbottom = 0		&& Gets the distance, in pixels, between the bottom edge of the control and the top edge of its container's client area.
	ctlcanfocus = .F.		&& Specifies whether the control can receive focus.
	ctlcontrolsource = 		&& Specifies the source of data to which an object is bound.
	ctlcreated = .F.		&& Gets a value indicating whether the control has been created.
	ctldefaultbackcolor = 0		&& Gets the default background color of the control.
	ctldefaultbordercolor = 0		&& Gets the default border color of the control.
	ctldefaultforecolor = 0		&& Gets the default foreground color of the control.
	ctldefaultheight = 0		&& Gets the default height of the control.
	ctldefaultwidth = 0		&& Gets the default width of the control.
	ctlenabled = .T.		&& Gets or sets a value indicating whether the control can respond to user interaction.
	ctlfocused = .F.		&& Gets a value indicating whether the control has input focus.
	ctlfontbold = .F.		&& Specifies if the text is bold.
	ctlfontcharset = 1		&& Specifies the character set, or language script, of the font.
	ctlfontitalic = .F.		&& Specifies if the text is italic.
	ctlfontname = Default		&& Specifies the name of the font.
	ctlfontsize = 0		&& Specifies the size of the font
	ctlfontstrikethru = .F.		&& Specifies if the text is strikethru.
	ctlfontunderline = .F.		&& Specifies if the text is underline.
	ctlforecolor = -1		&& Gets or sets the foreground color of the control.
	ctlhandle = 0		&& Gets the window handle that the control is bound to.
	ctlhostformhwnd = 0		&& Specifies the window handle of the inner window of the parent form.
	ctlhosthwnd = 0		&& Gets the windows handle of the parent object of this control, if there is one.
	ctlhwnd = 0		&& DEPRECATED. Replaced by the .NET ctlHandle property.
	ctlishandlecreated = .F.		&& Gets a value indicating whether the control has a handle associated with it.
	ctllocationleft = 0		&& Gets or sets the Left coordinate of the upper-left corner of the control relative to the upper-left corner of its container. (ObjToClient)
	ctllocationtop = 0		&& Gets or sets the Top coordinate of the upper-left corner of the control relative to the upper-left corner of its container. (ObjToClient)
	ctlorientation = 0		&& Gets or sets a value indicating the horizontal or vertical orientation of the control.
	ctlrecreatinghandle = .F.		&& Gets a value indicating whether the control is currently re-creating its handle.
	ctlright = 0		&& Gets the distance, in pixels, between the right edge of the control and the left edge of its container's client area. (Left + Width)
	ctlshowfocuscues = .T.		&& Gets or sets a value indicating whether the control should display focus rectangles.
	ctlthemes = .T.		&& Specifies if themes are used for the control.
	ctlvalue = 0		&& Specifies the current value or state of the control.
	ctlvisible = .T.		&& Gets or sets a value indicating whether the control is displayed.
	Height = 60
	Name = "ctl32_controlbase"
	Width = 240
	_backgroundbrush = 0		&& Handle to a GDI brush, passed to the control.
	_callbackprocaddress = 
	_clicktime = 0		&& Stores seconds() for click event to detect double clicks.
	_controlhasownfocuscue = .T.
	_controlhwnd = 0		&& hwnd of the control window.
	_controlwindowprocaddress = 
	_defaultheight = 0
	_defaultwidth = 0
	_enableupdates = .T.
	_focused = .F.		&& Specifies if the control has the focus.
	_focusstart = 0		&& Specifies the time the control got focus, used by _FocusTimerTick.
	_fontdefaultlogfont = .F.
	_fonthandle = 0
	_hostformhwnd = 0
	_inpage = .F.		&& Specifies if the control is in a page, somewhere in its object tree. Used to show/hide the control when the page becomes active/inactive.
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	_onvaluefired = .F.
	_pageactive = .F.
	_popup = .F.
	_recreatinghandle = .F.
	_visible = .T.		&& Set to FALSE to make container NEVER Visible

	ADD OBJECT 'ctlTextBox' AS textbox WITH ;
		Height = 23, ;
		Left = 0, ;
		Name = "ctlTextBox", ;
		Top = 32000, ;
		Width = 100
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_base", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 2
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE ctlautosize_assign
		*!* ctlAutoSize_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		*!* Always do this
		*!* If This.ctlAutoSize # m.tuNewValue Then
		
		This.ctlAutoSize = m.tuNewValue
		This._SetAutoSize()
		
		*!* Endif
		
		
	ENDPROC

	PROCEDURE ctlbackcolor_assign
		*!* ctlBackColor_Assign(tuNewValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) # "N"
			m.tuNewValue = -1
		Endif
		
		If m.tuNewValue > Rgb(255,255,255) Or m.tuNewValue < 0 Then
			m.tuNewValue = -1
		Endif
		
		If This.ctlBackColor # m.tuNewValue Then
			This.ctlBackColor = m.tuNewValue
			This._SetBackColor()
		Endif
		
		
		
		
	ENDPROC

	PROCEDURE ctlbackgroundimagelayout_assign
		lparameters tuNewValue
		This.ctlBackgroundImageLayout = tuNewValue
		
	ENDPROC

	PROCEDURE ctlbackgroundimage_assign
		lparameters tuNewValue
		This.ctlBackgroundImage = tuNewValue
		
	ENDPROC

	PROCEDURE ctlbackstyle_assign
		*!* ctlBackStyle_Assign()
		
		Lparameters m.tuNewValue
		
		If m.tuNewValue # 0 Then
			m.tuNewValue = 1
		Endif
		
		If This.ctlBackStyle # m.tuNewValue Then
			This.ctlBackStyle = m.tuNewValue
			This._SetBackStyle()
		Endif
		
	ENDPROC

	PROCEDURE ctlbordercolor_assign
		*!* ctlBorderColor_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) # "N"
			m.tuNewValue = -1
		Endif
		
		If m.tuNewValue > Rgb(255,255,255) Or m.tuNewValue < 0 Then
			m.tuNewValue = -1
		Endif
		
		If This.ctlBorderColor # m.tuNewValue Then
			This.ctlBorderColor = m.tuNewValue
			This._SetBorderColor()
		Endif
		
	ENDPROC

	PROCEDURE ctlbottom_access
		*!* ctlBottom_Access()
		
		Return This.Top + This.Height
		
	ENDPROC

	PROCEDURE ctlcontrolsource_assign
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlControlSource # m.tuNewValue Then
			This.ctlControlSource = m.tuNewValue
			This._SetControlSource()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlcreatecontrol		&& Forces the creation of the control, including the creation of the handle and any child controls.
		*!* CreateControl()
		
		This._Create()
		
	ENDPROC

	PROCEDURE ctlcreated_access
		*!* ctlCreated_Access()
		
		Return This._ControlHwnd # 0
		
	ENDPROC

	PROCEDURE ctldefaultbackcolor_access
		*!* ctlDefaultBackColor_Access()
		
		*!*	ActiveBorder			= COLOR_ACTIVEBORDER 
		*!*	ActiveCaption			= COLOR_ACTIVECAPTION 
		*!*	ActiveCaptionText		= COLOR_CAPTIONTEXT 
		*!*	AppWorkspace			= COLOR_APPWORKSPACE 
		*!*	ButtonFace				= COLOR_BTNFACE
		*!*	ButtonHighlight			= COLOR_BTNHIGHLIGHT
		*!*	ButtonShadow			= COLOR_BTNSHADOW
		*!*	Control					= COLOR_BTNFACE
		*!*	ControlDark				= COLOR_BTNSHADOW
		*!*	ControlDarkDark			= COLOR_3DDKSHADOW
		*!*	ControlLight			= COLOR_BTNHIGHLIGHT
		*!*	ControlLightLight		= COLOR_3DLIGHT
		*!*	ControlText				= COLOR_BTNTEXT
		*!*	Desktop					= COLOR_DESKTOP
		*!*	GradientActiveCaption	= COLOR_GRADIENTACTIVECAPTION
		*!*	GradientInactiveCaption	= COLOR_GRADIENTINACTIVECAPTION
		*!*	GrayText				= COLOR_GRAYTEXT
		*!*	Highlight				= COLOR_HIGHLIGHT
		*!*	HighlightText			= COLOR_HIGHLIGHTTEXT
		*!*	HotTrack				= COLOR_HOTLIGHT
		*!*	InactiveBorder			= COLOR_INACTIVEBORDER
		*!*	InactiveCaption			= COLOR_INACTIVECAPTION
		*!*	InactiveCaptionText		= COLOR_INACTIVECAPTIONTEXT
		*!*	Info					= COLOR_INFOBK
		*!*	InfoText				= COLOR_INFOTEXT
		*!*	Menu					= COLOR_MENU
		*!*	MenuBar					= COLOR_MENUBAR
		*!*	MenuHighlight			= COLOR_MENUHILIGHT 
		*!*	MenuText				= COLOR_MENUTEXT
		*!*	Scrollbar				= COLOR_SCROLLBAR
		*!*	Window					= COLOR_WINDOW
		*!*	WindowFrame				= COLOR_WINDOWFRAME
		*!*	WindowText				= COLOR_WINDOWTEXT
		
		Local lnColor As Integer
		
		Do Case
		
			Case This._GetlpClassName() = TRACKBAR_CLASSA
				m.lnColor = apiGetSysColor(COLOR_BTNFACE)	&& Control
		
			Case This._GetlpClassName() = PROGRESS_CLASSA
				m.lnColor = apiGetSysColor(COLOR_BTNFACE)	&& Control
		
			Case This._GetlpClassName() = MONTHCAL_CLASSA
				m.lnColor = apiGetSysColor(COLOR_WINDOW)	&& Window
			
			Case This._GetlpClassName() = TOOLTIPS_CLASSA
				m.lnColor = apiGetSysColor(COLOR_INFOBK)	&& Info
			
			Otherwise
				m.lnColor = 0
		
		Endcase
		
		Return m.lnColor
		
	ENDPROC

	PROCEDURE ctldefaultbordercolor_access
		*!* ctlDefaultBorderColor_Access()
		
		*!*	ActiveBorder			= COLOR_ACTIVEBORDER 
		*!*	ActiveCaption			= COLOR_ACTIVECAPTION 
		*!*	ActiveCaptionText		= COLOR_CAPTIONTEXT 
		*!*	AppWorkspace			= COLOR_APPWORKSPACE 
		*!*	ButtonFace				= COLOR_BTNFACE
		*!*	ButtonHighlight			= COLOR_BTNHIGHLIGHT
		*!*	ButtonShadow			= COLOR_BTNSHADOW
		*!*	Control					= COLOR_BTNFACE
		*!*	ControlDark				= COLOR_BTNSHADOW
		*!*	ControlDarkDark			= COLOR_3DDKSHADOW
		*!*	ControlLight			= COLOR_BTNHIGHLIGHT
		*!*	ControlLightLight		= COLOR_3DLIGHT
		*!*	ControlText				= COLOR_BTNTEXT
		*!*	Desktop					= COLOR_DESKTOP
		*!*	GradientActiveCaption	= COLOR_GRADIENTACTIVECAPTION
		*!*	GradientInactiveCaption	= COLOR_GRADIENTINACTIVECAPTION
		*!*	GrayText				= COLOR_GRAYTEXT
		*!*	Highlight				= COLOR_HIGHLIGHT
		*!*	HighlightText			= COLOR_HIGHLIGHTTEXT
		*!*	HotTrack				= COLOR_HOTLIGHT
		*!*	InactiveBorder			= COLOR_INACTIVEBORDER
		*!*	InactiveCaption			= COLOR_INACTIVECAPTION
		*!*	InactiveCaptionText		= COLOR_INACTIVECAPTIONTEXT
		*!*	Info					= COLOR_INFOBK
		*!*	InfoText				= COLOR_INFOTEXT
		*!*	Menu					= COLOR_MENU
		*!*	MenuBar					= COLOR_MENUBAR
		*!*	MenuHighlight			= COLOR_MENUHILIGHT 
		*!*	MenuText				= COLOR_MENUTEXT
		*!*	Scrollbar				= COLOR_SCROLLBAR
		*!*	Window					= COLOR_WINDOW
		*!*	WindowFrame				= COLOR_WINDOWFRAME
		*!*	WindowText				= COLOR_WINDOWTEXT
		
		Local lnColor As Integer
		
		Do Case
		
		*!*		Case This._GetlpClassName() = TRACKBAR_CLASSA
		*!*			m.lnColor = apiGetSysColor()
		
			Case This._GetlpClassName() = PROGRESS_CLASSA
				m.lnColor = apiGetSysColor(COLOR_BTNSHADOW)
		
			Case This._GetlpClassName() = MONTHCAL_CLASSA
				m.lnColor = apiGetSysColor(COLOR_WINDOW)	&& Window
		*!*		
		*!*		Case This._GetlpClassName() = TOOLTIPS_CLASSA
		*!*			m.lnColor = apiGetSysColor()
			
			Otherwise
				m.lnColor = 0
		
		Endcase
		
		Return m.lnColor
	ENDPROC

	PROCEDURE ctldefaultforecolor_access
		*!* ctlDefaultForeColor_Access()
		
		*!*	ActiveBorder			= COLOR_ACTIVEBORDER 
		*!*	ActiveCaption			= COLOR_ACTIVECAPTION 
		*!*	ActiveCaptionText		= COLOR_CAPTIONTEXT 
		*!*	AppWorkspace			= COLOR_APPWORKSPACE 
		*!*	ButtonFace				= COLOR_BTNFACE
		*!*	ButtonHighlight			= COLOR_BTNHIGHLIGHT
		*!*	ButtonShadow			= COLOR_BTNSHADOW
		*!*	Control					= COLOR_BTNFACE
		*!*	ControlDark				= COLOR_BTNSHADOW
		*!*	ControlDarkDark			= COLOR_3DDKSHADOW
		*!*	ControlLight			= COLOR_BTNHIGHLIGHT
		*!*	ControlLightLight		= COLOR_3DLIGHT
		*!*	ControlText				= COLOR_BTNTEXT
		*!*	Desktop					= COLOR_DESKTOP
		*!*	GradientActiveCaption	= COLOR_GRADIENTACTIVECAPTION
		*!*	GradientInactiveCaption	= COLOR_GRADIENTINACTIVECAPTION
		*!*	GrayText				= COLOR_GRAYTEXT
		*!*	Highlight				= COLOR_HIGHLIGHT
		*!*	HighlightText			= COLOR_HIGHLIGHTTEXT
		*!*	HotTrack				= COLOR_HOTLIGHT
		*!*	InactiveBorder			= COLOR_INACTIVEBORDER
		*!*	InactiveCaption			= COLOR_INACTIVECAPTION
		*!*	InactiveCaptionText		= COLOR_INACTIVECAPTIONTEXT
		*!*	Info					= COLOR_INFOBK
		*!*	InfoText				= COLOR_INFOTEXT
		*!*	Menu					= COLOR_MENU
		*!*	MenuBar					= COLOR_MENUBAR
		*!*	MenuHighlight			= COLOR_MENUHILIGHT 
		*!*	MenuText				= COLOR_MENUTEXT
		*!*	Scrollbar				= COLOR_SCROLLBAR
		*!*	Window					= COLOR_WINDOW
		*!*	WindowFrame				= COLOR_WINDOWFRAME
		*!*	WindowText				= COLOR_WINDOWTEXT
		
		Local lnColor As Integer
		
		Do Case
		
			Case This._GetlpClassName() = TRACKBAR_CLASSA
				m.lnColor = apiGetSysColor(COLOR_WINDOWTEXT)	&& WindowText
		
			Case This._GetlpClassName() = PROGRESS_CLASSA
				m.lnColor = apiGetSysColor(COLOR_HIGHLIGHT)		&& Highlight
		
			Case This._GetlpClassName() = MONTHCAL_CLASSA
				m.lnColor = apiGetSysColor(COLOR_WINDOWTEXT)	&& WindowText
			
			Case This._GetlpClassName() = TOOLTIPS_CLASSA
				m.lnColor = apiGetSysColor(COLOR_INFOTEXT)		&& InfoText
			
			Otherwise
				m.lnColor = 0
		
		Endcase
		
		Return m.lnColor
		
	ENDPROC

	PROCEDURE ctldefaultheight_access
		*!* ctlDefaultHeight_Access()
		
		Return This.ctlDefaultHeight
		
	ENDPROC

	PROCEDURE ctldefaultwidth_access
		*!* ctlDefaultWidth_Access()
		
		Return This.ctlDefaultWidth
		
	ENDPROC

	PROCEDURE ctldispose		&& Releases all resources used by the control.
		*!* ctlDispose()
		
		If This._ControlHwnd # 0 Then
			*!* if we have saved the old window procedure
			If This._ControlWindowProcAddress # 0 Then
				*!* Restore original window procedure
				apiSetWindowLong(This._ControlHwnd, GWL_WNDPROC, This._ControlWindowProcAddress)
				This._ControlWindowProcAddress = 0
			Endif
			apiDestroyWindow(This._ControlHwnd)
		Endif
		
		If This._BackGroundBrush # 0 Then
			apiDeleteObject(This._BackGroundBrush)
		Endif
		
		If This._FontHandle # 0 Then
			apiDeleteObject(This._FontHandle)
		Endif
		
		This._FontDefaultLogFont = .Null.
		
		This._DestroyCallBack()
	ENDPROC

	PROCEDURE ctlenabled_assign
		*!* ctlEnabled_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue= m.tuNewValue # 0
		Endif
		
		If This.ctlEnabled # m.tuNewValue Then
			This.ctlEnabled = m.tuNewValue
			This._SetEnabled()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlfocused_access
		*!* ctlFocused_Access()
		
		Return This._Focused
		
	ENDPROC

	PROCEDURE ctlfontbold_assign
		*!* ctlFontBold_Assign(lValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlFontBold = m.tuNewValue
		This._SetFont()
		
		
	ENDPROC

	PROCEDURE ctlfontcharset_assign
		*!* ctlFontCharSet_Assign(lValue)
		
		Lparameters m.tuNewValue
		
		This.ctlFontCharSet = m.tuNewValue
		This._SetFont()
		
	ENDPROC

	PROCEDURE ctlfontitalic_assign
		*!* ctlFontItalic_Assign(lValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlFontItalic = m.tuNewValue
		This._SetFont()
		
	ENDPROC

	PROCEDURE ctlfontname_assign
		*!* ctlFontName_Assign(tuNewValue)
		
		Lparameters m.tuNewValue
		
		This.ctlFontName = m.tuNewValue
		This._SetFont()
		
		
		
	ENDPROC

	PROCEDURE ctlfontsize_assign
		*!* ctlFontSize_Assign(lValue)
		
		Lparameters m.tuNewValue
		
		This.ctlFontSize = m.tuNewValue
		This._SetFont()
		
	ENDPROC

	PROCEDURE ctlfontstrikethru_assign
		*!* ctlFontStrikethru_Assign(lValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlFontStrikethru = m.tuNewValue
		This._SetFont()
		
	ENDPROC

	PROCEDURE ctlfontunderline_assign
		*!* ctlFontUnderline_Assign(lValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlFontUnderline = m.tuNewValue
		This._SetFont()
		
	ENDPROC

	PROCEDURE ctlforecolor_assign
		*!* ctlForeColor_Assign(tuNewValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) # "N"
			m.tuNewValue = -1
		Endif
		
		If m.tuNewValue > Rgb(255,255,255) Or m.tuNewValue < 0 Then
			m.tuNewValue = -1
		Endif
		
		If This.ctlForeColor # m.tuNewValue Then
			This.ctlForeColor = m.tuNewValue
			This._SetForeColor()
		Endif
	ENDPROC

	PROCEDURE ctlhandle_access
		*!* ctlHandle_Access()
		
		Return This._ControlHwnd
		
	ENDPROC

	PROCEDURE ctlhide		&& Conceals the control from the user.
		*!* ctlHide()
		
		This.ctlVisible = FALSE
		
	ENDPROC

	PROCEDURE ctlhostformhwnd_access
		*!* ctlHostFormhWnd_Access()
		
		*!* Gets hWnd of form or form inner window
		If This._HostFormhWnd = 0 Then
			This._HostFormhWnd = ctlGetHostHWnd(This)
		Endif
		
		Return This._HostFormhWnd
		
	ENDPROC

	PROCEDURE ctlhosthwnd_access
		*!* ctlHostHwnd_Access()
		
		If This.ctlHostHwnd = 0 Then
			This.ctlHostHwnd = ctlGetHostHwnd(This)
		Endif
		
		Return This.ctlHostHwnd
		
	ENDPROC

	PROCEDURE ctlhwnd_access
		*!* ctlHwnd_Access()
		
		Return This._ControlHwnd
		
	ENDPROC

	PROCEDURE ctlinit		&& Occurs when anobject is created, after the Init event.
	ENDPROC

	PROCEDURE ctlishandlecreated_access
		*!* ctlIsHandleCreated_Access()
		
		Return This._ControlHwnd # 0
		
	ENDPROC

	PROCEDURE ctllocationleft_access
		*!* ctlLocationLeft_Access()
		
		Return This._ObjToClient("Left")
		
		
	ENDPROC

	PROCEDURE ctllocationtop_access
		*!* ctlLocationTop_Access()
		
		Return This._ObjToClient("Top")
		
		
	ENDPROC

	PROCEDURE ctlorientation_assign
		*!* ctlOrientation_Assign()
		
		Lparameters m.tuNewValue
		
		If m.tuNewValue # 0 Then
			m.tuNewValue = 1
		Endif
		
		If This.ctlOrientation # m.tuNewValue Then
			This.ctlOrientation = m.tuNewValue
			This._SetOrientation()
		Endif
		
	ENDPROC

	PROCEDURE ctlrecreatinghandle_access
		*!* ctlRecreatingHandle_Access()
		
		Return This._RecreatingHandle
		
	ENDPROC

	PROCEDURE ctlrefresh		&& Forces the control to invalidate its client area and immediately redraw itself and any child controls.
		*!* ctlRefresh()
		
		Local lnFlags As Integer
		
		If This._ControlhWnd = 0 Then
			Return
		Endif
		
		Do Case
		
			Case This._GetlpClassName() = "msctls_trackbar32"
				*!* trackbar only refreshes with this:
				apiSendMessageInteger(This._ControlhWnd, WM_SETFOCUS, 0, 0)
		
			Otherwise
				m.lnFlags = Bitor(RDW_ERASE, RDW_FRAME, RDW_INTERNALPAINT, RDW_INVALIDATE, RDW_UPDATENOW, RDW_NOCHILDREN)
				apiRedrawWindow(This._ControlhWnd, "", 0, m.lnFlags)
		
		Endcase
		
		
		
		
	ENDPROC

	PROCEDURE ctlresetbackcolor		&& Resets the ctlBackColor property to its default value.
		*!* ctlResetBackColor()
		
		This.ctlBackColor = THis.ctlDefaultBackColor
		
	ENDPROC

	PROCEDURE ctlresetbordercolor		&& Resets the ctlBorderColor property to its default value.
		*!* ctlResetBorderColor()
		
		This.ctlBorderColor = This.ctlDefaultBorderColor
		
	ENDPROC

	PROCEDURE ctlresetfont		&& Resets the Font... properties to its default values.
		*!* ctlResetFont()
		
		This._EnableUpdates = FALSE
		
		This.ctlFontBold 		= This._FontDefaultLogFont.FontBold
		This.ctlFontCharSet 	= This._FontDefaultLogFont.FontCharSet
		This.ctlFontItalic 		= This._FontDefaultLogFont.FontItalic
		This.ctlFontName 		= This._FontDefaultLogFont.FontName
		This.ctlFontSize 		= This._FontDefaultLogFont.FontSize
		This.ctlFontStrikethru 	= This._FontDefaultLogFont.FontStrikethru
		This.ctlFontUnderline 	= This._FontDefaultLogFont.FontUnderline
		
		This._EnableUpdates = TRUE
		
		This._SetFont()
		
	ENDPROC

	PROCEDURE ctlresetforecolor		&& Resets the ctlForeColor property to its default value.
		*!* ctlResetForeColor()
		
		This.ctlForeColor = This.ctlDefaultForeColor
		
	ENDPROC

	PROCEDURE ctlright_access
		*!* ctlRight_Access()
		
		Return This.Left + This.Width
		
	ENDPROC

	PROCEDURE ctlshow		&& Displays the control to the user. Showing the control is equivalent to setting the ctlVisible property to true.
		*!* ctlShow()
		
		This.ctlVisible = TRUE
		
	ENDPROC

	PROCEDURE ctlshowfocuscues_assign
		*!* ctlShowFocusCues_Assign(lExpression)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlShowFocusCues # m.tuNewValue Then
			This.ctlShowFocusCues = m.tuNewValue
			This._SetShowFocusCues()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlthemes_assign
		*!* ctlThemes_Assign(lExpression)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlThemes # m.tuNewValue Then
			This.ctlThemes = m.tuNewValue
			This._SetThemes()
		Endif
		
		
		
	ENDPROC

	PROCEDURE ctlvaluechanged		&& Occurs when the ctlValue property changes.
		*!* ctlValueChanged()
	ENDPROC

	PROCEDURE ctlvalue_assign
		*!* ctlValue_Assign(nValue)
		
		Lparameters m.tuNewValue
		
		If Type("This.ctlMaximum") = T_NUMERIC Then
			m.tuNewValue = Min(This.ctlMaximum, m.tuNewValue)
		Endif
		
		If Type("This.ctlMinimum") = T_NUMERIC Then
			m.tuNewValue = Max(This.ctlMinimum, m.tuNewValue)
		Endif
		
		If This.ctlValue # m.tuNewValue Then
			This.ctlValue = m.tuNewValue
			This._SetValue()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlvisible_assign
		*!* ctlVisible_Assign(lValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlVisible # m.tuNewValue Then
			This.ctlVisible = m.tuNewValue
			This._SetVisible()
		Endif
		
		
		
		
	ENDPROC

	PROCEDURE Destroy
		*!* Destroy() 
		*!* DO NOT REMOVE THIS COMMENTS OR BINDEVENT DOES NOT WORK!
		*!* SOMETHING MUST BE HERE, EVEN A COMMENT, FOR BINDEVENT TO WORK.
	ENDPROC

	PROCEDURE Init
		*!* Init()
		
		*!* This parameter is passed from host ctl32 control
		Lparameters m.tnParam
		
		_vfp.AutoYield = FALSE
		
		This.Visible = This._Visible
		
		This._InitLibrary()
		This._InitCommonControls()
		This._SetProperties()
		This._AddObjects()
		This._SetControlSource()
		This._SetEnabled()
		This._BindEvents()
		This._CreateCallBack()
		
		*!* If we have a parameter, some other ctl32 control is parent, do no create control
		*!* Let parent call ctlCreate()
		
		If Vartype(m.tnParam) = T_LOGICAL Then
			This._Create()
		Endif
		
		Raiseevent(This, "ctlInit")
		
	ENDPROC

	PROCEDURE _addobjects		&& Adds objects used by the class.
		*!* _AddObjects()
		
		This._FontDefaultLogFont = Createobject("_LOGFONT")
		
	ENDPROC

	PROCEDURE _bindevents		&& Binds to events used by the class.
		*!* _BindEvents()
		
		*!* Instead of writing code in this events, we bind to them
		*!* just in case code is added in subclasses without a dodefault
		
		Bindevent(This, "Destroy", This, "ctlDispose")
		
		*!* Manage resize and move of the control:
		Bindevent(This, "Resize", This, "_OnResize", 1)
		Bindevent(This, "Moved", This, "_OnMoved", 1)
		
		*!* manage value changes of the control source
		*Bindevent(This.ctlTextBox, "ProgrammaticChange", This, "_OnProgrammaticChange", 1)
		Bindevent(This.ctlTextBox, "Value", This, "_OnValue", 1)
		
		*!* Manage theme changing
		Bindevent(_Screen, "Themes", This, "_OnThemes", 1)
		
		If Thisform.Name # _Screen.Name Then
			Bindevent(Thisform, "Themes", This, "_OnThemes", 1)
		Endif
		
		*!* We will create a background brush here
		Bindevent(Thisform, "Paint", This, "_OnFormPaint", 1)
		
		*!* If we have pages in the object hierarchy, monitor page activate/deactive
		*!* to hide/show the windows control
		If This._InPage = TRUE
			Local loPage As Control
			m.loPage = This._GetPage()
			Bindevent(m.loPage, "Activate", This, "_OnPageActivate", 1)
			Bindevent(m.loPage, "Deactivate", This, "_OnPageDeactivate", 1)
			m.loPage = .Null.
			Release m.loPage
		Endif
		
		*!* Add BindWindowsEventsProxy property to Form :
		If Not Pemstatus(Thisform,"BindWindowsEventsProxy", 5)
			Thisform.Newobject("BindWindowsEventsProxy", "BindWindowsEventsProxy", Addbs(Justpath(This.ClassLibrary)) + "vfpx.vcx")
		Endif
		
		*!* Bind to general window messages proxy:
		Bindevent(Thisform.BindWindowsEventsProxy, "_Msg", This, "_FormMessageHandler", 1)
		
		*!* This will tell us when there is a mouse click in a control
		Bindevent(This.ctlHostFormhWnd, WM_PARENTNOTIFY, Thisform.BindWindowsEventsProxy , "_MsgHandler", 4)
		
		*!* This is to pass a background brush for trackbars
		Bindevent(This.ctlHostFormhWnd, WM_CTLCOLORSTATIC, Thisform.BindWindowsEventsProxy , "_MsgHandler", 4)
		
		*!* This is to pass a background brush for scrollbars
		*!*Bindevent(This.ctlHostFormhWnd, WM_CTLCOLORSCROLLBAR, Thisform.BindWindowsEventsProxy , "_MsgHandler", 4)
		
		Bindevent(This.ctlHostFormhWnd, WM_TIMER, Thisform.BindWindowsEventsProxy , "_MsgHandler", 4)
		
		*!* Add BindWindowsEventsProxy property to _VFP :
		If Not Pemstatus(_vfp, "BindWindowsEventsProxy", 5)
			AddProperty(_vfp, "BindWindowsEventsProxy", .Null.)
		Endif
		
		*!* Create BindWindowsEventsProxy object:
		If Not Vartype(_vfp.BindWindowsEventsProxy) = "O"
			_vfp.BindWindowsEventsProxy = Newobject("BindWindowsEventsProxy", Addbs(Justpath(This.ClassLibrary)) + "vfpx.vcx")
		Endif
		
		*!* Bind to BindWindowsEventsProxy _Msg property changes:
		Bindevent(_vfp.BindWindowsEventsProxy, "_Msg", This,"_VFPMessageHandler")
		
		
	ENDPROC

	PROCEDURE _callbackproc
		*!* _CallbackProc
		
		Lparameters nHWnd As Integer, Msg As Integer, wParam As Integer, Lparam As Integer
		
		*!* Debugout m.nHWnd, m.Msg, m.wParam, m.Lparam
		
		Do Case
		
			Case m.Msg = WM_SETFOCUS
				This._Focused = TRUE
				If This._ControlHasOwnFocusCue = FALSE And This.ctlShowFocusCues = TRUE Then
					This._DrawFocusRect()
				Endif
		
			Case m.Msg = WM_KILLFOCUS
				This._Focused = FALSE
				If This._ControlHasOwnFocusCue = FALSE AND This.ctlShowFocusCues = TRUE Then
					This._DrawFocusRect()
				Endif
		
			Case m.Msg = WM_CHAR
		
				Local lnKeyShift
				*!* SHIFT KEY
				m.lnKeyShift = Bitand(apiGetKeyState(VK_SHIFT), 	0x8000)
		
				Do Case
		
					Case m.wParam = 9 And m.lnKeyShift # 0
						apiSetfocus(Thisform.HWnd)
						Keyboard '{LEFTARROW}' Plain
		
					Case m.wParam = 9
						apiSetfocus(Thisform.HWnd)
						Keyboard '{TAB}' Plain
		
					Case m.wParam = 13
						apiSetfocus(Thisform.HWnd)
						Keyboard '{ENTER}' Plain
		
					Case m.wParam = 27
						apiSetfocus(Thisform.HWnd)
						Keyboard '{ESC}' Plain
						*!* reset Focus to control window
						If This.ctlCanFocus Then
							apiSetfocus(This._ControlHwnd)
						Endif
		
				Endcase
		
		Endcase
		
		Return apiCallWindowProc(This._ControlWindowProcAddress, m.nHWnd, m.Msg, m.wParam, m.Lparam)
		
		
	ENDPROC

	PROCEDURE _create		&& Creates the windows control
		*!*	_Create()
		
		If This._ControlHwnd # 0 Then
			*!* if we have saved the old window procedure
			If This._ControlWindowProcAddress # 0 Then
				*!* Restore original window procedure
				apiSetWindowLong(This._ControlHwnd, GWL_WNDPROC, This._ControlWindowProcAddress)
				This._ControlWindowProcAddress = 0
			Endif
			apiDestroyWindow(This._ControlHwnd)
		Endif
		
		This._SetBackStyle()
		
		This._PreCreate()
		
		Local ;
			dwExStyle As Integer, ;
			lpClassName As String, ;
			lpWindowName As String, ;
			dwStyle As Integer, ;
			lnTop As Integer, ;
			lnLeft As Integer, ;
			nWidth As Integer, ;
			nHeight As Integer, ;
			hWndParent As Integer, ;
			hMenu As Integer, ;
			hInstance As Integer, ;
			lpParam As Integer
		
		If This._RecreatingHandle Then
			Return
		Endif
		
		*!* We enter Initialization Stage...
		This._RecreatingHandle = TRUE
		
		*!* Define parameters for apiCreateWindowEx:
		m.dwExStyle 	= This._GetdwExStyle()
		m.lpClassName 	= This._GetlpClassName()
		m.lpWindowName 	= This._GetlpWindowName()
		m.dwStyle 		= This._GetdwStyle()
		
		m.lnLeft = This.ctlLocationLeft
		m.lnTop  = This.ctlLocationTop
		
		If This._PopUp = TRUE Then
			ctlClientToScreen(This.ctlHostHwnd, @m.lnLeft, @m.lnTop)
		Endif
		
		m.nWidth = 	This.Width
		m.nHeight = This.Height
		
		m.hWndParent = This.ctlHostHwnd
		m.hMenu = 0
		m.hInstance = 0
		m.lpParam = 0
		
		This._ControlHwnd = apiCreateWindowEx( ;
			m.dwExStyle, ;
			m.lpClassName, ;
			m.lpWindowName, ;
			m.dwStyle, ;
			m.lnLeft, ;
			m.lnTop, ;
			m.nWidth, ;
			m.nHeight, ;
			m.hWndParent,  ;
			m.hMenu, ;
			m.hInstance, ;
			m.lpParam)
		
		*!* Here we subclass the control window procedure
		This._ControlWindowProcAddress = apiSetWindowLong(This._ControlHwnd, GWL_WNDPROC, This._CallbackProcAddress)
		
		*!* Debugout This._ControlWindowProcAddress, This._CallbackProcAddress
		
		This._GetDefaultFont()
		This._GetDefaultSize()
		
		This._PostCreate()
		
		This._SetValue()
		This._SetThemes()
		This._SetEnabled()
		
		This._SetVisible()
		
		*!* We finish Initialization State
		This._RecreatingHandle = FALSE
		
		
		
	ENDPROC

	PROCEDURE _createbackgroundbrush		&& Creates a brush.
		*!* _CreateBackGroundBrush()
		
		*!* Here we create a background brush.
		*!* If the control is on a themed Pageframe, this brush is a bitmap
		*!* 1 pixel wide, and tall as the control, we use the column of pixels
		*!* just to the left of the control.
		
		*!* Get rid of current BackGround Brush
		If This._BackGroundBrush # 0 Then
			apiDeleteObject(This._BackGroundBrush)
			This._BackGroundBrush = 0
		Endif
		
		Local loPageFrame As PageFrame
		
		m.loPageFrame = This._GetPageFrame()
		
		Do Case
		
			Case This.ctlBackStyle = 0 And This._InPage And ctlIsThemeActive(m.loPageFrame)
		
				Local lnTempDc, lnBitmap, lnCompatDc
		
				m.lnTempDc = apiGetDc(Thisform.HWnd)
		
				m.lnBitmap = apiCreateCompatibleBitmap(m.lnTempDc, 1, This.Height)
		
				m.lnCompatDc = apiCreateCompatibleDC(m.lnTempDc)
		
				apiSelectObject(m.lnCompatDc, m.lnBitmap)
		
				apiBitBlt(m.lnCompatDc, 0, 0, 1, This.Height, m.lnTempDc, Objtoclient(This, 2) - 1, Objtoclient(This, 1), SRCCOPY)
		
				This._BackGroundBrush = apiCreatePatternBrush(m.lnBitmap)
		
				apiReleaseDc(Thisform.HWnd, m.lnTempDc)
				apiDeleteObject(m.lnBitmap)
				apiDeleteObject(m.lnCompatDc)
		
				m.loPageFrame = .Null.
				Release m.loPageFrame
		
			Case This.ctlBackStyle = 0
		
				If Type("This.Parent.BackColor") # T_UNDEFINED
					This._BackGroundBrush = apiCreateSolidBrush(This.Parent.BackColor)
				Else
					This._BackGroundBrush = apiCreateSolidBrush(Thisform.BackColor)
				Endif
		
			Case This.ctlBackStyle = 1 And This.ctlBackColor = -1
				This._BackGroundBrush = apiCreateSolidBrush(This.ctlDefaultBackColor)
		
			Otherwise
		
				This._BackGroundBrush = apiCreateSolidBrush(This.ctlBackColor)
		
		Endcase
		
	ENDPROC

	PROCEDURE _createcallback
		*!* _CreateCallback()
		
		This._CallbackProcAddress = CREATECALLBACKFUNC("_CallbackProc", "INTEGER","INTEGER,INTEGER,INTEGER,INTEGER", This, 1)
		
	ENDPROC

	PROCEDURE _destroycallback
		*!* _DestroyCallback()
		
		If This._CallbackProcAddress # 0 Then
			DestroyCallbackFunc(This._CallbackProcAddress)
		Endif
		
	ENDPROC

	PROCEDURE _drawfocusrect		&& Draws a focus rectangle for controls that do not have one.
		*!* _DrawFocusRect()
		
		Local ;
			lnx, ;
			lny, ;
			lnx1, ;
			lny1, ;
			lnx2, ;
			lny2, ;
			lnDrawWidth, ;
			lnDrawMode
		
		m.lnDrawWidth = Thisform.DrawWidth
		m.lnDrawMode = Thisform.DrawMode
		
		Thisform.DrawWidth = 1
		Thisform.DrawMode = 6
		
		m.lnx1 = This.Left - 1
		m.lnx2 = This.Left + This.Width
		m.lny1 = This.Top - 1
		m.lny2 = This.Top + This.Height
		
		For m.lnx = m.lnx1 To m.lnx2 Step 2
			Thisform.Line(m.lnx, m.lny1, m.lnx + 1, m.lny1)
		Endfor
		
		For m.lnx = m.lnx1 + Mod(m.lny2 - m.lny1, 2) To m.lnx2 Step 2
			Thisform.Line(m.lnx, m.lny2, m.lnx + 1, m.lny2)
		Endfor
		
		For m.lny = m.lny1 + 2 To m.lny2 - 1 Step 2
			Thisform.Line(m.lnx1, m.lny, m.lnx1, m.lny + 1 )
		Endfor
		
		For m.lny = m.lny1 + 2 - Mod(m.lnx2 - m.lnx1, 2) To m.lny2 - 1 Step 2
			Thisform.Line(m.lnx2, m.lny, m.lnx2, m.lny + 1 )
		Endfor
		
		Thisform.DrawWidth = m.lnDrawWidth
		Thisform.DrawMode = m.lnDrawMode
		
	ENDPROC

	PROCEDURE _formmessagehandler
		*!* _FormMessageHandler()
		
		Do Case
		
			Case Thisform.BindWindowsEventsProxy._Msg = WM_PARENTNOTIFY
		
				Local lnX, lnY, lcPoint
		
				*!* If we have a mouse click
				If This.ctlEnabled And Inlist(Thisform.BindWindowsEventsProxy._wParam, WM_LBUTTONDOWN, WM_RBUTTONDOWN, WM_MBUTTONDOWN)
		
					*!* Get mouse click coordinates in pixels relative to form:
					m.lnX = ctlLoWord(Thisform.BindWindowsEventsProxy._lParam)
					m.lnY = ctlHiWord(Thisform.BindWindowsEventsProxy._lParam)
		
					*!* Check if control window is under that point:
					*!* We can only get this messages from visible windows
					If This.ctlVisible = TRUE ;
							And Between(m.lnX, This.ctlLocationLeft, This.ctlLocationLeft + This.Width) ;
							And Between(m.lnY, This.ctlLocationTop, This.ctlLocationTop + This.Height) Then
		
						If This.ctlCanFocus Then
							If This.ctlTextbox.ctlFocused = FALSE Then
								This.SetFocus()
							Endif
							apiSetFocus(This._ControlHwnd)
						Endif
		
						*!* Raise click/rightclick/middleclick event
						Do Case
								*!* special case if this is a monthcalendar control
							Case Thisform.BindWindowsEventsProxy._wParam = WM_LBUTTONDOWN And This._GetlpClassName() == MONTHCAL_CLASSA
								Local ;
									loMcHitTestInfo As _MCHITTESTINFO, ;
									lcMcHitTestInfo As String, ;
									loPoint As _POINT, ;
									lcPoint As String
		
								m.loMcHitTestInfo = Newobject("_MCHITTESTINFO")
								m.loPoint = Newobject("_POINT")
		
								m.lcPoint = m.loPoint.Value
		
								*!* Get mouse position in monthcalendar window coordinates:
								apiGetCursorPos(@m.lcPoint)
								apiScreenToClient(This._ControlHwnd, @m.lcPoint)
								m.loPoint.Value = m.lcPoint
		
								*!* Set coordinates of structure
								m.loMcHitTestInfo.pt.X = m.loPoint.X
								m.loMcHitTestInfo.pt.Y = m.loPoint.Y
		
								*!* Send MCM_HITTEST message to get where click was
								*m.lcMcHitTestInfo = m.loMcHitTestInfo.Value
								apiSendMessageInteger(This._ControlHwnd, MCM_HITTEST, 0, m.loMcHitTestInfo.Address)
								*m.loMcHitTestInfo.Value = m.lcMcHitTestInfo
		
								*?This._ControlHwnd,m.loMcHitTestInfo.uHit, MCHT_CALENDARDATE, MCHT_TODAYLINK
		
								If Seconds() - This._ClickTime < apiGetDoubleClickTime() / 1000 Then
									*!* Only raise DblClick if clicked on day or today
									If Inlist(m.loMcHitTestInfo.uHit, MCHT_CALENDARDATE, MCHT_TODAYLINK) Then
										Raiseevent(This, "DblClick")
									Endif
								Else
									This._ClickTime = Seconds()
									Raiseevent(This, "Click")
								Endif
		
								m.loMcHitTestInfo = .Null.
								m.lcPoint = .Null.
		
							Case Thisform.BindWindowsEventsProxy._wParam = WM_LBUTTONDOWN
								If Seconds() - This._ClickTime < apiGetDoubleClickTime() / 1000 Then
									Raiseevent(This, "DblClick")
								Else
									This._ClickTime = Seconds()
									Raiseevent(This, "Click")
								Endif
		
							Case Thisform.BindWindowsEventsProxy._wParam = WM_RBUTTONDOWN
								Raiseevent(This, "RightClick")
		
							Case Thisform.BindWindowsEventsProxy._wParam = WM_MBUTTONDOWN
								Raiseevent(This, "MiddleClick")
		
						Endcase
					Endif
				Endif
		
			Case Thisform.BindWindowsEventsProxy._Msg = WM_CTLCOLORSTATIC
		
				*!* here we provide a background brush
		
				*!* If the message is not for this control, just return
				If Thisform.BindWindowsEventsProxy._lParam = This._ControlHwnd Then
					*!* Return a background brush (Brush can just be 0)
					Thisform.BindWindowsEventsProxy._Result = This._BackGroundBrush
				Endif
		
		Endcase
		
		
	ENDPROC

	PROCEDURE _getdefaultfont
		*!* _GetDefaultFont()
		
		*!* This saves the default font of the control
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		Local ;
			lnFontHandle As Integer, ;
			lcLogFont As String
		
		*!* Get a handle to the current font
		m.lnFontHandle = apiSendMessageInteger(This._ControlHwnd, WM_GETFONT, 0, 0)
		
		*!* Get a LogFont structure
		m.lcLogFont = This._FontDefaultLogFont.Value
		
		*!* Get font info from font handle
		apiGetObject(m.lnFontHandle, Len(m.lcLogFont), @m.lcLogFont)
		
		*!* Save LogFont structure
		This._FontDefaultLogFont.Value = m.lcLogFont
		
		*!* Fix MonthCalendar UGLY default non-themed font:
		If This._GetlpClassName() = MONTHCAL_CLASSA Then
			If ctlGetOsVersion() < CON_OS_WINVISTA Then
				This._FontDefaultLogFont.FontName = "Tahoma"
			Else
				This._FontDefaultLogFont.FontBold = FALSE
				This._FontDefaultLogFont.FontName = "Segoe UI"
				This._FontDefaultLogFont.FontSize = 8
			Endif
		Endif
		
		This._EnableUpdates = FALSE
		
		*!* Now set value of default properties:
		If Sys(1269, This, "ctlFontBold", 0) = FALSE Then
			This.ctlFontBold =  This._FontDefaultLogFont.FontBold
		Endif
		
		If Sys(1269, This, "ctlFontCharSet", 0) = FALSE Then
			This.ctlFontCharSet = This._FontDefaultLogFont.FontCharSet
		Endif
		
		If Sys(1269, This, "ctlFontStrikethru", 0) = FALSE Then
			This.ctlFontItalic = This._FontDefaultLogFont.FontItalic
		Endif
		
		If Sys(1269, This, "ctlFontName", 0) = FALSE
			This.ctlFontName = This._FontDefaultLogFont.FontName
		Endif
		
		If Sys(1269, This, "ctlFontSize", 0) = FALSE Then
			This.ctlFontSize = This._FontDefaultLogFont.FontSize
		Endif
		
		If Sys(1269, This, "ctlFontStrikethru", 0) = FALSE Then
			This.ctlFontStrikethru = This._FontDefaultLogFont.FontStrikethru
		Endif
		
		If Sys(1269, This, "ctlFontUnderline", 0) = FALSE Then
			This.ctlFontUnderline = This._FontDefaultLogFont.FontUnderline
		Endif
		
		This._EnableUpdates = TRUE
		
		This._SetFont()
		
		
		
		
	ENDPROC

	PROCEDURE _getdefaultsize
		*!* _GetDefaultSize()
	ENDPROC

	PROCEDURE _getdwexstyle
		*!* _GetdwExStyle()
		
		Return 0
		
	ENDPROC

	PROCEDURE _getdwstyle
		*!* _GetdwStyle
		
		Return 0
		
	ENDPROC

	PROCEDURE _getlpclassname
		*!* _GetlpClassName()
	ENDPROC

	PROCEDURE _getlpwindowname
		*!* _GetWindowName
		
		Return ""
		
		
	ENDPROC

	PROCEDURE _getpage		&& Returns an object reference to the page that contains this control.
		*!* _GetPage()
		
		Local loControl As Control
		
		m.loControl = This
		
		Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE
		
			If Upper(m.loControl.BaseClass) == "PAGE" Then
				Exit
			Endif
		
			m.loControl = m.loControl.Parent
		
		Enddo
		
		Return m.loControl
		
	ENDPROC

	PROCEDURE _getpageframe
		*!* _GetPageFrame()
		
		Local loControl as Control
		
		m.loControl = This
		
		Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE
		
			If Upper(m.loControl.BaseClass) == "PAGEFRAME" Then
				Exit
			Endif
		
			m.loControl = m.loControl.Parent
		
		Enddo
		
		Return m.loControl
		
	ENDPROC

	PROCEDURE _initcommoncontrols
		*!* _InitCommonControls()
		
		Local lcControls As String
		
		*!* This is needed to make the month calendar common control work in windows 2000
		If Type("_Screen._0BCB895540F84134BDF39BB58FE0D43F") = T_UNDEFINED Then
		
			_Screen.AddProperty("_0BCB895540F84134BDF39BB58FE0D43F", TRUE)
		
			m.lcControls = BinToC(8, "4rs") + BinToC(ICC_DATE_CLASSES, "4RS")
			apiInitCommonControlsEx(@m.lcControls)
		
		Endif
		
	ENDPROC

	PROCEDURE _initlibrary
		*!* _InitLibrary()
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
	ENDPROC

	PROCEDURE _iscontrolinpage		&& Returns TRUE if the control is contained in a page.
		*!* _IsControlInPage()
		
		Local ;
			llPageFound As Boolean, ;
			loControl As Control
		
		m.llPageFound = FALSE
		
		m.loControl = This
		
		Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE
		
			If Upper(m.loControl.BaseClass) == "PAGE" Then
				m.llPageFound = TRUE
				Exit
			Endif
		
			If Type("m.loControl.Parent") # T_UNDEFINED Then
				m.loControl = m.loControl.Parent
			Else
				Exit
			Endif
		
		Enddo
		
		m.loControl = .Null.
		Release m.loControl
		
		Return m.llPageFound
		
		
	ENDPROC

	PROCEDURE _objtoclient		&& Replaces OBJTOCLIENT that has bugs.
		*!* _ObjToClient(cPosition)
		
		Lparameters m.tcPosition As String
		
		Local ;
			lnPosition As Integer, ;
			loControl As Control
		
		m.tcPosition = Upper(m.tcPosition)
		m.lnPosition = 0
		m.loControl = This
		
		Do Case
		
			Case m.tcPosition $ "TOP|BOTTOM"
				*!* 20070711 Modified to account for toolbars
				Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE
					If Pemstatus(m.loControl, "Top", CTLPEMSTATUS_DEFINED) Then
						m.lnPosition = m.lnPosition + m.loControl.Top
					Endif
					If Upper(m.loControl.BaseClass) == "PAGE" Then
						If m.loControl.Parent.TabOrientation = CTLTABORIENTATION_TOP Then	&& Top
							m.lnPosition = m.lnPosition + ;
								m.loControl.Parent.Height - ;
								m.loControl.Parent.PageHeight - ;
								m.loControl.Parent.BorderWidth * 2
						Else
							m.lnPosition = m.lnPosition + 1
						Endif
					Endif
					m.loControl = m.loControl.Parent
				Enddo
		
				If m.tcPosition == "BOTTOM" Then
					m.lnPosition = m.lnPosition + This.Height
				Endif
		
			Case m.tcPosition $ "LEFT|RIGHT"
				*!* 20070711 Modified to account for toolbars
				Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE
					If Pemstatus(m.loControl, "Left", CTLPEMSTATUS_DEFINED) Then
						m.lnPosition = m.lnPosition + m.loControl.Left
					Endif
					If Upper(m.loControl.BaseClass) == "PAGE"
						If m.loControl.Parent.TabOrientation = CTLTABORIENTATION_LEFT Then	&& Left
							m.lnPosition = m.lnPosition + ;
								m.loControl.Parent.Width - ;
								m.loControl.Parent.PageWidth - ;
								m.loControl.Parent.BorderWidth * 2
						Else
							m.lnPosition = m.lnPosition + 1
						Endif
					Endif
					m.loControl = m.loControl.Parent
				Enddo
		
				If m.tcPosition == "RIGHT" Then
					m.lnPosition = m.lnPosition + This.Width
				Endif
		
		Endcase
		
		m.loControl = .Null.
		Release m.loControl
		
		Return m.lnPosition
		
	ENDPROC

	PROCEDURE _onformborderstyle
	ENDPROC

	PROCEDURE _onformpaint
		*!* _OnFormPaint()
		
		This._CreateBackgroundBrush()
		
		Unbindevents(Thisform, "Paint", This, "_OnFormPaint")
		
		
	ENDPROC

	PROCEDURE _onformresize
	ENDPROC

	PROCEDURE _onmoved		&& Bindevent(This, "Moved", This, "_OnMoved", 1)
		*!* _OnMoved()
		
		Local ;
			lhwnd As Integer, ;
			lhWndInsertAfter As Integer, ;
			lnLeft As Integer, ;
			lnTop As Integer, ;
			lnWidth As Integer, ;
			lnHeight As Integer, ;
			lwFlags As Integer, ;
			loPageFrame As PageFrame
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		m.loPageFrame = This._GetPageFrame()
		
		*!* If control is in a pageframe, update background brush since it is no longer valid
		If This.ctlBackStyle = 0 And This._InPage And ctlIsThemeActive(m.loPageFrame) Then
			This._CreateBackgroundBrush()
		Endif
		
		m.loPageFrame = .Null.
		Release m.loPageFrame
		
		m.lhwnd 			= This._ControlHwnd
		m.lhWndInsertAfter 	= 0
		
		m.lnLeft = This.ctlLocationLeft
		m.lnTop  = This.ctlLocationTop
		
		If This._PopUp = TRUE Then
			ctlClientToScreen(This.ctlHostHwnd, @m.lnLeft, @m.lnTop)
		Endif
		
		m.lnWidth 	= This.Width
		m.lnHeight 	= This.Height
		m.lwFlags	= SWP_NOZORDER
		
		*!* This is here cause we are getting dll exception when month calendar
		*!* control has more than one row and column
		Try
			apiSetWindowPos( ;
				m.lhwnd, ;
				m.lhWndInsertAfter,;
				m.lnLeft, ;
				m.lnTop, ;
				m.lnWidth, ;
				m.lnHeight, ;
				m.lwFlags)
		Catch
		Endtry
		
		
	ENDPROC

	PROCEDURE _onpageactivate		&& Bindevent(m.loControl, "Activate", This, "_OnPageActivate", 1)
		*!* _OnPageActivate()
		
		This._PageActive = TRUE
		This._SetVisible()
	ENDPROC

	PROCEDURE _onpagedeactivate		&& Bindevent(m.loControl, "Deactivate", This, "_OnPageDeactivate", 1)
		*!* _OnPageDeactivate()
		
		This._PageActive = FALSE
		This._SetVisible()
	ENDPROC

	PROCEDURE _onparentbackcolor
		*!* _OnParentBackColor()
		
		This._CreateBackGroundBrush()
		
		This.ctlRefresh()
		
	ENDPROC

	PROCEDURE _onresize		&& Bindevent(This, "Resize", This, "_OnResize", 1)
		*!* _OnResize()
		
		This._OnMoved()
	ENDPROC

	PROCEDURE _onthemes		&& Bindevent(_Screen, "Themes", This, "_OnThemes", 1) / Bindevent(Thisform, "Themes", This, "_OnThemes", 1)
		*!* _OnThemes()
		
		This._SetThemes()
		
	ENDPROC

	PROCEDURE _onvalue
		*!* _OnValue()
		
		This.ctlValue = This.ctlTextBox.Value
		
	ENDPROC

	PROCEDURE _postcreate
		*!* _PostCreate()
		
		
	ENDPROC

	PROCEDURE _precreate
		*!* _PreCreate()
	ENDPROC

	PROCEDURE _reparent
		*!* _Reparent()
		
		This._PopUp = TRUE
		apiSetParent(This._ControlHwnd, 0)
		This._OnMoved()
		
	ENDPROC

	PROCEDURE _setautosize
		*!* _SetAutosize()
		
	ENDPROC

	PROCEDURE _setbackcolor
		*!* _SetBackColor()
	ENDPROC

	PROCEDURE _setbackstyle
		*!* _SetBackStyle()
		
		*!* We get here only of ctlBackStyle changed
		
		*!* We bind to form activate if we have a ctlBackStyle = 0
		If This.ctlBackStyle = 0 Then
		
			If Type("This.Parent.BackColor") # T_UNDEFINED
				Bindevent(This.Parent, "BackColor", This, "_OnParentBackColor", 1)
			Else
				Bindevent(Thisform, "BackColor", This, "_OnParentBackColor", 1)
			Endif
		
		Else
		
			If Type("This.Parent.BackColor") # T_UNDEFINED
				Unbindevent(This.Parent, "BackColor", This, "_OnParentBackColor")
			Else
				Unbindevent(Thisform, "BackColor", This, "_OnParentBackColor")
			Endif
		
		Endif
		
		This._CreateBackGroundBrush()
		
		This.ctlRefresh()
		
		
	ENDPROC

	PROCEDURE _setbordercolor
		*!* _SetBorderColor()
	ENDPROC

	PROCEDURE _setcontrolsource
		*!* _SetControlSource()
		
		This.ctlTextBox.ControlSource = This.ctlControlSource
		
		If Not Empty(This.ctlControlSource) Then
			This.ctlValue = This.ctlTextBox.Value
		Endif
		
	ENDPROC

	PROCEDURE _setenabled
		*!* _SetEnabled()
		
		*!* We want the focus to go to the next enabled control if this control
		*!* gets disabled while it has the focus, so we disable the dummy textbox
		*!* first. We then disable the container to prevent click events to fire.
		*!* To be shure, we give keyboard focus to the form
		
		
		This.ctlTextBox.Enabled = This.ctlEnabled And This.ctlCanFocus
		This.Enabled = This.ctlEnabled And This.ctlCanFocus
		
		If This.ctlEnabled = FALSE Then
			If Thisform.HWnd = apiGetActiveWindow()
				apiSetfocus(Thisform.HWnd)
			Endif
		Endif
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlEnabled = TRUE Then
			apiEnableWindow(This._ControlHwnd, TRUE)
		Else
			*!* Return keyboard focus to form
			apiEnableWindow(This._ControlHwnd, FALSE)
		Endif
		
		
	ENDPROC

	PROCEDURE _setfont
		*!* _SetFont()
		
		*!*	typedef struct tagLOGFONT {
		*!*	  LONG lfHeight;
		*!*	  LONG lfWidth;
		*!*	  LONG lfEscapement;
		*!*	  LONG lfOrientation;
		*!*	  LONG lfWeight;
		*!*	  BYTE lfItalic;
		*!*	  BYTE lfUnderline;
		*!*	  BYTE lfStrikeOut;
		*!*	  BYTE lfCharSet;
		*!*	  BYTE lfOutPrecision;
		*!*	  BYTE lfClipPrecision;
		*!*	  BYTE lfQuality;
		*!*	  BYTE lfPitchAndFamily;
		*!*	  TCHAR lfFaceName[LF_FACESIZE];
		*!*	} LOGFONT, *PLOGFONT;
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This._EnableUpdates = FALSE Then
			Return
		Endif
		
		Local ;
			loLogFont As _LOGFONT, ;
			lcLogFont As String
		
		m.loLogFont = Createobject("_LOGFONT")
		m.loLogFont.Value = This._FontDefaultLogFont.Value
		
		*!* Fill members of font structure:
		With m.loLogFont
			.FontBold			= This.ctlFontBold
			.FontCharSet		= This.ctlFontCharSet
			.FontItalic 		= This.ctlFontItalic
			.FontName 			= This.ctlFontName + NULA
			.FontSize			= This.ctlFontSize
			.FontStrikethru 	= This.ctlFontStrikethru
			.FontUnderline 		= This.ctlFontUnderline
		Endwith
		
		*!* Release Font object if we already have one:
		If This._FontHandle # 0 Then
			apiDeleteObject(This._FontHandle )
		Endif
		
		m.lcLogFont = m.loLogFont.Value
		
		*!* Create a new font object:
		This._FontHandle = apiCreateFontIndirect(@m.lcLogFont)
		
		*!* Set control font to this font object:
		apiSendMessageInteger(This._ControlHwnd, WM_SETFONT, This._FontHandle, 1)
		
		m.loLogFont = .Null.
		Release m.loLogFont
		
		
	ENDPROC

	PROCEDURE _setforecolor
		*!* _SetForeColor()
	ENDPROC

	PROCEDURE _setorientation
		*!* _SetOrientation()
	ENDPROC

	PROCEDURE _setproperties
		*!* _SetProperties()
		
		*!* Specifies if control is inside a pageframe
		This._InPage = This._IsControlInPage()
		
		*This._FormType = ctlGetFormType(This)
		
		
	ENDPROC

	PROCEDURE _setshowfocuscues
		*!* _SetShowFocusCues()
		
		Local wParam As Integer
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlShowFocusCues Then
			m.wParam = ctlMakewParam(UIS_CLEAR, UISF_HIDEFOCUS)
		Else
			m.wParam = ctlMakewParam(UIS_SET, UISF_HIDEFOCUS)
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, WM_CHANGEUISTATE, m.wParam, 0)
		
	ENDPROC

	PROCEDURE _setthemes
		*!* _SetThemes()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If ctlIsThemeActive(This) = TRUE Then
			apiSetWindowTheme(This._ControlHwnd, .Null., .Null.)
		Else
			apiSetWindowTheme(This._ControlHwnd, .Null., "")
		Endif
		
		
	ENDPROC

	PROCEDURE _setvalue
		*!* _SetValue()
		
		If Not Empty(This.ctlTextBox.ControlSource) Then
			This.ctlTextBox.Value = This.ctlValue
			Thisform.Refresh()
		Endif
		
		Raiseevent(This, "ctlValueChanged")
		
		
	ENDPROC

	PROCEDURE _setvisible
		*!* _SetVisible()
		
		Local m.llVisible As Logical
		
		m.llVisible = This.ctlVisible
		
		If This._InPage = TRUE
			m.llVisible = This._PageActive And m.llVisible
		Endif
		
		*!* Set the container control itself visible property
		This.Visible = m.llVisible And This._Visible
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If m.llVisible = TRUE Then
		*	apiShowWindow(This._ControlHwnd, SW_SHOWNA)
			apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0, 0, 0, 0, BITOR(SWP_NOACTIVATE, SWP_NOMOVE, SWP_NOSIZE, SWP_SHOWWINDOW))
		Else
			apiShowWindow(This._ControlHwnd, SW_HIDE)
		Endif
		
		
	ENDPROC

	PROCEDURE _updatecolors
		*!* _UpdateColors()
	ENDPROC

	PROCEDURE _vfpmessagehandler
		*!* _VFPMessageHandler
		*!* This binds to the _Msg property of the BindWindowsEventsProxy object of _VFP
		
		Do Case
		
			Case _vfp.BindWindowsEventsProxy._Msg = WM_THEMECHANGED
				This._SetThemes()
		
				This._CreateBackGroundBrush()
				
				*!* Update colors if needed
				This._UpdateColors()
		
				*!* Send a color change message to control to force redraw and
				*!* prevent glitches
				If This._ControlHwnd # 0 Then
					apiSendMessageInteger(This._ControlHwnd, WM_SYSCOLORCHANGE , 0, 0)
				Endif
		
		Endcase
		
	ENDPROC

	PROCEDURE ctlTextBox.GotFocus
		*!* GotFocus()
		
		This.ctlFocused = TRUE
		
		*!* Set Focus to control window
		If This.Parent.ctlCanFocus Then
			apiSetfocus(This.Parent._ControlHwnd)
		Endif
		
		
		
	ENDPROC

	PROCEDURE ctlTextBox.Init
		This.AddProperty("ctlFocused", FALSE)
	ENDPROC

	PROCEDURE ctlTextBox.LostFocus
		*!* LostFocus()
		
		This.ctlFocused = FALSE
		
		Do Case
			Case _vfp.HWnd = apiGetActiveWindow()
		
				If Type("_Screen.ActiveForm") = "O" And _Screen.ActiveForm.HWnd = Thisform.HWnd Then
					apiSetfocus(Thisform.HWnd)
				Endif
		
			Case Thisform.HWnd = apiGetActiveWindow()
				apiSetfocus(Thisform.HWnd)
		Endcase
		
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_datepicker AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: controlsource_assign
		*m: ctlcalendarvisible_assign
		*m: ctlcontrolsource_assign
		*m: ctlfocused_access
		*m: ctlinit
		*m: ctlmaxdate_assign
		*m: ctlmindate_assign
		*m: ctlvaluechanged
		*m: ctlvalue_assign
		*m: value_access
		*m: value_assign
		*m: _addobjects
		*m: _bindevents
		*m: _getbordercolor
		*m: _initlibrary
		*m: _oncalendarctlvaluechanged
		*m: _oncalendardblclick
		*m: _onformclick
		*m: _onvalue
		*m: _selectall
		*m: _setcontrolsource
		*m: _setinputmask
		*m: _setvalue
		*m: _validate
		*p: ctlcalendar
		*p: ctlcalendarvisible
		*p: ctlcontrolsource		&& Specifies the source of data to which an object is bound.
		*p: ctlfocused
		*p: ctlmaxdate		&& Gets or sets the maximum date and time that can be selected in the control.
		*p: ctlmindate		&& Gets or sets the minimum date and time that can be selected in the control.
		*p: ctlusedatetime		&& .F.
		*p: ctluseinputmask
		*p: ctlvalue
		*p: _dropdown
		*p: _enableupdates
		*p: _focused
		*p: _markkeypressed
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _shadow
		*p: _textbox
	*</DefinedPropArrayMethod>

	ControlSource = ""
	ctlcalendar = .F.
	ctlcalendarvisible = .F.
	ctlcontrolsource = 		&& Specifies the source of data to which an object is bound.
	ctlfocused = .F.
	ctlmaxdate = (date(9998,12,31))		&& Gets or sets the maximum date and time that can be selected in the control.
	ctlmindate = (date(1800,1,1))		&& Gets or sets the minimum date and time that can be selected in the control.
	ctlusedatetime = .F.		&& .F.
	ctluseinputmask = .F.
	ctlvalue = ({})
	DisplayValue = 
	FontName = "Tahoma"
	FontSize = 8
	Name = "ctl32_datepicker"
	SelectOnEntry = .T.
	Value = 
	Width = 90
	_dropdown = .F.
	_enableupdates = .T.
	_focused = .F.
	_markkeypressed = .F.
	_memberdata = <VFPData>
		<memberdata name="alignment" type="property" display="Alignment"/>
		</VFPData>		&& XML Metadata for customizable properties
	_shadow = 
	_textbox = .F.
	
	PROCEDURE controlsource_assign
		lparameters tuNewValue
		*This.ControlSource = tuNewValue
		
	ENDPROC

	PROCEDURE ctlcalendarvisible_assign
		*!* ctlCalendarVisible_Assign()
		
		Lparameters tuNewValue
		
		This.ctlCalendarVisible = m.tuNewValue
		
		
		If This.ctlCalendarVisible = TRUE Then
		
			This.ToolTipText = ""
		
			This.ctlCalendar.Top = Objtoclient(This, 1) + This.Height
			This.ctlCalendar.Left = Objtoclient(This, 2)
		
			If This.ctlCalendar.Top + This.ctlCalendar.Height > Thisform.Height Then
				This.ctlCalendar.Top = Objtoclient(This, 1) - This.ctlCalendar.Height
			Endif
		
			If This.ctlCalendar.Left + This.ctlCalendar.Width > Thisform.Width Then
				This.ctlCalendar.Left = This.ctlCalendar.Left - (This.ctlCalendar.Width - This.Width)
			Endif
		
		This.ctlCalendar.ctlBorderColor = This._GetBorderColor()
		
		Endif
		
		This.ctlCalendar.ctlVisible = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlcontrolsource_assign
		*!* ctlControlSource_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlControlSource # m.tuNewValue Then
			This.ctlControlSource = m.tuNewValue
			This._SetControlSource()
		Endif
	ENDPROC

	PROCEDURE ctlfocused_access
		*!* ctlFocused_Access()
		
		Return This._Focused
		
	ENDPROC

	PROCEDURE ctlinit
	ENDPROC

	PROCEDURE ctlmaxdate_assign
		*!* ctlMaxDate_Assign()
		
		Lparameters tuNewValue
		
		This.ctlMaxDate = m.tuNewValue
		
		This.ctlCalendar.ctlMaxDate = This.ctlMaxDate
		
	ENDPROC

	PROCEDURE ctlmindate_assign
		*!* ctlMinDate_Assign()
		
		Lparameters tuNewValue
		
		This.ctlMinDate = m.tuNewValue
		
		This.ctlCalendar.ctlMinDate = This.ctlMinDate
		
	ENDPROC

	PROCEDURE ctlvaluechanged
	ENDPROC

	PROCEDURE ctlvalue_assign
		*!* ctlValue_Assign(nValue)
		
		Lparameters m.tuNewValue
		
		Local llError As Boolean
		
		m.llError = FALSE
		
		If Not Empty(m.tuNewValue)
			If m.tuNewValue < This.ctlMinDate Then
				m.tuNewValue = This.ctlMinDate
				m.llError = TRUE
			Endif
		
			If m.tuNewValue > This.ctlMaxDate Then
				m.tuNewValue = This.ctlMaxDate
				m.llError = TRUE
			Endif
		Endif
		
		If This.ctlValue # m.tuNewValue Then
			If This.ctlUseDateTime = TRUE And Vartype(m.tuNewValue) # T_DATETIME Then
				This.ctlValue = Dtot(m.tuNewValue)
			Else
				This.ctlValue = m.tuNewValue
			Endif
			This._SetValue()
		Else
			This.DisplayValue = Dtoc(This.ctlValue)
		Endif
		
		If This.ctlCalendarVisible = FALSE Then
			This.ToolTipText = " " + ctlGetDateFormatEx(m.tuNewValue) + " "
		Endif
		
		If m.llError Then
			??Chr(7)
		Endif
		
	ENDPROC

	PROCEDURE Destroy
		*!* Destroy()
		
		This.ctlCalendar = .Null.
		This._TextBox = .Null.
		
	ENDPROC

	PROCEDURE GotFocus
		*!* GotFocus()
		
		*!* This is done here in case date format was changed
		If Not Empty(This.ctlValue) Then
			This.ctlValue = Date(Year(This.ctlValue), Month(This.ctlValue), Day(This.ctlValue))
		Endif
		
		*!* This is done here in case date format was changed
		If This.ctlUseInputMask = TRUE Then
			This._SetInputMask()
		Endif
		
		*!* In case set century value was changed
		If Set("Century") = "ON" Then
			This.MaxLength = 10
		Else
			This.MaxLength = 8
		Endif
		
		*!* Select whole text even if clicked
		If This.SelectOnEntry
			Nodefault
			ComboBox::GotFocus()
		Endif
		
		This._Focused = TRUE
		
	ENDPROC

	PROCEDURE Init
		*!* Init()
		
		This._InitLibrary()
		This._AddObjects()
		This._BindEvents()
		This._SetControlSource()
		
		*!* Default to current day
		If Empty(This.ctlValue) And Empty(This.ctlControlSource)
			This.ctlValue = Date()
		Endif
		
		This.ctlInit()
		
		
		
	ENDPROC

	PROCEDURE KeyPress
		*!* KeyPress()
		
		Lparameters nKeyCode, nShiftAltCtrl
		
		If This.ReadOnly Then
			Return
		Endif
		
		Local ;
			lcMark As String, ;
			lnMark1 As Integer, ;
			lnMark2 As Integer, ;
			lnSelStart As Integer, ;
			lnSelLength As Integer, ;
			lcSelected As String, ;
			lnDelta As Integer
		
		If Vartype(This.ctlValue) = T_DATETIME Then
			m.lnDelta = 1 * 60 * 60 * 24
		Else
			m.lnDelta = 1
		Endif
		
		*!* Get current date separator
		m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))
		
		*!* Get position of separators
		m.lnMark1 = At(m.lcMark, This.DisplayValue, 1)
		m.lnMark2 = At(m.lcMark, This.DisplayValue, 2)
		
		m.lnSelStart = This.SelStart
		m.lnSelLength = This.SelLength
		
		m.lcSelected = "D"
		
		*!* TAB
		If m.nKeyCode = 9 Then
			Do Case
				Case m.lnMark1 = 0
		
				Case This.SelLength = Len(This.DisplayValue)
		
				Case This.SelStart < m.lnMark1
					This.SelStart = m.lnMark1
					This.SelLength = m.lnMark2 - m.lnMark1 - 1
					Nodefault
					Return
		
				Case This.SelStart >= m.lnMark1 And This.SelStart < m.lnMark2
					This.SelStart = m.lnMark2
					This.SelLength = Len(This.DisplayValue) - m.lnMark2
					Nodefault
					Return
		
			Endcase
		
		Endif
		
		*!* DOWN ARROW / UP ARROW
		If Inlist(m.nKeyCode, 24, 5) And m.nShiftAltCtrl = 0 And This.ctlCalendarVisible = FALSE
			*!* if the whole date is not selected, select the day, month or year
			*!* depending on where the cursor is located:
			If This.SelLength < Len(This.DisplayValue)
				Do Case
					Case This.SelStart < m.lnMark1
						This.SelStart = 0
						This.SelLength = m.lnMark1 - 1
						Do Case
							Case Set("Date", 1) = 0	&& MDY
								m.lcSelected = "M"
							Case Set("Date", 1) = 1	&& DMY
								m.lcSelected = "D"
							Case Set("Date", 1) = 2	&& YMD
								m.lcSelected = "Y"
						Endcase
		
					Case This.SelStart >= m.lnMark1 And This.SelStart < m.lnMark2
						This.SelStart = m.lnMark1
						This.SelLength = m.lnMark2 - m.lnMark1 - 1
						Do Case
							Case Set("Date", 1) = 0	&& MDY
								m.lcSelected = "D"
							Case Set("Date", 1) = 1	&& DMY
								m.lcSelected = "M"
							Case Set("Date", 1) = 2	&& YMD
								m.lcSelected = "M"
						Endcase
		
					Case This.SelStart >= m.lnMark2
						This.SelStart = m.lnMark2
						This.SelLength = Len(This.DisplayValue) - m.lnMark2
						Do Case
							Case Set("Date", 1) = 0	&& MDY
								m.lcSelected = "Y"
							Case Set("Date", 1) = 1	&& DMY
								m.lcSelected = "Y"
							Case Set("Date", 1) = 2	&& YMD
								m.lcSelected = "D"
						Endcase
		
				Endcase
		
				m.lnSelStart = This.SelStart
				m.lnSelLength = This.SelLength
		
			Endif
		
		Endif
		
		Do Case
		
				*!* SPACE, F4
			Case Inlist(m.nKeyCode, -3, 32, 160) And Inlist(m.nShiftAltCtrl, 0, 4)
				This.ctlCalendarVisible = Not This.ctlCalendarVisible
				Nodefault
		
				*!* ESC
			Case m.nKeyCode = 27 And m.nShiftAltCtrl = 0
				If This.ctlCalendarVisible = TRUE Then
					This.ctlCalendarVisible = FALSE
					Nodefault
				Endif
		
				*!* DOWN ARROW
			Case m.nKeyCode = 24 And m.nShiftAltCtrl = 0
				If This.ctlCalendarVisible = TRUE
					This.ctlValue = This.ctlValue + 7 * m.lnDelta
				Else
					Do Case
						Case m.lcSelected = "D"
							This.ctlValue = This.ctlValue - 1 * m.lnDelta
						Case m.lcSelected = "M"
							This.ctlValue = Gomonth(This.ctlValue, -1)
						Case m.lcSelected = "Y"
							This.ctlValue = Gomonth(This.ctlValue, -12)
					Endcase
				Endif
		
				If Empty(This.ctlValue) Then
					If This.ctlUseDateTime = TRUE Then
						This.ctlValue = Datetime(Year(Date()), Month(Date()), Day(Date()), 0, 0, 0)
					Else
						This.ctlValue = Date()
					Endif
				Endif
				Nodefault
		
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
		
				*!* UP ARROW
			Case m.nKeyCode = 5 And m.nShiftAltCtrl = 0
				If This.ctlCalendarVisible = TRUE
					This.ctlValue = This.ctlValue - 7 * m.lnDelta
				Else
					Do Case
						Case m.lcSelected = "D"
							This.ctlValue = This.ctlValue + 1 * m.lnDelta
						Case m.lcSelected = "M"
							This.ctlValue = Gomonth(This.ctlValue, 1)
						Case m.lcSelected = "Y"
							This.ctlValue = Gomonth(This.ctlValue, 12)
					Endcase
				Endif
		
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				Nodefault
		
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
		
				*!* LEFT ARROW
			Case m.nKeyCode = 19 And m.nShiftAltCtrl = 0
				If This.ctlCalendarVisible = TRUE
					This.ctlValue = This.ctlValue - 1 * m.lnDelta
					If Empty(This.ctlValue) Then
						This.ctlValue =Date()
					Endif
					This.SelStart = m.lnSelStart
					This.SelLength = m.lnSelLength
					Nodefault
				Else
					If This.SelLength = Len(This.DisplayValue) Then
						This.SelStart = 0
						This.SelLength = 0
						Nodefault
					Endif
				Endif
		
				*!* RIGHT ARROW
			Case m.nKeyCode = 4 And m.nShiftAltCtrl = 0
				If This.ctlCalendarVisible = TRUE
					This.ctlValue = This.ctlValue + 1 * m.lnDelta
					If Empty(This.ctlValue) Then
						This.ctlValue =Date()
					Endif
					This.SelStart = m.lnSelStart
					This.SelLength = m.lnSelLength
					Nodefault
				Else
					If This.SelLength = Len(This.DisplayValue) Then
						This.SelStart = 0
						This.SelLength = 0
						Nodefault
					Endif
		
				Endif
		
				*!* NUMPAD +
			Case m.nKeyCode = 43 And m.nShiftAltCtrl = 0
				This.ctlValue = This.ctlValue + 1 * m.lnDelta
				If Empty(This.ctlValue) Then
					This.ctlValue = Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* NUMPAD -
			Case m.nKeyCode = 45 And m.nShiftAltCtrl = 0 And This.SelLength = Len(This.DisplayValue)
				This.ctlValue = This.ctlValue - 1 * m.lnDelta
				If Empty(This.ctlValue) Then
					This.ctlValue = Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* PAGE DOWN
			Case m.nKeyCode = 3 And m.nShiftAltCtrl = 0
				This.ctlValue = Gomonth(This.ctlValue, 1)
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* CTRL + PAGE DOWN
			Case m.nKeyCode = 30 And m.nShiftAltCtrl = 2
				This.ctlValue = Gomonth(This.ctlValue, 12)
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* PAGE UP
			Case m.nKeyCode = 18 And m.nShiftAltCtrl = 0
				This.ctlValue = Gomonth(This.ctlValue, -1)
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* CTRL + PAGE UP
			Case m.nKeyCode = 31 And m.nShiftAltCtrl = 2
				This.ctlValue = Gomonth(This.ctlValue, -12)
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* HOME
			Case m.nKeyCode = 1 And m.nShiftAltCtrl = 0
				This.ctlValue = This.ctlValue - Day(This.ctlValue) * m.lnDelta + 1 * m.lnDelta
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* CTRL + HOME
			Case m.nKeyCode = 29 And m.nShiftAltCtrl = 2
				This.ctlValue = Date()
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* END
			Case m.nKeyCode = 6 And m.nShiftAltCtrl = 0
				This.ctlValue = Gomonth(This.ctlValue, 1) - Day(This.ctlValue)
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
				Nodefault
		
				*!* MARK keys
			Case Between(m.nKeyCode, 32, 126) And Chr(m.nKeyCode) $ ".,/*-"
				If This._MarkKeyPressed = FALSE Then
					If Occurs(m.lcMark, This.DisplayValue) < 2 ;
							And Right(Alltrim(This.DisplayValue), 1) # m.lcMark Then
						This._MarkKeyPressed = TRUE
						Keyboard m.lcMark Plain
					Else
						??Chr(7)
					Endif
					Nodefault
				Else
					This._MarkKeyPressed = FALSE
				Endif
		
				*!* Reject rest
			Case Between(m.nKeyCode, 32, 126) And Not (Chr(m.nKeyCode) $ "0123456789")
				??Chr(7)
				Nodefault
		
			Otherwise
		Endcase
		
	ENDPROC

	PROCEDURE LostFocus
		*!* LostFocus()
		
		This.ctlCalendarVisible = FALSE
		This._Focused = FALSE
		This._ValiDate()
		
		
	ENDPROC

	PROCEDURE MouseUp
		*!* MouseUp()
		
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		*!* All this is here because the NODEFAULT in the GOTFOCUS prevents
		*!* the month calendar drop down to open when the control does not
		*!* have the focus and the user clicks in the dropdown arrow
		*!* the NODEFAULT in the GOTFOCUS is there so the text stays selected
		*!* on GOTFOCUS even if the control gets focus by a mouse click.
		
		If This._DropDown = TRUE Then
			This._DropDown = FALSE
			Return
		Endif
		
		If This.ReadOnly Then
			Return
		Endif
		
		Local m.lnx1, m.lnx2
		
		*!* Check if the mouse click is within the down arrow button
		m.lnx1 = Objtoclient(This, 2) + This.Width - Sysmetric(7) - This.Margin
		m.lnx2 = Objtoclient(This, 2) + This.Width
		
		If Between(m.nXCoord, m.lnx1, m.lnx2) Then
			This.ctlCalendarVisible = Not This.ctlCalendarVisible
		Endif
		
	ENDPROC

	PROCEDURE MouseWheel
		*!* MouseWheel()
		
		Lparameters nDirection, nShift, nXCoord, nYCoord
		
		If This.ctlFocused = FALSE Then
			Return
		Endif
		
		Local ;
			lcMark As String, ;
			lnMark1 As Integer, ;
			lnMark2 As Integer, ;
			lnSelStart As Integer, ;
			lnSelLength As Integer, ;
			lcSelected As String, ;
			m.lnDelta As Integer
		
		If Vartype(This.ctlValue) = T_DATETIME Then
			m.lnDelta = 1 * 60 * 60 * 24
		Else
			m.lnDelta = 1
		Endif
		
		
		*!* Get current date separator
		m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))
		
		*!* Get position of separators
		m.lnMark1 = At(m.lcMark, This.DisplayValue, 1)
		m.lnMark2 = At(m.lcMark, This.DisplayValue, 2)
		
		m.lnSelStart = This.SelStart
		m.lnSelLength = This.SelLength
		
		m.lcSelected = "D"
		
		*!* if the whole date is not selected, select the day, month or year
		*!* depending on where the cursor is located:
		If This.SelLength < Len(This.DisplayValue)
			Do Case
				Case This.SelStart < m.lnMark1
					This.SelStart = 0
					This.SelLength = m.lnMark1 - 1
					Do Case
						Case Set("Date", 1) = 0	&& MDY
							m.lcSelected = "M"
						Case Set("Date", 1) = 1	&& DMY
							m.lcSelected = "D"
						Case Set("Date", 1) = 2	&& YMD
							m.lcSelected = "Y"
					Endcase
		
				Case This.SelStart >= m.lnMark1 And This.SelStart < m.lnMark2
					This.SelStart = m.lnMark1
					This.SelLength = m.lnMark2 - m.lnMark1 - 1
					Do Case
						Case Set("Date", 1) = 0	&& MDY
							m.lcSelected = "D"
						Case Set("Date", 1) = 1	&& DMY
							m.lcSelected = "M"
						Case Set("Date", 1) = 2	&& YMD
							m.lcSelected = "M"
					Endcase
		
				Case This.SelStart >= m.lnMark2
					This.SelStart = m.lnMark2
					This.SelLength = Len(This.DisplayValue) - m.lnMark2
					Do Case
						Case Set("Date", 1) = 0	&& MDY
							m.lcSelected = "Y"
						Case Set("Date", 1) = 1	&& DMY
							m.lcSelected = "Y"
						Case Set("Date", 1) = 2	&& YMD
							m.lcSelected = "D"
					Endcase
		
			Endcase
		
			m.lnSelStart = This.SelStart
			m.lnSelLength = This.SelLength
		
		Endif
		
		Do Case
				*!* DOWN
			Case nDirection < 0
				Do Case
					Case m.lcSelected = "D"
						This.ctlValue = This.ctlValue - 1 * m.lnDelta
					Case m.lcSelected = "M"
						This.ctlValue = Gomonth(This.ctlValue, -1)
					Case m.lcSelected = "Y"
						This.ctlValue = Gomonth(This.ctlValue, -12)
				Endcase
		
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				Nodefault
		
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
		
				*!* UP
			Case  nDirection > 0
				Do Case
					Case m.lcSelected = "D"
						This.ctlValue = This.ctlValue + 1 * m.lnDelta
					Case m.lcSelected = "M"
						This.ctlValue = Gomonth(This.ctlValue, +1)
					Case m.lcSelected = "Y"
						This.ctlValue = Gomonth(This.ctlValue, +12)
				Endcase
		
				If Empty(This.ctlValue) Then
					This.ctlValue =Date()
				Endif
				Nodefault
		
				This.SelStart = m.lnSelStart
				This.SelLength = m.lnSelLength
		
		Endcase
		
	ENDPROC

	PROCEDURE Move
		*!* Move()
		
		Lparameters nLeft, nTop, nWidth, nHeight
		This.ctlCalendarVisible = FALSE
		
	ENDPROC

	PROCEDURE value_access
		*!* Value_Access()
		
		Return This.ctlValue
		
	ENDPROC

	PROCEDURE value_assign
		*!* Value_Assign()
		
		Lparameters tuNewValue
		This.ctlValue = m.tuNewValue
		
	ENDPROC

	PROCEDURE _addobjects
		*!* _AddObjects()
		
		Local ;
			lcCalendarName As String, ;
			lcTextBox As String
		
		m.lcTextBox = Sys(2015)
		Thisform.AddObject(m.lcTextBox, "TextBox")
		This._TextBox = Getpem(Thisform, m.lcTextBox)
		
		m.lcCalendarName = Sys(2015)
		Thisform.AddObject(m.lcCalendarName, "ctl32_monthcalendar")
		This.ctlCalendar = Getpem(Thisform, m.lcCalendarName)
		
		This.ctlCalendarVisible = FALSE
		
		With This.ctlCalendar
			.ctlFontName = "Tahoma"
			.ctlFontSize = 8
			.ctlCanFocus = FALSE
			.ctlMinDate = This.ctlMinDate
			.ctlMaxDate = This.ctlMaxDate
			If ctlGetOsVersion() < NTDDI_VISTA Then
				.ctlBorderWidth = 1
			Endif
		Endwith
		
	ENDPROC

	PROCEDURE _bindevents
		*!* _BindEvents()
		
		Bindevent(This.ctlCalendar, "DblClick", This, "_OnCalendarDblClick")
		Bindevent(This.ctlCalendar, "ctlValueChanged", This, "_OnCalendarctlValueChanged")
		Bindevent(Thisform, "Click", This, "_OnFormClick")
		
		Bindevent(This._TextBox, "Value", This, "_OnValue", 1)
		
	ENDPROC

	PROCEDURE _getbordercolor
		*!* _GetBorderColor()
		
		*!* Returns color to use for border
		Local ;
			m.lnTheme, ;
			m.lnColor
		
		m.lnColor = 0
		If ctlIsThemeActive(This.ctlCalendar) Then
			m.lnTheme = apiOpenThemeData(0, VSCLASS_EDIT)
			If m.lnTheme <> 0 Then
				apiGetThemeColor(m.lnTheme, EP_BACKGROUNDWITHBORDER, EBWBS_NORMAL, TMT_BORDERCOLOR, @m.lnColor)
				apiCloseThemeData(m.lnTheme)
			Endif
		Else
			m.lnColor = apiGetSysColor(COLOR_BTNSHADOW)
		Endif
		
		Return m.lnColor
		
	ENDPROC

	PROCEDURE _initlibrary
		*!* _InitLibrary()
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
	ENDPROC

	PROCEDURE _oncalendarctlvaluechanged
		*!* _OnCalendarctlValueChanged()
		
		If This._EnableUpdates = TRUE Then
			This.ctlValue = This.ctlCalendar.ctlValue
		Endif
		
		This._SelectAll()
		
	ENDPROC

	PROCEDURE _oncalendardblclick
		*!* _OnCalendarDblClick()
		
		This.ctlCalendarVisible = FALSE
		
		This.ctlValue = This.ctlCalendar.ctlValue
		
		This._SelectAll()
		
	ENDPROC

	PROCEDURE _onformclick
		*!* _OnFormClick()
		
		This.ctlCalendarVisible = FALSE
	ENDPROC

	PROCEDURE _onvalue
		*!* _OnValue()
		
		This.ctlValue = This._TextBox.Value
		
		
	ENDPROC

	PROCEDURE _selectall
		*!* _SelectAll()
		
		This.SelStart = 0
		This.SelLength = Len(This.DisplayValue)
		
	ENDPROC

	PROCEDURE _setcontrolsource
		*!* _SetControlSource()
		
		Local lcTextBox As String
		
		This._TextBox.ControlSource = This.ctlControlSource
		
		If Not Empty(This.ctlControlSource) Then
			This.ctlValue = This._TextBox.Value
		Endif
		
		
	ENDPROC

	PROCEDURE _setinputmask
		*!* _SetInputMask()
		
		Local ;
			m.lcYearMask As String, ;
			m.lcMask As String, ;
			m.lcMark As String
		
		If Set("Century") = "ON" Then
			m.lcYearMask = "9999"
		Else
			m.lcYearMask = "99"
		Endif
		
		m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))
		
		Do Case
			Case Set("Date",1) = 0	&& MDY
				m.lcMask = "99" + m.lcMark + "99" + m.lcMark + m.lcYearMask
			Case Set("Date",1) = 1	&& DMY
				m.lcMask = "99" + m.lcMark + "99" + m.lcMark + m.lcYearMask
			Case Set("Date",1) = 2	&& YMD
				m.lcMask =  m.lcYearMask + m.lcMark + "99" + m.lcMark + "99"
		Endcase
		
		This.InputMask = m.lcMask
		
	ENDPROC

	PROCEDURE _setvalue
		*!* _SetValue()
		
		If Not Empty(This.ctlControlSource) Then
			This._TextBox.Value = This.ctlValue
			Thisform.Refresh()
		Endif
		
		This.DisplayValue = Dtoc(This.ctlValue)
		
		This._EnableUpdates = FALSE
		
		If Empty(This.ctlValue) Then
			This.ctlCalendar.ctlValue = Date()
		Else
			This.ctlCalendar.ctlValue = This.ctlValue
		Endif
		
		This._EnableUpdates = TRUE
		
		Raiseevent(This, "ctlValueChanged")
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE _validate
		*!* _Validate()
		
		*!* Valid date ranges: 1753.01.01 to 9998.12.31
		
		Local ;
			lcValue As String, ;
			lcMark As String, ;
			lnYear As Integer, ;
			lnMonth As Integer, ;
			lnDay As Integer, ;
			llError As Logical, ;
			lnLastDayOfMonth As Integer
		
		m.lcValue = Alltrim(This.DisplayValue)
		m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))
		m.llError = FALSE
		
		If Not m.lcMark $ m.lcValue Then
		
			*!* if 2 digit value
			If Val(m.lcValue) < 100
				m.lnLastDayOfMonth = Day(Gomonth(Date(Year(Date()), Month(Date()), 1), 1) - 1)
				Do Case
						*!* If value is >= last day of month but <= 31, assume user wanted last
						*!* day of month
					Case Between(Val(m.lcValue), m.lnLastDayOfMonth, 31)
						m.lcValue = Str(m.lnLastDayOfMonth)
						*!* if value is > 31 assume 1 digit day and 1 digit month
					Case Val(m.lcValue) > 31
						m.lcValue = "0" + Left(m.lcValue, 1) + "0" + Right(m.lcValue, 1)
				Endcase
			Endif
		
			Do Case
		
					*!* 1 DIGIT: D
				Case Len(m.lcValue) = 1 And Set("Date", 1) = 0	&& mmdDyyyy
					m.lcValue = Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue + m.lcMark + Transform(Year(Date()), "@L 9999")
		
				Case Len(m.lcValue) = 1 And Set("Date", 1) = 1	&& dDmmyyyy
					m.lcValue = m.lcValue + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + Transform(Year(Date()), "@L 9999")
		
				Case Len(m.lcValue) = 1 And Set("Date", 1) = 2	&& yyyymmdD
					m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue
		
					*!* 2 DIGITS: DD
				Case Len(m.lcValue) = 2 And Set("Date", 1) = 0	&& mmDDyyyy
					m.lcValue = Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue + m.lcMark + Transform(Year(Date()), "@L 9999")
		
				Case Len(m.lcValue) = 2 And Set("Date", 1) = 1	&& DDmmyyyy
					m.lcValue = m.lcValue + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + Transform(Year(Date()), "@L 9999")
		
				Case Len(m.lcValue) = 2 And Set("Date", 1) = 2	&& yyyymmDD
					m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue
		
					*!* 3 DIGITS: DDM/DMM/MMD/MDD
					*!* there are 108 one digit days in a 365 days year: 30% one digit days
					*!* there are 9 one digit months in a 12 month year: 75% one digit months
					*!* so if we have a 3 digit date, let's assume the day is 2 digits and the month 1 digit,
					*!* except for special cases where we can safely assume there is a 2 digit month.
				Case Len(m.lcValue) = 3 And Set("Date", 1) = 0	&& MMdDyyyy or mMDDyyyyy
					If m.lcValue $ "101|102|103|104|105|106|107|108|109"
						m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 1) + m.lcMark + Transform(Year(Date()), "@L 9999")
					Else
						m.lcValue = Left(m.lcValue, 1) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")
					Endif
		
				Case Len(m.lcValue) = 3 And Set("Date", 1) = 1	&& DDmMyyyy or dDMMyyyy
					If m.lcValue $ "110|210|310|312|410|411|412|510|511|512|610|611|612|710|711|712|810|811|812|910|911|912"
						m.lcValue = Left(m.lcValue, 1) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")
					Else
						m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 1) + m.lcMark + Transform(Year(Date()), "@L 9999")
					Endif
		
				Case Len(m.lcValue) = 3 And Set("Date", 1) = 2	&& yyyyMMdD or yyyymMDD
					If m.lcValue $ "101|102|103|104|105|106|107|108|109"
						m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 1)
					Else
						m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Left(m.lcValue, 1) + m.lcMark + Right(m.lcValue, 2)
					Endif
		
					*!* 4 DIGITS: DDMM/MMDD
				Case Len(m.lcValue) = 4 And Set("Date", 1) = 0	&& MMDDyyyy
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")
		
				Case Len(m.lcValue) = 4 And Set("Date", 1) = 1	&& DDMMyyyy
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")
		
				Case Len(m.lcValue) = 4 And Set("Date", 1) = 2	&& yyyyMMDD
					m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 2)
		
					*!* 5 DIGITS: DDMMY/MMDDY/YMMDD
				Case Len(m.lcValue) = 5 And Set("Date", 1) = 0	&& MMDDyyyY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 1)
		
				Case Len(m.lcValue) = 5 And Set("Date", 1) = 1	&& DDMMyyyY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 1)
		
				Case Len(m.lcValue) = 5 And Set("Date", 1) = 2	&& yyyYMMDD
					m.lcValue = Left(m.lcValue, 1) + m.lcMark + Substr(m.lcValue, 2, 2) + m.lcMark + Right(m.lcValue, 2)
		
					*!* 6 DIGITS: DDMMYY/MMDDYY/YYMMDD
				Case Len(m.lcValue) = 6 And Set("Date", 1) = 0	&& MMDDyyYY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 2)
		
				Case Len(m.lcValue) = 6 And Set("Date", 1) = 1	&& DDMMyyYY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 2)
		
				Case Len(m.lcValue) = 6 And Set("Date", 1) = 2	&& yyYYMMDD
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 2)
		
					*!* 7 DIGITS: DDMMYYY/MMDDYYY/YYYMMDD
				Case Len(m.lcValue) = 7 And Set("Date", 1) = 0	&& MMDDyyYY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 3)
		
				Case Len(m.lcValue) = 7 And Set("Date", 1) = 1	&& DDMMyyYY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 3)
		
				Case Len(m.lcValue) = 7 And Set("Date", 1) = 2	&& yyYYMMDD
					m.lcValue = Left(m.lcValue, 3) + m.lcMark + Substr(m.lcValue, 4, 2) + m.lcMark + Right(m.lcValue, 2)
		
					*!* 8 DIGITS: DDMMYYYY/MMDDYYYY/YYYYMMDD
				Case Len(m.lcValue) = 8 And Set("Date", 1) = 0	&& MMDDYYYY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 4)
		
				Case Len(m.lcValue) = 8 And Set("Date", 1) = 1	&& DDMMYYYY
					m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 4)
		
				Case Len(m.lcValue) = 8 And Set("Date", 1) = 2	&& YYYYMMDD
					m.lcValue = Left(m.lcValue, 4) + m.lcMark + Substr(m.lcValue, 5, 2) + m.lcMark + Right(m.lcValue, 2)
		
			Endcase
		Endif
		
		Do Case
			Case Set("Date", 1) = 0	&& MDY
				*!* Extract month, day, year
				m.lnMonth 	= Val(Getwordnum(m.lcValue, 1, m.lcMark))
				m.lnDay 	= Val(Getwordnum(m.lcValue, 2, m.lcMark))
				m.lnYear 	= Val(Getwordnum(m.lcValue, 3, m.lcMark))
			Case Set("Date", 1) = 1	&& DMY
				*!* Extract day, month, year
				m.lnDay 	= Val(Getwordnum(m.lcValue, 1, m.lcMark))
				m.lnMonth 	= Val(Getwordnum(m.lcValue, 2, m.lcMark))
				m.lnYear 	= Val(Getwordnum(m.lcValue, 3, m.lcMark))
			Case Set("Date", 1) = 2	&& YMD
				*!* Extract year, month, day
				m.lnYear 	= Val(Getwordnum(m.lcValue, 1, m.lcMark))
				m.lnMonth 	= Val(Getwordnum(m.lcValue, 2, m.lcMark))
				m.lnDay 	= Val(Getwordnum(m.lcValue, 3, m.lcMark))
		Endcase
		
		*!* Add missing values
		If m.lnMonth + m.lnDay + m.lnYear > 0 Then
			If m.lnMonth = 0 Then
				m.lnMonth = Month(Date())
			Endif
			If m.lnYear = 0 Then
				m.lnYear = Year(Date())
			Endif
		Endif
		
		*!* If year is less than 99, add century using ROLLOVER
		If Between(m.lnYear, 1, 99) Then
			If m.lnYear >= Set("Century", 2) Then
				m.lnYear = m.lnYear + Set("Century", 1) * 100
			Else
				m.lnYear = m.lnYear + (Set("Century", 1) + 1) * 100
			Endif
		Endif
		
		If m.lnYear # 0 Then
			*!* Check year is between 1753, 9998 (gregorian calendar limits)
			If m.lnYear < 1753 Then
				m.llError = TRUE
				m.lnYear = 1753
			Endif
			If m.lnYear > 9998 Then
				m.llError = TRUE
				m.lnYear = 9998
			Endif
		Endif
		
		If m.lnMonth # 0 Then
			*!* Check month is between 1, 12
			If m.lnMonth < 1 Then
				m.llError = TRUE
				m.lnMonth = 1
			Endif
			If m.lnMonth > 12 Then
				m.llError = TRUE
				m.lnMonth = 12
			Endif
		Endif
		
		If m.lnDay # 0 Then
			*!* Check day is between 1, 31
			If m.lnDay < 1 Then
				m.llError = TRUE
				m.lnDay = 1
			Endif
			If m.lnDay > 31 Then
				m.llError = TRUE
				m.lnDay = 31
			Endif
		
			*!* Check day is not > than last day of entered month
			*!* GOMONTH() does not support dates earlier than 1753.
			If m.lnYear # 0 And m.lnMonth # 0 Then
				If m.lnDay > Day(Gomonth(Date(m.lnYear, m.lnMonth, 1), 1) - 1) Then
					m.llError = TRUE
					m.lnDay = Day(Gomonth(Date(m.lnYear, m.lnMonth, 1), 1) - 1)
				Endif
			Endif
		Endif
		
		If m.lnYear # 0 And m.lnMonth # 0 And m.lnDay # 0 Then
			This.ctlValue = Date(m.lnYear, m.lnMonth, m.lnDay)
		Else
			This.ctlValue = {}
		Endif
		
		If m.llError Then
			??Chr(7)
		Endif
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_filedialog AS ctl32_commondialog OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctladdextension_assign
		*m: ctlautoupgradeenabled_assign
		*m: ctlcheckfileexists_assign
		*m: ctlcheckpathexists_assign
		*m: ctldereferencelinks_assign
		*m: ctlfileok		&& Occurs when the user clicks on the Open or Save button on a file dialog box.
		*m: ctlgetdefaultfilter
		*m: ctlinitialview_assign
		*m: ctlonfileok		&& Raises the FileOk event.
		*m: ctloptions_access
		*m: ctlrestorefolder_assign
		*m: ctlshowhelp_assign
		*m: ctlshowplacesbar_assign
		*m: ctlsupportmultidottedextensions_assign
		*m: ctlvalidatenames_assign
		*m: _getflags
		*m: _getresults
		*m: _setupopenfilename
		*p: ctladdextension		&& Gets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension.
		*p: ctladdtorecentdocuments		&& Specifies if the selected file should be added to the Recent Documents menu item.
		*p: ctlautoupgradeenabled		&& Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista.
		*p: ctlcancelcaption		&& Gets or sets the Cancel button caption.
		*p: ctlcheckfileexists		&& Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist.
		*p: ctlcheckpathexists		&& Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist.
		*p: ctlcustomplaces		&& Gets the custom places collection for this FileDialog instance.
		*p: ctldefaultext		&& Gets or sets the default file name extension.
		*p: ctldereferencelinks		&& Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk).
		*p: ctlfilecount		&& Gets the number of files selected.
		*p: ctlfilename		&& Gets a string containing the file name selected in the file dialog box.
		*p: ctlfilter		&& Gets or sets the current file name filter string, which determines the choices that appear in the "Save as file type" or "Files of type" box in the dialog box.
		*p: ctlfilterindex		&& Gets or sets the index of the filter currently selected in the file dialog box.
		*p: ctlfolder		&& Gets the selected file folder.
		*p: ctlhelpcaption		&& Gets or sets the Help button caption.
		*p: ctlinitialfilename		&& Gets or sets the initial file name displayed by the file dialog box.
		*p: ctlinitialfolder		&& Gets or sets the initial folder displayed by the file dialog box.
		*p: ctlinitialview		&& Specifies the initial view of the file pane.
		*p: ctlokcaption		&& Gets or sets the OK button caption.
		*p: ctloptions		&& Infrastructure.  Gets values to initialize the FileDialog.
		*p: ctlrestorefolder		&& Gets or sets a value indicating whether the dialog box restores the current directory before closing.
		*p: ctlsafefilename		&& Gets the file name and extension of the first selected file in the dialog box. The file name does not include the path.
		*p: ctlshowhelp		&& Gets or sets a value indicating whether the Help button is displayed in the file dialog box.
		*p: ctlshowhiddenfiles		&& Specifies is hidden files are shown.
		*p: ctlshowplacesbar		&& Gets or sets a value indicating whether the Places Bar is displayed in the file dialog box.
		*p: ctlsupportmultidottedextensions		&& Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions.
		*p: ctlvalidatenames		&& Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names.
		*a: ctlfilenames[1,1]		&& Gets the file names of all selected files in the dialog box.
		*a: ctlsafefilenames[1,1]		&& Gets an array of file names and extensions for all the selected files in the dialog box. The file names do not include the path.
		*p: _currentfolder		&& Stores the current directory before the dialog is shown.
		*p: _dialogtype		&& "O" for open, "S" for save.
		*p: _filesspec
		*p: _folderpath
		*p: _initialviewvalue
		*p: _lastfolder
		*p: _listviewhwnd		&& Saves the listview hwnd.
		*p: _openfilename		&& OPENFILENAME structure
	*</DefinedPropArrayMethod>

	ctladdextension = .T.		&& Gets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension.
	ctladdtorecentdocuments = .T.		&& Specifies if the selected file should be added to the Recent Documents menu item.
	ctlautoupgradeenabled = .T.		&& Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista.
	ctlcancelcaption = 		&& Gets or sets the Cancel button caption.
	ctlcheckfileexists = .T.		&& Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist.
	ctlcheckpathexists = .T.		&& Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist.
	ctlcustomplaces = 		&& Gets the custom places collection for this FileDialog instance.
	ctldefaultext = 		&& Gets or sets the default file name extension.
	ctldereferencelinks = .T.		&& Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk).
	ctlfilecount = 0		&& Gets the number of files selected.
	ctlfilename = 		&& Gets a string containing the file name selected in the file dialog box.
	ctlfilter = 		&& Gets or sets the current file name filter string, which determines the choices that appear in the "Save as file type" or "Files of type" box in the dialog box.
	ctlfilterindex = 1		&& Gets or sets the index of the filter currently selected in the file dialog box.
	ctlfolder = 		&& Gets the selected file folder.
	ctlhelpcaption = 		&& Gets or sets the Help button caption.
	ctlinitialfilename = 		&& Gets or sets the initial file name displayed by the file dialog box.
	ctlinitialfolder = 		&& Gets or sets the initial folder displayed by the file dialog box.
	ctlinitialview = 0		&& Specifies the initial view of the file pane.
	ctlokcaption = 		&& Gets or sets the OK button caption.
	ctloptions = 0		&& Infrastructure.  Gets values to initialize the FileDialog.
	ctlrestorefolder = .F.		&& Gets or sets a value indicating whether the dialog box restores the current directory before closing.
	ctlsafefilename = 		&& Gets the file name and extension of the first selected file in the dialog box. The file name does not include the path.
	ctlshowhelp = .F.		&& Gets or sets a value indicating whether the Help button is displayed in the file dialog box.
	ctlshowhiddenfiles = .F.		&& Specifies is hidden files are shown.
	ctlshowplacesbar = .T.		&& Gets or sets a value indicating whether the Places Bar is displayed in the file dialog box.
	ctlsupportmultidottedextensions = .F.		&& Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions.
	ctlvalidatenames = .T.		&& Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names.
	Name = "ctl32_filedialog"
	_currentfolder = 		&& Stores the current directory before the dialog is shown.
	_dialogtype = 		&& "O" for open, "S" for save.
	_filesspec = 
	_folderpath = 
	_initialviewvalue = 0
	_lastfolder = 
	_listviewhwnd = 0		&& Saves the listview hwnd.
	_openfilename = 		&& OPENFILENAME structure
	lblname.Caption = "ctl32_filedialog"
	lblname.Name = "lblname"
	
	PROCEDURE ctladdextension_assign
		*!* ctlAddExtension(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlAddExtension = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlautoupgradeenabled_assign
		*!* ctlAutoUpgradeEnabled(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlAutoUpgradeEnabled = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlcheckfileexists_assign
		*!* ctlCheckFileExists(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlCheckFileExists = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlcheckpathexists_assign
		*!* ctlCheckPathExists(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlCheckPathExists = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctldereferencelinks_assign
		*!* ctlDereferenceLinks(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlDereferenceLinks = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlfileok		&& Occurs when the user clicks on the Open or Save button on a file dialog box.
	ENDPROC

	PROCEDURE ctlgetdefaultfilter
		*!* ctlGetDefaultFilter()
		
		Local lcFilter As String
		
		m.lcFilter = ctlGetStringResource("shell32.dll", 9021)
		m.lcFilter = Getwordnum(m.lcFilter, 1, "#") + " (*.*)|*.*"
		
		Return m.lcFilter
		
	ENDPROC

	PROCEDURE ctlhookproc
		*!* ctlHookProc
		
		Lparameters hdlg As Integer, uiMsg As Integer, wParam As Integer, Lparam As Integer
		
		*!*	    hdlg
		*!*	        [in] Handle to the child dialog box of the Open or Save As dialog box.
		*!*			Use the GetParent function to get the handle to the Open or Save As dialog box.
		*!*	    uiMsg
		*!*	        [in] Identifies the message being received.
		*!*	    wParam
		*!*	        [in] Specifies additional information about the message. The exact meaning
		*!*			depends on the value of the uiMsg parameter.
		*!*	    lParam
		*!*	        [in] Specifies additional information about the message. The exact meaning
		*!*			depends on the value of the uiMsg parameter. If the uiMsg parameter indicates
		*!*			the WM_INITDIALOG message, lParam is a pointer to an OPENFILENAME structure
		*!*			containing the values specified when the dialog box was created.
		
		?hdlg , uiMsg , wParam , Lparam
		
		Local ;
			lcFolderPath As String, ;
			lnFolderLen As Integer, ;
			lcFilesSpec As String, ;
			lnFilesLen As Integer, ;
			loNMHdr As _NMHDR, ;
			lnCode As Integer, ;
			lnHwnd As Integer
		
		Do Case
		
			Case m.uiMsg = 49265
		
				*!* The user opened a new folder
				m.lcFolderPath = Replicate(NULA, 2048)
				m.lnFolderLen = apiSendMessageString(apiGetParent(m.hdlg), CDM_GETFOLDERPATH, Len(m.lcFolderPath), @m.lcFolderPath)
				m.lcFolderPath = Left(m.lcFolderPath, m.lnFolderLen - 1)
				This._FolderPath = m.lcFolderPath
		
				*!* The user selected a new file or folder from the file list.
				*!* Try first with a null buffer, get needed buffer length, the try with correct buffer len
				m.lcFilesSpec = ""
				m.lnFilesLen = apiSendMessageString(apiGetParent(m.hdlg), CDM_GETSPEC, Len(m.lcFilesSpec), @m.lcFilesSpec)
				m.lcFilesSpec = Replicate(NULA, m.lnFilesLen)
				m.lnFilesLen = apiSendMessageString(apiGetParent(m.hdlg), CDM_GETSPEC, Len(m.lcFilesSpec), @m.lcFilesSpec)
				m.lcFilesSpec = Left(m.lcFilesSpec, m.lnFilesLen - 1)
		
				This._FilesSpec = m.lcFilesSpec
		
		
			Case m.uiMsg = WM_NOTIFY
		
				*!* Get NMHDR structure from pointer
				m.loNMHdr = Createobject("_NMHDR", m.Lparam)
				m.lnCode = m.loNMHdr.Code
				m.loNMHdr = .Null.
				Release m.loNMHdr
		
				Do Case	&& WM_NOTIFY/m.lnCode
		
					*!* Case m.lnCode = CDN_FILEOK
						*?"CDN_FILEOK", m.lnCode
		
					*!* Case m.lnCode = CDN_FOLDERCHANGE Or m.lnCode = CDN_SELCHANGE
						*?"CDN_FOLDERCHANGE|CDN_SELCHANGE", m.lnCode
		
					Case m.lnCode = CDN_HELP
						*?"CDN_HELP", m.lnCode
						Raiseevent(This, "ctlHelpRequest")
		
					*!* Case m.lnCode = CDN_INCLUDEITEM
						*?"CDN_INCLUDEITEM", m.lnCode
		
					Case m.lnCode = CDN_INITDONE
						*?"CDN_INITDONE", m.lnCode
						*!* This event happens only once in the dialog life,
						*!* but the listview does not yet exist here
						*!* Here we set _ListViewHwnd to 0, so later the listview initial view is set
						This._ListViewHwnd = 0
		
						*!* Reset properties:
						This._FolderPath = ""
						This._FilesSpec = ""
		
					*!* Case m.lnCode = CDN_SHAREVIOLATION
						*?"CDN_SHAREVIOLATION", m.lnCode
		
					*!* Case m.lnCode = CDN_TYPECHANGE
						*?"CDN_TYPECHANGE", m.lnCode
		
					Otherwise
						*?"WM_NOTIFY OTHER", m.lnCode
		
				Endcase
		
			Case m.uiMsg = WM_INITDIALOG
				*?"WM_INITDIALOG", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				If Not Empty(This.ctlOkCaption) Then
					apiSendMessageString(apiGetParent(m.hdlg), CDM_SETCONTROLTEXT, IDOK, This.ctlOkCaption)
				Endif
		
				If Not Empty(This.ctlCancelCaption) Then
					apiSendMessageString(apiGetParent(m.hdlg), CDM_SETCONTROLTEXT, IDCANCEL, This.ctlCancelCaption)
				Endif
		
				If Not Empty(This.ctlHelpCaption) Then
					apiSendMessageString(apiGetParent(m.hdlg), CDM_SETCONTROLTEXT, pshHelp, This.ctlHelpCaption)
				Endif
		
				*!*		Case m.uiMsg = WM_CTLCOLORDLG
				*!*			*?"WM_CTLCOLORDLG", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_SETFONT
				*!*			*?"WM_SETFONT", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_SHOWWINDOW
				*!*			*?"WM_SHOWWINDOW", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_SETREDRAW
				*!*			*?"WM_SETREDRAW", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_WINDOWPOSCHANGING
				*!*			*?"WM_WINDOWPOSCHANGING", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_WINDOWPOSCHANGED
				*!*			*?"WM_WINDOWPOSCHANGED", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_SIZE
				*!*			*?"WM_SIZE", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_NCCALCSIZE
				*!*			*?"WM_NCCALCSIZE", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_CHILDACTIVATE
				*!*			*?"WM_CHILDACTIVATE", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_DESTROY
				*!*			*?"WM_DESTROY", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_NCDESTROY
				*!*			*?"WM_NCDESTROY", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_CANCELMODE
				*!*			*?"WM_CANCELMODE", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Case m.uiMsg = WM_ENABLE
				*!*			*?"WM_ENABLE", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
				*!*		Otherwise
				*!*			*?"OTHER", m.hdlg, m.uiMsg, m.wParam, m.Lparam
		
		Endcase
		
		*!* here we set the listview initial view mode
		*!* we test each time if the listview is there yet
		If This.ctlInitialView # 0 And This._ListViewHwnd = 0
			m.lnHwnd = apiFindWindowEx(apiGetParent(m.hdlg), 0, "SHELLDLL_DefView", "")
			If m.lnHwnd # 0 Then
				apiSendMessageInteger(m.lnHwnd, WM_COMMAND, This._InitialViewValue, 0)
				This._ListViewHwnd = m.lnHwnd
			Endif
		Endif
		
		Return 0
		
		*!*	Control identifier	Control description
		*!*	chx1	The read-only check box
		*!*	cmb1	Drop-down combo box that displays the list of file type filters
		*!*	stc2	Label for the cmb1 combo box
		*!*	cmb2	Drop-down combo box that displays the current drive or folder, and that allows the user to select a drive or folder to open
		*!*	stc4	Label for the cmb2 combo box
		*!*	cmb13	Drop-down combo box that displays the name of the current file, allows the user to type the name of a file to open, and select a file that has been opened or saved recently. This is for earlier Explorer-compatible applications without hook or dialog template. Compare with edt1.
		*!*	edt1	Edit control that displays the name of the current file, or allows the user to type the name of the file to open. Compare with cmb13.
		*!*	stc3	Label for the cmb13 combo box and the edt1 edit control
		*!*	lst1	List box that displays the contents of the current drive or folder
		*!*	stc1	Label for the lst1 list box
		*!*	IDOK	The OK command button (push button)
		*!*	IDCANCEL	The Cancel command button (push button)
		*!*	pshHelp	The Help command button (push button)
		
	ENDPROC

	PROCEDURE ctlinitialview_assign
		*!*	#Define SHVIEW_THUMBNAIL 	0x702D	&& 1	THUMBNAILS
		*!*	#Define SHVIEW_TILE 		0x702E	&& 2	TILES
		*!*	#Define SHVIEW_ICON 		0x7029	&& 3	ICONS
		*!*	#Define SHVIEW_LIST 		0x702B	&& 4	LIST
		*!*	#Define SHVIEW_REPORT 		0x702C	&& 5	DETAILS
		
		
		Lparameters tuNewValue
		
		m.tuNewValue = Min(5, Max(0, m.tuNewValue))
		
		This.ctlInitialView = m.tuNewValue
		
		Do Case
			Case m.tuNewValue = 0
				This._InitialViewValue = 0
			Case m.tuNewValue = 1
				This._InitialViewValue = SHVIEW_THUMBNAIL
			Case m.tuNewValue = 2
				This._InitialViewValue = SHVIEW_TILE
			Case m.tuNewValue = 3
				This._InitialViewValue = SHVIEW_ICON
			Case m.tuNewValue = 4
				This._InitialViewValue = SHVIEW_LIST
			Case m.tuNewValue = 5
				This._InitialViewValue = SHVIEW_REPORT
		Endcase
		
		
	ENDPROC

	PROCEDURE ctlonfileok		&& Raises the FileOk event.
	ENDPROC

	PROCEDURE ctlonhelprequest
		*!* ctlOnHelpRequest()
		
		Raiseevent(This, "ctlHelpRequest")
		
	ENDPROC

	PROCEDURE ctloptions_access
		*!* _ctlOptions_Access()
		
		Return This._GetFlags()
		
	ENDPROC

	PROCEDURE ctlreset
		*!* ctlReset()
		
		This._ResetProperties()
		
	ENDPROC

	PROCEDURE ctlrestorefolder_assign
		lparameters tuNewValue
		This.ctlrestorefolder = tuNewValue
		
	ENDPROC

	PROCEDURE ctlshowdialog
		*!* ctlShowDialog(Hwnd)
		
		Lparameters pnHwnd As Integer
		
		Local lnResult As Integer
		
		*!* Store the current Folder:
		This._CurrentFolder = Set("DEFAULT") + Sys(2003)
		
		This._SetupOpenFileName(m.pnHwnd)
		
		*!* Here Dialog gets displayed:
		********************************************************************************
		Do Case
			Case This._DialogType = "OPEN"
				m.lnResult = apiGetOpenFileName(This._OpenFileName.Address)
			Case This._DialogType = "SAVE"
				m.lnResult = apiGetSaveFileName(This._OpenFileName.Address)
		Endcase
		********************************************************************************
		
		If This._DialogType = "OPEN" Then
			This.ctlReadOnlyChecked = (Bitand(This._OpenFileName.Flags, OFN_READONLY) = OFN_READONLY)
		Endif
		
		*!* Restore current Folder
		If This.ctlRestoreFolder = TRUE Then
			Set Default To (This._CurrentFolder)
		Endif
		
		This._GetResults()
		
		If This.ctlFileCount > 0 Then
			Raiseevent(This, "ctlFileOK")
		Endif
		
		Return This.ctlFileCount
		
	ENDPROC

	PROCEDURE ctlshowhelp_assign
		*!* ctlShowHelp(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlShowHelp = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlshowplacesbar_assign
		*!* ctlShowPlacesBar(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlShowPlacesBar = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlsupportmultidottedextensions_assign
		*!* ctlSupportMultiDottedExtensions(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlSupportMultiDottedExtensions = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlvalidatenames_assign
		*!* ctlValidateNames(lValue)
		
		Lparameters tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		This.ctlValidateNames = m.tuNewValue
		
	ENDPROC

	PROCEDURE Destroy
		*!* _Destroy()
		
		This._DestroyCallback()
	ENDPROC

	PROCEDURE Init
		DoDefault()
		
		This._CreateCallback()
		
	ENDPROC

	PROCEDURE _getflags
		*!* _GetFlags()
		
		Local lnFlags As Integer
		
		m.lnFlags = 0
		
		*!* OFN_ALLOWMULTISELECT
		*!* When ctlMultiselect is ON, OFN_FILEMUSTEXIST will be OFF.
		*!* Also, links are not resolved.
		
		If This._DialogType = "OPEN" And This.ctlMultiselect = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_ALLOWMULTISELECT)
		Endif
		
		*!* OFN_CREATEPROMPT
		If This._DialogType = "SAVE" And This.ctlCreatePrompt = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_CREATEPROMPT)
		Endif
		
		*!* OFN_DONTADDTORECENT
		If This.ctlAddToRecentDocuments = FALSE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_DONTADDTORECENT)
		Endif
		
		*!* OFN_ENABLEHOOK
		If ctlGetOsVersion() < NTDDI_VISTA Or This.ctlAutoUpgradeEnabled = FALSE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_ENABLEHOOK)
		Endif
		
		*!* OFN_ENABLEINCLUDENOTIFY
		*!* m.lnFlags = Bitor(m.lnFlags, OFN_ENABLEINCLUDENOTIFY)
		
		*!* OFN_ENABLESIZING
		m.lnFlags = Bitor(m.lnFlags, OFN_ENABLESIZING)
		
		*!* OFN_ENABLETEMPLATE
		
		*!* OFN_ENABLETEMPLATEHANDLE
		
		*!* OFN_EXPLORER
		m.lnFlags = Bitor(m.lnFlags, OFN_EXPLORER)
		
		*!* OFN_EXTENSIONDIFFERENT
		
		*!* OFN_FILEMUSTEXIST
		*!* When ctlMultiselect is on, we do not check if files exist.
		If This._DialogType = "OPEN" And This.ctlCheckFileExists = TRUE And This.ctlMultiselect = FALSE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_FILEMUSTEXIST)
		Endif
		
		*!* OFN_FORCESHOWHIDDEN
		If This.ctlShowHiddenFiles = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_FORCESHOWHIDDEN)
		Endif
		
		*!* OFN_HIDEREADONLY
		If This._DialogType = "SAVE" Or This.ctlShowReadOnly = FALSE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_HIDEREADONLY)
		Endif
		
		*!* OFN_LONGNAMES
		
		*!* OFN_NOCHANGEDIR (This flag is ineffective for GetOpenFileName.)
		If This.ctlRestoreFolder = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_NOCHANGEDIR)
		Endif
		
		*!* OFN_NODEREFERENCELINKS
		If This.ctlDereferenceLinks = FALSE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_NODEREFERENCELINKS)
		Endif
		
		*!* OFN_NOLONGNAMES
		
		*!* OFN_NONETWORKBUTTON
		
		*!* OFN_NOREADONLYRETURN
		
		*!* OFN_NOTESTFILECREATE
		m.lnFlags = Bitor(m.lnFlags, OFN_NOTESTFILECREATE)
		
		*!* OFN_NOVALIDATE
		If This.ctlValidateNames = FALSE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_NOVALIDATE)
		Endif
		
		*!* OFN_OVERWRITEPROMPT
		If This._DialogType = "SAVE" And This.ctlOverWritePrompt = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_OVERWRITEPROMPT)
		Endif
		
		*!* OFN_PATHMUSTEXIST
		If This.ctlCheckPathExists = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_PATHMUSTEXIST)
		Endif
		
		*!* OFN_READONLY
		If This._DialogType = "OPEN" And This.ctlReadOnlyChecked = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, OFN_READONLY)
		Endif
		
		*!* OFN_SHAREAWARE
		m.lnFlags = Bitor(m.lnFlags, OFN_SHAREAWARE)
		
		*!* OFN_SHOWHELP
		If This.ctlShowHelp = TRUE
			If ctlGetOsVersion() < NTDDI_VISTA Or This.ctlAutoUpgradeEnabled = FALSE Then
				m.lnFlags = Bitor(m.lnFlags, OFN_SHOWHELP)
			Endif
		Endif
		
		*!* OFN_USESHELLITEM (Do not use)
		
		Return m.lnFlags
		
	ENDPROC

	PROCEDURE _getresults
		*!* _GetResults()
		
		*!* XP only returns about 32K of files no matter how big we make the buffer
		*!* Vista returns all the files.
		
		Local lcFilesSpec, lcFolderPath, lnx As Integer
		
		m.lcFilesSpec = This._OpenFileName.GetlpstrFile()
		m.lcFilesSpec = Left(m.lcFilesSpec, At(NULW, m.lcFilesSpec)-1)
		m.lcFilesSpec = Chrtran(m.lcFilesSpec, NULA, "|")
		
		*!* lpstrFile may contain embedded nuls if it has more than one file
		*!* ReadPCString only reads up to the first nul, so we use a function
		*!* to read the string
		
		If At("|", m.lcFilesSpec) # 0 Then
		
			If ctlGetOsVersion() >= NTDDI_VISTA Then
				m.lcFolderPath = Getwordnum(m.lcFilesSpec, 1, "|")
				m.lcFilesSpec = Right(m.lcFilesSpec, Len(m.lcFilesSpec) - Len(m.lcFolderPath))
			Else
				m.lcFilesSpec = Strtran(This._FilesSpec, '" "', "|")
				m.lcFilesSpec = Chrtran(m.lcFilesSpec, '"', '')
				m.lcFolderPath = This._FolderPath
			Endif
		
		Else
			m.lcFolderPath = Justpath(m.lcFilesSpec)
			m.lcFilesSpec = Justfname(m.lcFilesSpec)
		Endif
		
		This.ctlFolder = m.lcFolderPath
		This._LastFolder = m.lcFolderPath
		
		This.ctlFileCount = Getwordcount(m.lcFilesSpec, "|")
		
		Dimension This.ctlSafeFileNames(Max(1,This.ctlFileCount))
		Dimension This.ctlFileNames(Max(1,This.ctlFileCount))
		
		This.ctlSafeFileNames(1) = ""
		This.ctlFileNames(1) = ""
		
		For m.lnx = 1 To This.ctlFileCount
			This.ctlSafeFileNames(m.lnx) = Getwordnum(m.lcFilesSpec, m.lnx, "|")
			This.ctlFileNames(m.lnx) = Addbs(m.lcFolderPath) + This.ctlSafeFileNames(m.lnx)
		Endfor
		
		Asort(This.ctlSafeFileNames)
		Asort(This.ctlFileNames)
		
		This.ctlSafeFileName = This.ctlSafeFileNames(1)
		This.ctlFilename = This.ctlFileNames(1)
		
		
		
		
	ENDPROC

	PROCEDURE _setproperties
		*!* _SetProperties()
		
		DoDefault()
		
		This._OpenFileName = Newobject("_OPENFILENAME")
		
		
	ENDPROC

	PROCEDURE _setupopenfilename
		*!* _SetupOpenFileName()
		
		Lparameters pnHwnd
		
		Local lnBufferLen As Integer, lcFilter As String
		
		With This._OpenFileName As _OpenFileName
		
			*!*** HWND hwndOwner
			Do Case
				Case Vartype(m.pnHwnd) = "N" And m.pnHwnd > 0
					.hwndOwner = m.pnHwnd
		
				Case Type("_Screen.Activeform") = "O"
					.hwndOwner = _Screen.ActiveForm.HWnd
		
				Otherwise
					.hwndOwner = _vfp.HWnd
			Endcase
		
			*!*** HINSTANCE hInstance
			.hInstance = 0
		
			*!*** LPCTSTR lpstrFilter
			If Empty(This.ctlFilter) Then
				m.lcFilter = This.ctlGetDefaultFilter()
			Else
				m.lcFilter = Alltrim(Transform(This.ctlFilter))
			Endif
		
			If Right(m.lcFilter, 1) # "|" Then
				m.lcFilter = m.lcFilter + "|"
			Endif
		
			*!* Change | to chr(0), add double nul at end
			m.lcFilter = Chrtran(m.lcFilter, "|", NULA) + NULA
		
			.lpstrFilter = m.lcFilter
		
			*!*** LPTSTR lpstrCustomFilter
			*!*** DWORD nMaxCustFilter
		
			*!*** DWORD nFilterIndex
			.nFilterIndex = This.ctlFilterIndex
		
			*!*** LPTSTR lpstrFile
			If This._DialogType = "OPEN" And This.ctlMultiselect = TRUE Then
				m.lnBufferLen = 512 * 1024
			Else
				m.lnBufferLen = MAX_PATH
			Endif
		
			m.lnBufferLen = m.lnBufferLen - Len(Transform(This.ctlInitialFileName))
		
			.lpstrFile = Transform(This.ctlInitialFileName) + Replicate(NULA, m.lnBufferLen)
		
			*!*** DWORD nMaxFile
		
			*!*** LPTSTR lpstrFileTitle
			.lpstrFileTitle = Replicate(NULA, MAX_PATH)
		
			*!*** DWORD nMaxFileTitle
		
			*!*** LPCTSTR lpstrInitialDir
			If Not Empty(This.ctlInitialFolder) Then
				.lpstrInitialDir = Transform(This.ctlInitialFolder) + NULA
			Else
				.lpstrInitialDir = Transform(This._LastFolder) + NULA
			Endif
		
			If This.ctlRestoreFolder = TRUE
				.lpstrInitialDir = This._CurrentFolder + NULA
			Endif
		
			*!*** LPCTSTR lpstrTitle
			.lpstrTitle = Rtrim(Transform(This.ctlTitle)) + NULA
		
			*!*** DWORD Flags
			.Flags = This._GetFlags()
		
			*!*** WORD nFileOffset
		
			*!*** WORD nFileExtension
		
			*!*** LPCTSTR lpstrDefExt
			.lpstrDefExt = Alltrim(Transform(This.ctlDefaultExt)) + NULA
		
			*!*** LPARAM lCustData
		
			*!*** LPOFNHOOKPROC lpfnHook
			.lpfnHook = This. _CallbackPointer
		
			*!*** LPCTSTR lpTemplateName
		
			*!*** DWORD FlagsEx
			If This.ctlShowPlacesBar = TRUE Then
				.FlagsEx = 0
			Else
				.FlagsEx = OFN_EX_NOPLACESBAR
			Endif
		
			If ctlGetOsVersion() >= NTDDI_VISTA And This.ctlAutoUpgradeEnabled = TRUE Then
				.FlagsEx = 0
			Endif
		
		Endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_folderbrowserdialog AS ctl32_commondialog OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: _getflags
		*m: _setupbrowseinfo
		*p: ctldescription		&& Gets or sets the descriptive text displayed above the tree view control in the dialog box.
		*p: ctlinitialfolder		&& Sets the initial folder displayed by the file dialog box.
		*p: ctlokcaption		&& Sets the OK Button caption.
		*p: ctlrootfolder		&& Gets or sets the root folder where the browsing starts from.
		*p: ctlselectedpath		&& Gets or sets the path selected by the user.
		*p: ctlshownewfolderbutton		&& Gets or sets a value indicating whether the New Folder button appears in the folder browser dialog box.
		*p: _browseinfo
		*p: _lastmessage
	*</DefinedPropArrayMethod>

	ctldescription = 		&& Gets or sets the descriptive text displayed above the tree view control in the dialog box.
	ctlinitialfolder = 		&& Sets the initial folder displayed by the file dialog box.
	ctlokcaption = 		&& Sets the OK Button caption.
	ctlrootfolder = 		&& Gets or sets the root folder where the browsing starts from.
	ctlselectedpath = 		&& Gets or sets the path selected by the user.
	ctlshownewfolderbutton = .T.		&& Gets or sets a value indicating whether the New Folder button appears in the folder browser dialog box.
	Name = "ctl32_folderbrowserdialog"
	_browseinfo = 
	_lastmessage = 0
	lblname.Caption = "ctl32_folderbrowserdialog"
	lblname.Name = "lblname"
	
	PROCEDURE ctlhookproc
		Lparameters hdlg As Integer, uiMsg As Integer, wParam As Integer, Lparam As Integer
		
		*!*?hdlg , uiMsg , wParam , Lparam
		
		Do Case
			Case m.uiMsg = BFFM_INITIALIZED
		
				If Not Empty(This.ctlTitle) Then
					apiSetWindowText(m.hdlg, This.ctlTitle)
				Endif
		
				If Not Empty(This.ctlInitialFolder) Then
					apiSendMessage(m.hdlg, BFFM_SETSELECTIONW, 1, Strconv(Transform(This.ctlInitialFolder), 12) + NULW)
				Endif
		
				Local ;
					loRegistry As ctl32_registry, ;
					loRect As _RECT, ;
					loMonitorInfoEx As _MONITORINFOEX, ;
					lnLeft, lnTop, lnWidth, lnHeight
		
				m.loRegistry = Newobject("ctl32_registry")
				m.loRect = Newobject("_RECT")
				m.loMonitorInfoEx = Newobject("_MONITORINFOEX")
		
				*!* Get stored dimensions of dialog from registry:
				m.loRegistry.RegistryKey = "HKCU"
				m.loRegistry.RegistrySubkey = "Software\Microsoft\Windows\CurrentVersion\Explorer"
		
				m.lnWidth = m.loRegistry.GetValue("Browse For Folder Width", 327)
				m.lnHeight = m.loRegistry.GetValue("Browse For Folder Height", 289)
		
				m.loRegistry = .Null.
				
				*!* Get rect of browseforfolder window
				apiGetWindowRect(m.hdlg, m.loRect.Address)
		
				*!* Adjust rect
				m.loRect.Width = m.lnWidth
				m.loRect.Height = m.lnHeight
				
				*!* Get monitor where dialog is located:
				m.lnHMonitor = apiMonitorFromRect(m.loRect.Address, MONITOR_DEFAULTTONEAREST)
		
				*!* Get monitor info:
				m.lnResult = apiGetMonitorInfo(m.lnHMonitor, m.loMonitorInfoEx.Address)
		
				m.lnLeft   = m.loMonitorInfoEx.rcWork.Left + (m.loMonitorInfoEx.rcWork.Width - m.lnWidth) / 2
				m.lnTop    = m.loMonitorInfoEx.rcWork.Top  + (m.loMonitorInfoEx.rcWork.Height  - m.lnHeight) / 2;
		
				apiSetWindowPos(m.hdlg, HWND_TOP, m.lnLeft, m.lnTop, 0, 0, Bitor(SWP_NOSIZE,SWP_NOZORDER,SWP_NOACTIVATE))
		
				m.loRect = .Null.
				m.loMonitorInfoEx = .Null.
		
		Endcase
		
		Return 0
		
		*!*	#Define BFFM_SETSTATUSTEXTA     (0x400 + 100)
		*!*	#Define BFFM_ENABLEOK           (0x400 + 101)
		*!*	#Define BFFM_SETSELECTIONA      (0x400 + 102)
		*!*	#Define BFFM_SETSELECTIONW      (0x400 + 103)
		*!*	#Define BFFM_SETSTATUSTEXTW     (0x400 + 104)
		*!*	#Define BFFM_SETOKTEXT          (0x400 + 105) && Unicode only
		*!*	#Define BFFM_SETEXPANDED        (0x400 + 106) && Unicode only
		
	ENDPROC

	PROCEDURE ctlshowdialog
		*!* ctlShowDialog()
		
		Lparameters pnHwnd As Integer
		
		Local ;
			lnPidl As Integer, ;
			lcPath As String
		
		This._SetupBrowseInfo(m.pnHwnd)
		
		m.lnPidl = apiSHBrowseForFolder(This._BrowseInfo.Address)
		
		m.lcPath = Replicate(NULA, MAX_PATH)
		
		If m.lnPidl # 0 Then
			If apiSHGetPathFromIDList(m.lnPidl, @m.lcPath) = 0 Then
				m.lcPath = This._BrowseInfo.pszDisplayName
			Endif
			apiCoTaskMemFree(m.lnPidl)
		Endif
		
		m.lcPath = Chrtran(m.lcPath, NULA, "")
		
		?m.lcPath
		
		Return 0
		
	ENDPROC

	PROCEDURE Destroy
		*!* _Destroy()
		
		This._DestroyCallBack()
	ENDPROC

	PROCEDURE Init
		DoDefault()
		
		This._CreateCallBack()
		
	ENDPROC

	PROCEDURE _getflags
		*!* _getFlags()
		
		Local lnFlags As Integer
		
		m.lnFlags = 0
		
		*!* BIF_RETURNONLYFSDIRS
		*m.lnFlags = Bitor(m.lnFlags, BIF_RETURNONLYFSDIRS)
		
		*!* BIF_DONTGOBELOWDOMAIN
		
		*!* BIF_STATUSTEXT
		
		*!* BIF_RETURNFSANCESTORS
		
		*!* BIF_EDITBOX
		
		*!* BIF_VALIDATE
		*m.lnFlags = Bitor(m.lnFlags, BIF_VALIDATE)
		
		*!* BIF_NEWDIALOGSTYLE
		m.lnFlags = Bitor(m.lnFlags, BIF_NEWDIALOGSTYLE)
		
		*!* BIF_BROWSEINCLUDEURLS
		
		*!* BIF_USENEWUI
		*m.lnFlags = Bitor(m.lnFlags, BIF_USENEWUI)
		
		*!* BIF_UAHINT
		* m.lnFlags = Bitor(m.lnFlags, BIF_UAHINT)
		
		*!* BIF_NONEWFOLDERBUTTON
		
		*!* BIF_NOTRANSLATETARGETS
		
		*!* BIF_BROWSEFORCOMPUTER
		*m.lnFlags = Bitor(m.lnFlags, BIF_BROWSEFORCOMPUTER)
		
		*!* BIF_BROWSEFORPRINTER
		*m.lnFlags = Bitor(m.lnFlags, BIF_BROWSEFORPRINTER)
		
		*!* BIF_BROWSEINCLUDEFILES
		*m.lnFlags = Bitor(m.lnFlags, BIF_BROWSEINCLUDEFILES)
		
		*!* BIF_SHAREABLE
		
		Return m.lnFlags
		
	ENDPROC

	PROCEDURE _setproperties
		*!* _SetProperties()
		
		DoDefault()
		
		This._BrowseInfo = Newobject("_BROWSEINFO")
		
	ENDPROC

	PROCEDURE _setupbrowseinfo
		*!* _SetupBrowseInfo()
		
		Lparameters pnHwnd
		
		Local lnBufferLen As Integer, lcFilter As String
		
		With This._BrowseInfo As _BrowseInfo
		
			*!* Get the owner window of the dialog
			Do Case
				Case Vartype(m.pnHwnd) = "N" And m.pnHwnd > 0
					.hwndOwner = m.pnHwnd
		
				Case Type("_Screen.Activeform") = "O"
					.hwndOwner = _Screen.ActiveForm.HWnd
		
				Otherwise
					.hwndOwner = _vfp.HWnd
			Endcase
		
			.pidlRoot = 0
			
			.pszDisplayName = Replicate(NULA, MAX_PATH)
			
			.lpszTitle = Alltrim(Transform(This.ctlDescription)) + NULA
			
			.ulFlags = This._GetFlags()
			
			.lpfn = This._CallbackPointer
			
			.Lparam = 0
			
			.iImage = 0
		
		Endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_formstate AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlclearstate		&& Removes the state data from the registry.
		*m: ctlrestorestate
		*m: _addobjects
		*m: _addproperties
		*m: _bindevents
		*m: _generateformid
		*m: _getstatefromregistry
		*m: _getstatefromwindow
		*m: _moveform
		*m: _onforminit
		*m: _onformshow0
		*m: _onformshow1
		*m: _restorestateafterformshow
		*m: _restorestatebeforeformshow
		*m: _savestate
		*p: ctlautocenter		&& Specifies if the Form should be always be displayed centered, regardless of the saved settings.
		*p: ctlhideminimized		&& Specifies if the minimized form should be hidden.
		*p: ctlrestoremaxstate		&& Specifies if the maximized state of the form should be restored.
		*p: ctlrestoreminpos		&& Specifies if the minimized position of the form should be restored.
		*p: ctlrestoreminstate		&& Specifies if the minimized state of the form should be restored.
		*p: ctlrestorestateinide		&& Specifies if form settings should be saved/restored while using IDE.
		*p: ctlrestorestyle		&& Specifies how the forms settings should be restored. 0: No restore. 1: Restore and move form into view 2: Move form fully into view 3: Resize to fit.
		*p: ctlrestoretoprimary		&& Specifies if the form should be restored in the primary monitor if it is out of the vistual screen area. For top level forms only.
		*p: ctlwindowstate		&& Especifies the initial Form State, regardless of the saved settings.
		*p: _autocenter
		*p: _clearstate
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _registrysubkey
		*p: _registryvaluename		&& Specifies the value name to use for storing form data in the registry
		*p: _windowstate
	*</DefinedPropArrayMethod>

	HIDDEN _autocenter,_clearstate,_windowstate
	BackColor = 140,200,200
	ctlautocenter = .F.		&& Specifies if the Form should be always be displayed centered, regardless of the saved settings.
	ctlhideminimized = .F.		&& Specifies if the minimized form should be hidden.
	ctlrestoremaxstate = .T.		&& Specifies if the maximized state of the form should be restored.
	ctlrestoreminpos = .F.		&& Specifies if the minimized position of the form should be restored.
	ctlrestoreminstate = .F.		&& Specifies if the minimized state of the form should be restored.
	ctlrestorestateinide = .T.		&& Specifies if form settings should be saved/restored while using IDE.
	ctlrestorestyle = 1		&& Specifies how the forms settings should be restored. 0: No restore. 1: Restore and move form into view 2: Move form fully into view 3: Resize to fit.
	ctlrestoretoprimary = .F.		&& Specifies if the form should be restored in the primary monitor if it is out of the vistual screen area. For top level forms only.
	ctlwindowstate = 0		&& Especifies the initial Form State, regardless of the saved settings.
	Height = 23
	Name = "ctl32_formstate"
	Visible = .F.
	Width = 96
	_autocenter = .F.
	_clearstate = .F.
	_registrysubkey = FormState
	_registryvaluename = 		&& Specifies the value name to use for storing form data in the registry
	_windowstate = 0

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_formstate", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 4
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE ctlclearstate		&& Removes the state data from the registry.
		*!* ctlClearState()
		
		*!* Deletes state data from registry and prevents saving on exit
		
		This.oRegistry.DeleteValue(Addbs(This._RegistrySubKey) + This._RegistryValueName)
		
		This._ClearState = TRUE
		
	ENDPROC

	PROCEDURE ctlrestorestate
		*!* ctlRestoreState()
		
		If This._FormType = CON_FORMTYPE_SCREEN Then
		  *!* Move VFP window out of sight:
		  This._RestoreStateBeforeFormShow()
		  *!* _Screen should start hidden via SCREEN=OFF in config.fpw
		  _Screen.Visible = TRUE
		  This._RestoreStateAfterFormShow()
		Endif
		
		
		
	ENDPROC

	PROCEDURE Destroy
		*!* Destroy
		
		This._SaveState()
	ENDPROC

	PROCEDURE Init
		*!* Init
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		*!* Add Objects
		This._AddObjects()
		
		*!* Add properties:
		This._AddProperties()
		
		*!* Decide when we are going to do the form state restore:
		If This._FormType = CON_FORMTYPE_SCREEN Then
			*!* This.ctlRestoreState() should be called in main program,
			*!* After setting properties of class like ctlRestoreStyle, etc
		Else
			*!* Form is not the Screen, bind to SHOW event of form:
			If Thisform.WindowType = 0 Then
				This._BindEvents()
			Endif
		Endif
		
		
		
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _addobjects
		*!* _AddObjects()
		
		*!* Add registry object
		This.AddObject("oRegistry", "ctl32_Registry")
		
		*!* Define MonitorInfoEx Object
		This.AddObject("oMonitorInfoEx", "_MONITORINFOEX")
		
		*!* Define object to hold windowplacement data of form
		This.AddObject("oWindowPlacement", "_WINDOWPLACEMENT")
		
		
	ENDPROC

	HIDDEN PROCEDURE _addproperties
		*!* _AddProperties()
		
		*!* Specifies if the form should be restored to maximized state:
		This.AddProperty("_Maximized", FALSE)
		
		*!* Stores the hWnd of the host window
		This.AddProperty("_hWnd", 0)
		
		*!* Stores Form Type:
		This.AddProperty("_FormType", ctlGetFormType(Thisform))
		
		*!* Save form HWnd or VFP HWnd if form is _Screen:
		If This._FormType = CON_FORMTYPE_SCREEN Then
		  This._HWnd = _vfp.HWnd
		Else
		  This._HWnd = Thisform.HWnd
		Endif
		
		
	ENDPROC

	HIDDEN PROCEDURE _bindevents
		*!* _BindEvents()
		
		Bindevent(Thisform, "Init", This, "_OnFormInit", 1)
		Bindevent(Thisform, "Show", This, "_OnFormShow0", 0)
		Bindevent(Thisform, "Show", This, "_OnFormShow1", 1)
		
	ENDPROC

	PROCEDURE _generateformid
		*!* _GenerateFormId()
		
		*!* Try to generate a unique ID for this form, based on the checksum
		*!* of the names off some of the objects in the form
		
		Local ;
			lcId As String, ;
			loControl As Control, ;
			loSubControl As Control
		
		m.lcId = ""
		
		*!* We just recurse one level
		For Each m.loControl In Thisform.Objects
			*!* Prevent sys(2015) names
			If (Len(m.loControl.Name) = 10 And Left(m.loControl.Name, 1) = "_")  = FALSE Then
				m.lcId = m.lcId + m.loControl.Name
			Endif
		
			If Pemstatus(m.loControl, "Objects", 5) Then
				For Each m.loSubControl In Thisform.Objects
					*!* Prevent sys(2015) names
					If (Len(m.loControl.Name) = 10 And Left(m.loControl.Name, 1) = "_")  = FALSE Then
						m.lcId = m.lcId + m.loControl.Name
					Endif
				Endfor
			Endif
		
		Endfor
		
		m.lcId = m.lcId + Thisform.Name
		
		m.lcId = Padl(Sys(2007, m.lcId, 0, 1), 10, "0")
		
		Return m.lcId
		
	ENDPROC

	HIDDEN PROCEDURE _getstatefromregistry
		*!* _GetStateFromRegistry()
		
		*!* We get the current state of form, save values in This.oWindowPlacement
		This._GetStateFromWindow()
		
		Local lcWindowPlacement As String
		
		m.lcWindowPlacement = This.oWindowPlacement.Value
		
		*!* Get registry data, if any, use actual form data as default
		
		m.lcWindowPlacement = This.oRegistry.GetValue(Addbs(This._RegistrySubKey) + This._RegistryValueName, m.lcWindowPlacement)
		
		This.oWindowPlacement.Value = m.lcWindowPlacement
		
	ENDPROC

	HIDDEN PROCEDURE _getstatefromwindow
		*!* _GetStateFromWindow()
		
		*!* Retrieve current WindowPlacement data from Form:
		apiGetWindowPlacement(This._HWnd, This.oWindowPlacement.Address)
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _moveform
		*!* _MoveForm()
		
		*!* Set form/Screen out of view to prevent flicker:
		If This._FormType = CON_FORMTYPE_DEFAULT Then
			Thisform.Left = - Thisform.Width - Sysmetric(4) * 2
			Thisform.Top = - Thisform.Height - Sysmetric(9) - Sysmetric(4)
		Else
			Thisform.Left = apiGetSystemMetrics(SM_XVIRTUALSCREEN) - Thisform.Width - Sysmetric(4) * 2
			Thisform.Top = apiGetSystemMetrics(SM_YVIRTUALSCREEN) - Thisform.Height - Sysmetric(9) - Sysmetric(4)
		Endif
		
		
	ENDPROC

	PROCEDURE _onforminit
		*!* _OnFormInit()
		Lparameters param1, param2, param3, param4, param5, param6, param7, param8, param9, param10
		
		This._RegistryValueName =This._GenerateFormId()
		
	ENDPROC

	HIDDEN PROCEDURE _onformshow0
		*!* _BeforeFormShow
		
		*!* This procedure should only run once in the form life:
		Unbindevent(Thisform, "Show", This, "_OnFormShow0")
		
		This._RestoreStateBeforeFormShow()
		
	ENDPROC

	HIDDEN PROCEDURE _onformshow1
		*!* _AfterFormShow
		
		*!* This procedure should only run once in the form life:
		Unbindevent(Thisform, "Show", This, "_OnFormShow1")
		
		*!* After the form is displayed, but out of view , we restore its state:
		*!* (check _BeforeFormShow and _MoveForm)
		This._RestoreStateAfterFormShow()
		
	ENDPROC

	HIDDEN PROCEDURE _restorestateafterformshow
		*!* _RestoreStateAfterFormShow()
		
		Local ;
			loRect As _RECT, ;
			lnHeight As Integer, ;
			lnWidth As Integer, ;
			lnParentHeight As Integer, ;
			lnParentWidth As Integer, ;
			loParentForm As Form, ;
			lnHMonitor, ;
			lnResult
		
		m.loRect = Createobject("_RECT")
		
		*!* 20080329 commented out
		*!* Define object to hold data of parent window of form:
		*!* This.AddObject("oParentRect", "_RECT")
		
		*!* After the form is displayed
		
		*!* ctlRestoreStyle values: 0, 1, 2, 3
		If This.ctlRestoreStyle = 0 Then
			Return
		Endif
		
		*!* If we are in the IDE, don´t do anything unless
		*!* ctlRestoreStateInIde is set
		If _vfp.StartMode = 0 .And. This.ctlRestoreStateInIDE = FALSE Then
			Return
		Endif
		
		*!* 20080329 Modified, add form rect calculation
		*!* Check if form does not have sizeable border, use form default size then:
		If Thisform.BorderStyle <> 3 Then
			*!* Get current form rect, so we dont have to add title bar height, etc
			apiGetWindowRect(Thisform.HWnd,m.loRect.Address)
		
			With This.oWindowPlacement.rcNormalPosition
				.Right = .Left + m.loRect.Width
				.Bottom = .Top + m.loRect.Height
			Endwith
		Endif
		
		*!* Always set minimized form coordinates:
		
		This.oWindowPlacement.Flags = Bitset(This.oWindowPlacement.Flags, WPF_SETMINPOSITION - 1)
		
		*!*	Check if minimized WindowState Status should be restored:
		If This.ctlRestoreMinState = FALSE Or Thisform.MinButton = FALSE Then
			If This.oWindowPlacement.ShowCmd = SW_SHOWMINIMIZED
				If Bittest(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1) = TRUE
					This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED
				Else
					This.oWindowPlacement.ShowCmd = SW_SHOWNORMAL
				Endif
			Endif
		Endif
		
		*!*	Check if maximized WindowState Status should be restored:
		If This.ctlRestoreMaxState = FALSE Or Thisform.MaxButton = FALSE Then
			If Bittest(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1) = TRUE Then
				Bitclear(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
				This.oWindowPlacement.Flags = Bitclear(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
				If This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED
					This.oWindowPlacement.ShowCmd = SW_SHOWNORMAL
				Endif
			Endif
		Endif
		
		*!* Should form always show minimized
		If This._WindowState = 1 And Thisform.MinButton = TRUE Then
			This.oWindowPlacement.Flags = Bitclear(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
			This.oWindowPlacement.ShowCmd = SW_SHOWMINIMIZED
		Endif
		
		*!* Should form always show maximized
		If This._WindowState = 2 And Thisform.MaxButton = TRUE Then
			This.oWindowPlacement.Flags = Bitset(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
			This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED
		Endif
		
		*!* Check if minimized WindowState Position should be restored:
		If This.ctlRestoreMinPos = FALSE Then
			This.oWindowPlacement.ptMinPosition.X = -1
			This.oWindowPlacement.ptMinPosition.Y = -1
		Endif
		
		*!* Check if minimized form should be hidden:
		If This.ctlHideMinimized = TRUE Then
			*!* set minimized WindowState Position out of screen:
			This.oWindowPlacement.ptMinPosition.X = 0
			This.oWindowPlacement.ptMinPosition.Y = apiGetSystemMetrics(SM_YVIRTUALSCREEN) + ;
				apiGetSystemMetrics(SM_CYVIRTUALSCREEN)
		Endif
		
		*!*	 We will maximize the form now if needed:
		If This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED Then
			If This._FormType = CON_FORMTYPE_DEFAULT
				Thisform.WindowState = WINDOWSTATE_MAXIMIZED
			Else
				If apiGetSystemMetrics(SM_CMONITORS) = 1 Then
					Thisform.WindowState = WINDOWSTATE_MAXIMIZED
				Else
					This.oWindowPlacement.ShowCmd = SW_SHOW
					This._Maximized = TRUE
				Endif
			Endif
		Endif
		
		*!* Get parent form container coordinates, if this is a standard
		*!* form, get coordinates of parent Top Level Form or Screen
		*!* if this is a Top Level Form or Screen, get coordinates of Windows
		*!* Desktop
		
		If This._FormType = CON_FORMTYPE_DEFAULT Then
			*!* we have a standard form, get coordinates of parent.
			*!* Parent can be a Top Level Form or the VFP _Screen
			m.loParentForm = ctlGetParentForm(Thisform)
		
			*!* Save parent position/size:
			With m.loRect
				.Left = 0
				.Top = 0
				.Right = m.loParentForm.Width
				.Bottom = m.loParentForm.Height
			Endwith
			m.loParentForm = .Null.
		Else
			*!* We have a Top Level Form or the _Screen
		
			*!* We already have the form Rect stored in last 16 bytes of This.oWindowPlacement.Value
		
			*!* Get work space Rect of monitor that contains most of form Rect,
			*!* or the nearest monitor, if form Rect is not in any monitor
		
			m.loRect.Value = Right(This.oWindowPlacement.Value, 16)
		
			If This.ctlRestoreToPrimary = TRUE Then
				*!* Form should restore to primary monitor if form Rect is outside any monitor:
				m.lnHMonitor = apiMonitorFromRect(m.loRect.Address, MONITOR_DEFAULTTONULL)
		
				If m.lnHMonitor = Null Then
					m.lnHMonitor = apiMonitorFromRect(m.loRect.Address, MONITOR_DEFAULTTOPRIMARY)
				Endif
			Else
				*!* Get nearest monitor to form Rect:
				m.lnHMonitor = apiMonitorFromRect(m.loRect.Address, MONITOR_DEFAULTTONEAREST)
			Endif
		
			m.lnResult = apiGetMonitorInfo(m.lnHMonitor, This.oMonitorInfoEx.Address)
		
			If m.lnResult <> 0 Then
				*!* GetMonitorInfo success!
				With m.loRect
					.Left = This.oMonitorInfoEx.rcWork.Left
					.Top = This.oMonitorInfoEx.rcWork.Top
					.Right = This.oMonitorInfoEx.rcWork.Right
					.Bottom = This.oMonitorInfoEx.rcWork.Bottom
				Endwith
				m.lnHMonitor = .Null.
		
			Else
				*!* GetMonitorInfo failed, use primary monitor info
				With m.loRect
					.Left = 0
					.Top = 0
					.Right = Sysmetric(SYSMETRIC_CLIENTWIDTH)
					** BUG! VFP reports this as too small, add one title bar height to value:
					.Bottom = Sysmetric(SYSMETRIC_CLIENTHEIGHT) + Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT)
				Endwith
			Endif
		
		Endif
		
		*!* Now adjust form position depending on ctlRestoreStyle:
		With This
		
			*!* Just move form barely into view if needed:
			If .ctlRestoreStyle = 1 Then
				*!* Move up, display title bar
				If .oWindowPlacement.rcNormalPosition.Top > m.loRect.Bottom - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) Then
					m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
					.oWindowPlacement.rcNormalPosition.Top = m.loRect.Bottom - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) - Sysmetric(SYSMETRIC_SIZINGBORDERHEIGHT)
					.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
				Endif
		
				*!* Move left, 4 title bar heights, if needed
				If .oWindowPlacement.rcNormalPosition.Left > m.loRect.Right - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 4 Then
					m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
					.oWindowPlacement.rcNormalPosition.Left = m.loRect.Right - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 4
					.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
				Endif
		
				*!* Move down, display title bar
				If .oWindowPlacement.rcNormalPosition.Top < m.loRect.Top Then
					m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
					.oWindowPlacement.rcNormalPosition.Top = m.loRect.Top
					.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
				Endif
		
				*!* 20070901 make it 5 title bar heights to account for vista buttons
				*!* Move right, 4 title bar heights
				If .oWindowPlacement.rcNormalPosition.Right <= m.loRect.Left + Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 6 Then
					m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
					.oWindowPlacement.rcNormalPosition.Right = m.loRect.Left + Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 6
					.oWindowPlacement.rcNormalPosition.Left = .oWindowPlacement.rcNormalPosition.Right - m.lnWidth
				Endif
			Endif
		
			*!* Move form fully into view if needed
			If .ctlRestoreStyle >= 2 Then
				*!* Move up
				If .oWindowPlacement.rcNormalPosition.Bottom > m.loRect.Bottom Then
					m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
					.oWindowPlacement.rcNormalPosition.Top = m.loRect.Bottom - m.lnHeight
					.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
				Endif
		
				*!* Move left
				If .oWindowPlacement.rcNormalPosition.Right > m.loRect.Right Then
					m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
					.oWindowPlacement.rcNormalPosition.Left = m.loRect.Right - m.lnWidth
					.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
				Endif
		
				*!* Move down
				If .oWindowPlacement.rcNormalPosition.Top < m.loRect.Top Then
					m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
					.oWindowPlacement.rcNormalPosition.Top = m.loRect.Top
					.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
				Endif
		
				*!* Move right
				If .oWindowPlacement.rcNormalPosition.Left < m.loRect.Left Then
					m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
					.oWindowPlacement.rcNormalPosition.Left = m.loRect.Left
					.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
				Endif
			Endif
		
			*!* Adjust form size to fit in parent, form already moved into view:
			If .ctlRestoreStyle = 3 .And. Thisform.BorderStyle = 3 Then
		
				m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
				m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
				m.lnParentHeight = m.loRect.Bottom - m.loRect.Top
				m.lnParentWidth = m.loRect.Right - m.loRect.Left
		
				*!* Adjust height
				If m.lnHeight > m.lnParentHeight Then
					.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnParentHeight
				Endif
		
				*!* Adjust width
				If m.lnWidth > m.lnParentWidth Then
					.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnParentWidth
				Endif
			Endif
		
			*!* Center if requested:
			If This._AutoCenter = TRUE Then
		
				m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
				m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
				m.lnParentHeight = m.loRect.Bottom - m.loRect.Top
				m.lnParentWidth = m.loRect.Right - m.loRect.Left
		
				If m.lnWidth < m.lnParentWidth Then
					.oWindowPlacement.rcNormalPosition.Left = Int(m.lnParentWidth / 2 - m.lnWidth / 2) + m.loRect.Left
					.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
				Endif
				If m.lnHeight < m.lnParentHeight Then
					.oWindowPlacement.rcNormalPosition.Top = Int(m.lnParentHeight / 2 - m.lnHeight / 2) + m.loRect.Top
					.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
				Endif
			Endif
		Endwith
		
		*!* Send structure to form:
		apiSetWindowPlacement(This._HWnd, This.oWindowPlacement.Address)
		
		If This._Maximized = TRUE Then
			Thisform.WindowState = WINDOWSTATE_MAXIMIZED
		Endif
		
		
		m.loRect = .Null.
		
	ENDPROC

	HIDDEN PROCEDURE _restorestatebeforeformshow
		*!* _RestoreStateBeforeFormShow()
		
		*!* Before the form is displayed
		
		*!* ctlRestoreStyle values: 0, 1, 2, 3
		If This.ctlRestoreStyle = 0 Then
			Return
		Endif
		
		*!* If we are in the IDE, don´t do anything unless
		*!* ctlRestoreStateInIde is set
		If _vfp.StartMode = 0 .And. This.ctlRestoreStateInIDE = FALSE Then
			Return
		Endif
		
		*!* Setup some values based in saved data existance:
		
		If This.oRegistry.SeekValue(Addbs(This._RegistrySubKey) + This._RegistryValueName) = TRUE Then
			This._AutoCenter = This.ctlAutoCenter
			This._WindowState = This.ctlWindowState
		Else
			This._AutoCenter = Thisform.AutoCenter Or This.ctlAutoCenter
			This._WindowState = Max(Thisform.WindowState, This.ctlWindowState)
		Endif
		
		Thisform.WindowState = 0
		
		If Thisform.MaxButton = FALSE And This._WindowState = 2 Then
			This._WindowState = 0
		Endif
		
		*!* Get form state Data from registry:
		This._GetStateFromRegistry()
		
		*!* Just before form displays, we send it out of view to prevent flicker
		This._MoveForm()
		
	ENDPROC

	HIDDEN PROCEDURE _savestate
		*!* _SaveState()
		
		Local lcWindowPlacement As String
		
		*!* ctlRestoreStyle values: 0, 1, 2, 3
		If This.ctlRestoreStyle = 0 Then
			Return
		Endif
		
		*!* If we are in the IDE, don´t do anything unless
		*!* ctlRestoreStateInIde is set
		If _vfp.StartMode = 0 .And. This.ctlRestoreStateInIDE = FALSE Then
			Return
		Endif
		
		*!* Check if registry data was deleted:
		If This._ClearState = TRUE Then
			Return
		Endif
		
		This._GetStateFromWindow()
		
		If This.ctlHideMinimized = TRUE Then
			*!* Restore minimized coordinates to default, so as not to save
			*!* off-screen coordinates:
			This.oWindowPlacement.ptMinPosition.x = -1
			This.oWindowPlacement.ptMinPosition.Y = -1
		Endif
		
		m.lcWindowPlacement = This.oWindowPlacement.Value
		
		*!* Store data in Windows registry:
		This.oRegistry.SetValue(Addbs(This._RegistrySubKey) + This._RegistryValueName, m.lcWindowPlacement)
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_ftp AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: formatbytes
		*m: formatseconds
		*m: ftpaddfs		&& Adds a forward slash to an ftp path
		*m: ftpcancel
		*m: ftpclose
		*m: ftpcommand		&& Sends commands directly to an FTP server.
		*m: ftpcreatedirectory
		*m: ftpdeletefile
		*m: ftpdirtoarray
		*m: ftpdirtocursor
		*m: ftpgetcurrentdirectory		&& Retrieves the current directory for the active FTP session.
		*m: ftpgetfile
		*m: ftpgetfiledate
		*m: ftpgetfileinfo
		*m: ftpgetfilesize
		*m: ftpopen
		*m: ftppause
		*m: ftpputfile
		*m: ftpreadfile
		*m: ftpreadurl
		*m: ftpremovedirectory		&& Removes the specified directory on the FTP server.
		*m: ftprenamefile
		*m: ftpresponse
		*m: ftpsetcurrentdirectory		&& Changes to a different working directory on the FTP server.
		*m: ftptransfer
		*m: ftptransferend
		*m: ftptransferstart
		*m: ftpwritefile
		*m: internetclose
		*m: internetopen
		*m: _addobjects
		*m: _addpath
		*m: _addproperties
		*m: _addtoarray
		*m: _clearlasterror
		*m: _clearlastresponse
		*m: _fillftpfileinfo
		*m: _ftpfindfile
		*m: _ftpgetfilesize
		*m: _ftpopenfile
		*m: _ftpreadcommand
		*m: _getflags
		*m: _getflagsinternet
		*m: _getlasterror
		*m: _getlastresponse
		*m: _internetclosehandle
		*m: _internetcrackurl
		*m: _internetqueryoption
		*m: _internetsetoption
		*m: _setproperties
		*m: _updateurlproperties
		*p: ctlabout
		*p: ctlversion
		*p: flagcacheasync
		*p: flagcacheifnetfail
		*p: flaghyperlink
		*p: flagneedfile
		*p: flagnocachewrite
		*p: flagpassive
		*p: flagreload
		*p: flagresynchronize
		*p: flagtransferbinary
		*p: ftpcommanddata
		*p: ftperrorcode
		*p: ftperrorfunction
		*p: ftperrortext
		*p: ftpfiledata
		*p: ftpfileinfo
		*p: ftppassword		&& ITC
		*p: ftpresponsecode		&& ITC
		*p: ftpresponsefunction
		*p: ftpresponsetext		&& ITC
		*p: ftptransfercancelled
		*p: ftptransferinfo
		*p: ftptransferpaused
		*p: ftpusername		&& ITC
		*p: hconnect
		*p: hfile
		*p: hfind
		*p: hftpcommand
		*p: hinternet
		*p: internetaccesstype		&& ITC
		*p: internetflagasync
		*p: internetflagfromcache
		*p: internetflagoffline
		*p: internetproxybypass
		*p: internetproxyname
		*p: internetuseragent
		*p: optiondebug
		*p: urlextrainfo
		*p: urlhostname		&& ITC
		*p: urlpassword
		*p: urlpath
		*p: urlport		&& ITC
		*p: urlschemecode
		*p: urlschemename
		*p: urltext
		*p: urlusername
		*a: ftpfiles[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	ctlabout = ctl32_ftp
	ctlversion = 20070800
	flagcacheasync = .F.
	flagcacheifnetfail = .F.
	flaghyperlink = .F.
	flagneedfile = .F.
	flagnocachewrite = .F.
	flagpassive = .F.
	flagreload = .F.
	flagresynchronize = .F.
	flagtransferbinary = .T.
	ftpcommanddata = 
	ftperrorcode = 0
	ftperrorfunction = 
	ftperrortext = 
	ftpfiledata = 
	ftpfileinfo = 
	ftppassword = 		&& ITC
	ftpresponsecode = 0		&& ITC
	ftpresponsefunction = 
	ftpresponsetext = 		&& ITC
	ftptransfercancelled = .F.
	ftptransferinfo = 
	ftptransferpaused = .F.
	ftpusername = 		&& ITC
	hconnect = 0
	Height = 21
	hfile = 0
	hfind = 0
	hftpcommand = 0
	hinternet = 0
	internetaccesstype = 0		&& ITC
	internetflagasync = .F.
	internetflagfromcache = .F.
	internetflagoffline = .F.
	internetproxybypass = <local>
	internetproxyname = 
	internetuseragent = Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
	Name = "ctl32_ftp"
	optiondebug = .F.
	urlextrainfo = 
	urlhostname = 		&& ITC
	urlpassword = 
	urlpath = 
	urlport = 0		&& ITC
	urlschemecode = 0
	urlschemename = 
	urltext = 
	urlusername = 
	Visible = .F.
	Width = 96

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_ftp", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 3, ;
		Width = 45
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE Destroy
		This.OptionDebug = FALSE
		
		This._Destroying = TRUE
		
		This.InternetClose()
		
		
	ENDPROC

	PROCEDURE formatbytes
		*!* FormatBytes(nBytes)
		
		Lparameters m.tnBytes As Integer
		
		Return ctlStrFormatByteSize(m.tnBytes)
		
	ENDPROC

	PROCEDURE formatseconds
		*!* FormatSeconds(nSeconds)
		
		Lparameters m.tnSeconds As Integer
		
		Return ctlStrFormatSeconds(m.tnSeconds)
		
	ENDPROC

	PROCEDURE ftpaddfs		&& Adds a forward slash to an ftp path
		*!* FtpAddfs(cPath)
		*!* Adds a forward slash at the end of an FTP path, if needed.
		
		Lparameters m.tcPath As String
		
		If Right(m.tcPath, 1) <> "/" Then
		    m.tcPath = m.tcPath + "/"
		Endif
		
		Return m.tcPath
		
	ENDPROC

	PROCEDURE ftpcancel
		*!* FtpCancel()
		
		This.FtpTransferCancelled = TRUE
	ENDPROC

	PROCEDURE ftpclose
		*!* FtpClose()
		
		This.hConnect = This._InternetCloseHandle(This.hConnect)
		
		Return TRUE
		
		
	ENDPROC

	PROCEDURE ftpcommand		&& Sends commands directly to an FTP server.
		*!* FtpCommand(cCommand, [lExpectResponse])
		
		Lparameters m.tcCommand As String, m.tlExpectResponse As Boolean
		
		Local ;
			lnApiRetVal As Integer, ;
			lnExpectResponse As Integer, ;
			lnFlags As Integer, ;
			lcCommand As String, ;
			lnContext As Integer, ;
			lnFtpCommandHandle As Integer, ;
			lcFunction As String, ;
			llRetVal As Boolean
		
		*!* If a response is expected, clear current hFtpCommand handle:
		If m.tlExpectResponse = TRUE Then
			m.lnExpectResponse = 1
			This.hFtpCommand = This._InternetCloseHandle(This.hFtpCommand)
		Else
			m.lnExpectResponse = 0
		Endif
		
		*!* Get flags for FtpCommand:
		If This.FlagTransferBinary = TRUE Then
			m.lnFlags = FTP_TRANSFER_TYPE_ASCII
		Else
			m.lnFlags = FTP_TRANSFER_TYPE_BINARY
		Endif
		
		m.lcCommand = Alltrim(m.tcCommand) + NULA
		
		m.lnContext = 0
		
		m.lnFtpCommandHandle = 0
		
		m.lnApiRetVal = apiFtpCommand( ;
			This.hConnect, ;
			m.lnExpectResponse, ;
			m.lnFlags, ;
			m.lcCommand, ;
			m.lnContext, ;
			@m.lnFtpCommandHandle)
		
		If m.tlExpectResponse = TRUE Then
			This.hFtpCommand = m.lnFtpCommandHandle
			This._FtpReadCommand()
			This.hFtpCommand = This._InternetCloseHandle(This.hFtpCommand)
		Endif
		
		m.lcFunction = "FtpCommand"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpcreatedirectory
		*!* FtpCreateDirectory(cDirectory)
		
		Lparameters m.tcDirectory As String
		
		Local ;
			lnApiRetVal As Integer, ;
			lcFunction As String, ;
			llRetVal As Boolean
		
		If Vartype(m.tcDirectory) = T_CHARACTER Then
			m.tcDirectory = Alltrim(m.tcDirectory) + NULA
		Else
			m.tcDirectory = ""  + NULA
		Endif
		
		m.lnApiRetVal = apiFtpCreateDirectory(This.hConnect, m.tcDirectory)
		
		m.lcFunction = "FtpCreateDirectory"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpdeletefile
		*!* FtpDeleteFile(cRemoteFile)
		
		Lparameters m.tcRemoteFile As String
		
		Local ;
			lcRemoteFile As String, ;
			lnApiRetVal As Integer, ;
			lcFunction As String, ;
			llRetVal As Boolean
		
		If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
			Return FALSE
		Endif
		
		m.lcRemoteFile = m.tcRemoteFile
		m.lcRemoteFile = This._AddPath(m.lcRemoteFile) + NULA
		
		m.lnApiRetVal = apiFtpDeleteFile(This.hConnect, m.lcRemoteFile)
		
		m.lcFunction = "FtpDeleteFile"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpdirtoarray
		*!* FtpDirToArray([cFileSkeleton])
		
		*!* Calls ._FtpFindFile to get files one by one
		*!* Calls ._AddToArray for each file found
		*!* cFileSkeleton can be a directory + filespec, just a filespec, or empty
		*!* if it is just a filespec, it uses the current ftp directory
		*!* if it is empty, it uses the current ftp directory and a *.* filespec
		
		Lparameters m.tcFileSkeleton
		
		Local ;
			lcDirSpec As String, ;
			lcFileSpec As String, ;
			lcFileSkeleton As String, ;
			lcCurrentDirectory As String, ;
			lnFileCount As Integer, ;
			lnRetVal As Integer
		
		*!* Just in case we have an open file enumeration:
		This.hFind = This._InternetCloseHandle(This.hFind)
		
		*!* Init array and add first row (".." directory entry row)
		This._AddToArray(0)
		
		If Vartype(m.tcFileSkeleton) = T_CHARACTER Then
			m.tcFileSkeleton = Alltrim(m.tcFileSkeleton)
		Else
			m.tcFileSkeleton = ""
		Endif
		
		m.lcFileSkeleton = m.tcFileSkeleton
		
		*!* m.lcFileSkeleton = m.lcDirSpec + m.lcFileSpec
		*!* Split file skeleton in path and file spec:
		
		m.lcDirSpec = Justpath(m.lcFileSkeleton)
		m.lcFileSpec = Justfname(m.lcFileSkeleton)
		
		*!* if no path in file skeleton, use current directory:
		If Empty(m.lcDirSpec) Then
		
			m.lcCurrentDirectory = ""
			If This.FtpGetCurrentDirectory(@m.lcCurrentDirectory) = FALSE Then
				*!* could not get current directory, return with error
				Return -1
			Else
				m.lcDirSpec = This.FtpAddfs(m.lcCurrentDirectory)
			Endif
		
		Else
			*!* Add a forward slash if needed at the end of dirspec:
			m.lcDirSpec = This.FtpAddfs(m.lcDirSpec)
		Endif
		
		If Empty(m.lcFileSpec) Then
			m.lcFileSpec = "*.*"
		Endif
		
		m.lcFileSkeleton =  m.lcDirSpec + m.lcFileSpec
		
		m.lnFileCount = 0
		
		m.lnRetVal = 1
		
		Do While m.lnRetVal = 1
			m.lnRetVal = This._FtpFindFile(m.lcFileSkeleton)
		
			If m.lnRetVal = 1 Then
				m.lnFileCount  = m.lnFileCount  + 1
				This._AddToArray(m.lnFileCount)
			Endif
		
			If m.lnRetVal = -1 Then
				m.lnFileCount = m.lnRetVal
			Endif
		Enddo
		
		Return m.lnFileCount
		
		
		
		
	ENDPROC

	PROCEDURE ftpdirtocursor
		*!* FtpDirToCursor(cCursor, [cFileSkeleton])
		
		Lparameters m.tcCursorName As String, m.tcFileSkeleton As String
		
		m.tcCursorName = Alltrim(m.tcCursorName)
		
		Local ;
			lnFileCount As Integer, ;
			lnRows As Integer, ;
			lnCols As Integer, ;
			laStru(1), ;
			lnCol As Integer
		
		m.lnFileCount = This.FtpDirToArray(m.tcFileSkeleton)
		
		* Figure out size of array
		m.lnRows = Alen(This.FtpFiles, 1)
		m.lnCols = Max( Alen(This.FtpFiles, 2), 1 )
		
		Dimension m.laStru(m.lnCols, 4)
		
		*!* Field names:
		m.laStru(1,1) = "f_name"
		m.laStru(2,1) = "f_size"
		m.laStru(3,1) = "f_date"
		m.laStru(4,1) = "f_time"
		m.laStru(5,1) = "f_attr"
		
		*!* Field sizes:
		m.laStru(1,3) = 254
		m.laStru(2,3) = 12
		m.laStru(3,3) = 8
		m.laStru(4,3) = 8
		m.laStru(5,3) = 5
		
		For m.lnCol = 1 To m.lnCols
			*!* Field type
			m.laStru(m.lnCol, 2 ) = Vartype(This.FtpFiles( 1, m.lnCol))
			*!* Field decimals
			m.laStru(m.lnCol, 4 ) = 0
		Endfor
		
		* Make a cursor with fields defined by laStru
		Create Cursor (m.tcCursorName) From Array m.laStru
		
		Insert Into (m.tcCursorName) From Array This.FtpFiles
		Go Top In (m.tcCursorName)
		
		Return m.lnFileCount
		
	ENDPROC

	PROCEDURE ftpgetcurrentdirectory		&& Retrieves the current directory for the active FTP session.
		*!* FtpGetCurrentDirectory(@cDirectory)
		
		*!* Returns the current Ftp directory in the var passed by reference
		
		Lparameters m.tcDirectory As String
		
		If Pcount() = 0 Then
			Return false
		Endif
		
		Local ;
			lcDirectory As String, ;
			lnDirectoryLen As Integer, ;
			lnApiRetVal As Integer, ;
			lcFunction As String, ;
			llRetVal As Boolean
		
		m.lnDirectoryLen = MAX_PATH
		m.lcDirectory = Space(m.lnDirectoryLen)
		
		m.lnApiRetVal = apiFtpGetCurrentDirectory(;
			This.hConnect, ;
			@m.lcDirectory, ;
			@m.lnDirectoryLen)
		
		If m.lnApiRetVal = 0 Then
			m.tcDirectory = ""
		Else
			m.tcDirectory = Left(m.lcDirectory, m.lnDirectoryLen)
		Endif
		
		m.lcFunction = "FtpGetCurrentDirectory"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = false
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpgetfile
		*!* FtpGetFile(cRemoteFile, cLocalFile, [lOverWrite], [nAttributes])
		
		Lparameters ;
			m.tcRemoteFile As String, ;
			m.tcLocalFile As String, ;
			m.tlOverWrite As Boolean, ;
			m.tnAttributes As Integer
		
		Local ;
			lnApiRetVal As Integer, ;
			lcRemoteFile As String, ;
			lcLocalFile As String, ;
			llOverWrite As Boolean, ;
			llFailIfExists As Boolean, ;
			lnAttributes As Integer, ;
			lnFlags As Integer, ;
			lnContext As Integer, ;
			lcFunction as String, ;
			llRetVal As Boolean
		
		If Vartype(m.tcRemoteFile) <> T_CHARACTER ;
				OR Vartype(m.tcLocalFile) <> T_CHARACTER Then
			Return FALSE
		Endif
		
		m.lcRemoteFile = m.tcRemoteFile
		m.lcRemoteFile = This._AddPath(m.lcRemoteFile) + NULA
		m.lcLocalFile  = Alltrim(m.tcLocalFile) + NULA
		
		If Pcount() < 3 Then
			If Set("Safety") = "OFF" Then
				m.llOverWrite = TRUE
			Else
				m.llOverWrite = FALSE
			Endif
		Else
			m.llOverWrite = m.tlOverWrite
		Endif
		
		*!* Set flags:
		m.lnFlags = This._GetFlags()
		
		If m.tlOverWrite = TRUE Then
			m.llFailIfExists = 0
		Else
			m.llFailIfExists = 1
		Endif
		
		If Vartype(m.tnAttributes) <> T_NUMERIC Then
			m.lnAttributes = 0
		Else
			m.lnAttributes = m.tnAttributes
		Endif
		
		m.lnContext = 0
		
		m.lnApiRetVal = apiFtpGetFile( ;
			This.hConnect, ;
			m.lcRemoteFile, ;
			m.lcLocalFile, ;
			m.llFailIfExists, ;
			m.lnAttributes, ;
			m.lnFlags, ;
			m.lnContext)
		
		m.lcFunction = "FtpGetFile"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = false
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpgetfiledate
		*!* FtpGetFileDate(cRemoteFile)
		
		*!* Returns the last modified date and time of a remote file in GMT time
		
		Lparameters m.tcRemoteFile As String
		
		Local lcRemoteFile, lcResponse
		
		m.lcRemoteFile = m.tcRemoteFile
		m.lcRemoteFile = This._AddPath(m.lcRemoteFile)
		
		If This.FtpCommand("MDTM " + m.lcRemoteFile) = TRUE Then
			m.lcResponse = Getwordnum(This.FtpResponseText, 2, " ")
		Else
			m.lcResponse = ""
		Endif
		
		Return m.lcResponse
	ENDPROC

	PROCEDURE ftpgetfileinfo
		*!* FtpGetFileInfo(cRemoteFile | cRemoteDir)
		
		*!* This method places file/directory info in the FtpFileInfo object
		
		Lparameters m.tcRemoteFile As String
		
		Local ;
			lcDirSpec As String, ;
			lcFileSpec As String, ;
			llRetVal As Boolean, ;
			lcRemoteFile As String
		
		If Pcount() = 0 Or Empty(m.tcRemoteFile) Then
			Return FALSE
		Endif
		
		m.lcRemoteFile = m.tcRemoteFile
		m.lcRemoteFile = This._AddPath(m.lcRemoteFile)
		m.lcDirSpec = This.FtpAddfs(Justpath(m.lcRemoteFile))
		m.lcFileSpec = Justfname(m.lcRemoteFile)
		
		*!* if m.lcRemoteFile is a directory, we get the first file of that
		*!* directory if we use it as a filespec to _FtpFindFile
		*!* so we use the parent directory and iterate thru its files until we find the
		*!* one we are looking for, file or directory (yes, its a kludge)
		
		m.llRetVal = FALSE
		
		Do While This._FtpFindFile(m.lcDirSpec) = 1
			If This.FtpFileInfo.FilePath + This.FtpFileInfo.FileName  == m.lcRemoteFile
				m.llRetVal = TRUE
				Exit
			Endif
		Enddo
		
		*!* close hFind Handle:
		This.hFind = This._InternetCloseHandle(This.hFind)
		
		Return m.llRetVal
		
		
		
		
		
	ENDPROC

	PROCEDURE ftpgetfilesize
		*!* FtpGetFileSize(cRemoteFile)
		
		*!* Returns the size of a remote file
		
		Lparameters m.tcRemoteFile As String
		
		Local ;
			lcRemoteFile, ;
			lnFileSize
		
		m.lcRemoteFile = m.tcRemoteFile
		m.lcRemoteFile = This._AddPath(m.lcRemoteFile)
		
		If This.FtpCommand("SIZE " + m.lcRemoteFile) = TRUE Then
			m.lnFileSize = Int(Val(Getwordnum(This.FtpResponseText, 2, " ")))
		Else
			m.lnFileSize = -1
		Endif
		
		Return m.lnFileSize
		
		*!* FtpGetFileSize does not work as expected for files greater then 4Gb (dwFileSizeHigh always NULL)
		*!* http://groups.google.com.ar/group/microsoft.public.windows.inetexplorer.ie5.programming.wininet/browse_thread/thread/3c118ed4c7c32269/791a868311e60a00?lnk=st&q=ftpfindfirstfile+and+large+files&rnum=2&hl=es#791a868311e60a00
		
		*!*	Local ;
		*!*		m.lcRemoteFile As String, ;
		*!*		m.lnFileSize As Integer
		
		*!*	m.lcRemoteFile = Alltrim(m.tcRemoteFile)
		
		*!*	m.lnFileSize = 0
		
		*!*	*!* FTP PROTOCOL SPECIFIC
		*!*	If This._FtpGetFileSize(m.tcRemoteFile, @m.lnFileSize) = FALSE Then
		*!*		m.lnFileSize = -1
		*!*	Endif
		
		*!*	Return m.lnFileSize
		
	ENDPROC

	PROCEDURE ftpopen
		*!* FtpOpen(cUrl)
		
		*!* Encapsulates InternetConnect API call
		
		*!* Service
		*!*	#DEFINE INTERNET_SERVICE_FTP					1
		*!*	#DEFINE INTERNET_SERVICE_GOPHER					2
		*!*	#DEFINE INTERNET_SERVICE_HTTP					3
		
		*!* Flags
		*!*	INTERNET_FLAG_EXISTING_CONNECT	0x20000000
		*!*	INTERNET_FLAG_PASSIVE	0x8000000
		*!*	INTERNET_FLAG_SECURE	0x800000
		
		Lparameters m.tcUrl As String
		
		If Empty(m.tcUrl) Or Isnull(m.tcUrl) Then
			Return FALSE
		Endif
		
		*!* Before connecting, lets check if we have a valid internet handle,
		*!* if not, try to open one:
		If This.hInternet = 0 Then
			If This.InternetOpen() = FALSE Then
				Return FALSE
			Endif
		Endif
		
		*!* Close any previous InternetConnect open handles:
		This.hConnect = This._InternetCloseHandle(This.hConnect)
		
		Local ;
			lcUrlString As String, ;
			lcServerName As String, ;
			lnServerPort As Integer, ;
			lcUserName As String, ;
			lcPassword As String, ;
			lnService As Integer, ;
			lnFlags As Integer, ;
			lnContext As Integer, ;
			lnApiRetVal As Integer, ;
			lcFunction As String, ;
			llRetVal As Boolean
		
		m.lcUrlString 	= Alltrim(m.tcUrl)
		
		This._InternetCrackUrl(m.lcUrlString)
		
		m.lnService	= INTERNET_SERVICE_FTP
		
		*!* Get value of lnFlags parameter:
		m.lnFlags = This._GetFlags()
		
		*!* Get what we have:
		m.lcServerName = This.UrlHostName + NULA
		m.lnServerPort = This.UrlPort
		m.lcUserName   = This.UrlUserName + NULA
		m.lcPassword   = This.UrlPassword + NULA
		
		m.lnContext = 0
		
		m.lnApiRetVal = apiInternetConnect( ;
			This.hInternet, ;
			m.lcServerName, ;
			m.lnServerPort, ;
			m.lcUserName, ;
			m.lcPassword, ;
			m.lnService, ;
			m.lnFlags, ;
			m.lnContext)
		
		m.lcFunction = "InternetConnect"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		If m.lnApiRetVal = 0 Then
			*!* This is here so we get response from server
			This._GetLastResponse(m.lcFunction)
		Else
			This.hConnect = m.lnApiRetVal
			This._UpdateUrlProperties()
		Endif
		
		If m.llRetVal = TRUE And Not Empty(This.UrlPath) Then
			This.FtpSetCurrentDirectory(This.UrlPath)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftppause
		This.FtpTransferPaused = TRUE
		
	ENDPROC

	PROCEDURE ftpputfile
		*!* FtpPutFile(cLocalFile, cRemoteFile)
		
		Lparameters ;
			m.tcLocalFile As String, ;
			m.tcRemoteFile As String
		
		Local ;
			lcRemoteFile, ;
			lcLocalFile, ;
			lnApiRetVal As Integer, ;
			lnFlags As Integer, ;
			lnContext As Integer, ;
			lcFunction As String, ;
			llRetVal As Boolean
		
		If Vartype(m.tcLocalFile) <> T_CHARACTER Then
			Return FALSE
		Endif
		
		If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
			m.tcRemoteFile = Justfname(m.tcLocalFile)
		Endif
		
		m.lcRemoteFile = m.tcRemoteFile
		m.lcRemoteFile = This._AddPath(m.lcRemoteFile) + NULA
		m.lcLocalFile  = Alltrim(m.tcLocalFile) + NULA
		
		*!* Set flags:
		m.lnFlags = This._GetFlags()
		
		m.lnContext = 0
		
		m.lnApiRetVal = apiFtpPutFile( ;
			This.hConnect, ;
			m.lcLocalFile, ;
			m.lcRemoteFile, ;
			m.lnFlags, ;
			m.lnContext)
		
		m.lcFunction = "FtpPutFile"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpreadfile
		*!* FtpReadFile(cRemoteFile, [cLocalFile])
		
		#Define _MIN_READ_BUFFER_SIZE 1024
		#Define _MAX_READ_BUFFER_SIZE 1024 * 1024
		
		#Define _DOEVENTS_INTERVAL 200
		#Define _UPDATE_UI_INTERVAL 1000
		
		Lparameters m.tcRemoteFile As String, m.tcLocalFile As String
		
		*!* Reset Cancel/Pause flags to false:
		This.FtpTransferCancelled = FALSE
		This.FtpTransferPaused 	  = FALSE
		
		If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
			Return FALSE
		Endif
		
		*!* Commented, let it fail later
		*!*	If This.hConnect = 0 Then
		*!*		Return FALSE
		*!*	Endif
		
		Local ;
			lcReadBuffer As String, ;
			lnReadBufferSize As Integer, ;
			lnNumberOfBytesRead As Integer, ;
			lnApiRetVal As Integer
		
		Local ;
			lcRemoteFile As String, ;
			lcLocalFile As String, ;
			lnBytesTotal As Integer, ;
			lnBytesComplete As Integer, ;
			lnBytesRead As Integer, ;
			lnBytesLeft As Integer ,;
			lnBytesSpeed As Integer , ;
			lnReadTimeStart As Integer, ;
			lnReadTime As Integer, ;
			lnUpdateTime As Integer, ;
			lnTimeStart As Integer, ;
			lnTimeElapsed As Integer, ;
			lnTimeLeft As Integer, ;
			llRetVal As Boolean, ;
			lcTempFile As String, ;
			lnLocalFileHandle As Integer, ;
			llSaveToFile As Boolean, ;
			lnRemoteFileHandle As Integer
		
		m.lcRemoteFile = This._AddPath(m.tcRemoteFile)
		
		If Vartype(m.tcLocalFile) # T_CHARACTER  Then
			m.lcLocalFile = ""
		Else
			m.lcLocalFile = Alltrim(m.tcLocalFile)
		Endif
		
		*!* If we have a m.lcLocalFile, save to file:
		If Not Empty(m.lcLocalFile)  Then
			m.llSaveToFile = TRUE
		Else
			m.llSaveToFile = FALSE
		Endif
		
		*!* Init Api vars:
		m.lnReadBufferSize = _MIN_READ_BUFFER_SIZE
		m.lcReadBuffer = Space(m.lnReadBufferSize)
		m.lnNumberOfBytesRead = 0
		
		*!* Init Counter vars:
		m.lnReadTimeStart = 0
		m.lnReadTime = 0
		m.lnUpdateTime = _UPDATE_UI_INTERVAL
		
		m.lnTimeStart = apiGetTickCount()
		m.lnTimeElapsed = 0
		m.lnTimeLeft = 0
		
		If m.llSaveToFile = TRUE Then
			m.lcTempFile = m.lcLocalFile + ".part"
			*!* If we already have a partial temp file "*.part", get its size:
			If File(m.lcTempFile) Then
				m.lnBytesComplete = ctlFsize(m.lcTempFile)
			Else
				m.lnBytesComplete = 0
			Endif
		Else
			m.lnBytesComplete = 0
			This.FtpFileData = ""
		Endif
		
		*!* Used to store hFile:
		m.lnRemoteFileHandle = 0
		
		*!* If FtpGetFileSize fails, it returns -1
		m.lnBytesTotal = This.FtpGetFileSize(m.lcRemoteFile)
		If m.lnBytesTotal = -1 Then
			m.lnBytesTotal = 0
		Endif
		
		*!* FTP PROTOCOL SPECIFIC
		
		*!* Send REST "Resume" command to ftp server, this has to
		*!* be done BEFORE we open file
		If m.lnBytesComplete > 0 Then
			If This.FtpCommand("REST " + Transform(m.lnBytesComplete)) = TRUE Then
		
				If This.FtpResponseCode <> 350
					*!* Rest command NOT supported
					m.lnBytesComplete = 0
				Endif
			Else
				*!* FtpCommand failed:
				m.lnBytesComplete = 0
			Endif
		
		Endif
		
		*!* Try to open remote file:
		If This._FtpOpenFile(m.lcRemoteFile, GENERIC_READ) = FALSE
			Return FALSE
		Endif
		
		m.lnRemoteFileHandle = This.hFile
		
		*!* Prevent negative values:
		m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)
		
		m.lnBytesRead = 0
		m.lnBytesSpeed = 0
		
		If m.llSaveToFile = TRUE Then
			*!* Create temporary local file if we don't have one or server
			*!* does not support resume:
			If File(m.lcTempFile) = FALSE Or m.lnBytesComplete = 0 Then
				Strtofile("", m.lcTempFile, 0)
			Endif
		
			*!* Open local temp file:
			m.lnLocalFileHandle = ctlFopen(m.lcTempFile, 2)
		
			*!* Move file pointer to end of file:
			ctlFseek(m.lnLocalFileHandle, 0, FILE_END)
		Endif
		
		With This.FtpTransferInfo
			.FtpRemoteFile 		= m.lcRemoteFile
			.FtpBytesTotal 		= m.lnBytesTotal
			.FtpBytesComplete 	= m.lnBytesComplete
			.FtpBytesLeft 		= m.lnBytesLeft
			.FtpBytesSpeed 		= m.lnBytesSpeed
			.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
			.FtpTimeElapsed 	= m.lnTimeElapsed
			.FtpTimeLeft 		= m.lnTimeLeft
			.FtpStatus			= FALSE
		Endwith
		
		Raiseevent(This, "FtpTransferStart")
		
		*!*	This._InternetSetOption(m.lnRemoteFileHandle, INTERNET_OPTION_READ_BUFFER_SIZE , 1024*512)
		*!*	vValue = 0
		*!*	This._InternetQueryOption(m.lnRemoteFileHandle, INTERNET_OPTION_READ_BUFFER_SIZE , @vValue)
		*!*	?vValue
		
		
		*!* Enter loop where we download file chunks:
		Do While TRUE
		
			*!* This we use to calculate time it takes to read a file chunk
			m.lnReadTimeStart = apiGetTickCount()
		
			m.lnApiRetVal = apiInternetReadFile( ;
				m.lnRemoteFileHandle, ;
				@m.lcReadBuffer, ;
				m.lnReadBufferSize, ;
				@m.lnNumberOfBytesRead)
		
			If m.lnApiRetVal = 0 Then
				This._GetLastError("InternetReadFile")
				m.llRetVal = FALSE
			Else
				m.llRetVal = TRUE
			Endif
		
			*!* This so user can cancel download
			DoEvents
		
			If This.FtpTransferPaused = TRUE Then
				m.llRetVal = FALSE
			Endif
		
			If This.FtpTransferCancelled = TRUE Then
				m.llRetVal = FALSE
			Endif
		
			If m.lnApiRetVal <> 0 Then
				*!* Save data to temp file
				If m.llSaveToFile = TRUE Then
					ctlFwrite(m.lnLocalFileHandle, Left(m.lcReadBuffer, m.lnNumberOfBytesRead))
				Else
					*!* 16711680 bytes is the maximum size of a string in VFP:
					If m.lnBytesRead + m.lnNumberOfBytesRead > VFP_MAX_STRING_SIZE Then
						m.lnNumberOfBytesRead = VFP_MAX_STRING_SIZE - m.lnBytesRead
						m.llRetVal = FALSE
					Endif
		
					This.FtpFileData = This.FtpFileData + Left(m.lcReadBuffer, m.lnNumberOfBytesRead)
				Endif
		
				*!* Here we resize read buffer so DoEvents is run every _DOEVENTS_INTERVAL milliseconds
				*!* This depends on download speed
		
				*!* Calculate time it takes to read a file chunk:
				m.lnReadTime = apiGetTickCount() - m.lnReadTimeStart
		
				*!* Check for apiGetTickCount overflow after 49,7 days:
				If m.lnReadTime < 0 Then
					m.lnReadTime = 0xffffffff - m.lnReadTimeStart + apiGetTickCount()
				Endif
		
				*!* We want a _DOEVENTS_INTERVAL milliseconds between each call:
		
				*!* Adjust read buffer size downward
				If m.lnReadTime > _DOEVENTS_INTERVAL * 2 Then
					m.lnReadBufferSize = m.lnReadBufferSize / 2
				Endif
		
				*!* Adjust read buffer size upward
				If m.lnReadTime < _DOEVENTS_INTERVAL Then
					m.lnReadBufferSize = m.lnReadBufferSize * 2
				Endif
		
				*!* Limit read buffer size:
				m.lnReadBufferSize = Max(m.lnReadBufferSize, _MIN_READ_BUFFER_SIZE)
				m.lnReadBufferSize = Min(m.lnReadBufferSize, _MAX_READ_BUFFER_SIZE )
				m.lcReadBuffer = Space(m.lnReadBufferSize)
		
				*!* Application.StatusBar = m.lnReadBufferSize
				*!* Update byte counters:
				m.lnBytesRead = m.lnBytesRead + m.lnNumberOfBytesRead
				m.lnBytesComplete = m.lnBytesComplete + m.lnNumberOfBytesRead
		
				*!* Prevent negative values
				m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)
		
				*!* Update time counters:
				m.lnTimeElapsed = apiGetTickCount() - m.lnTimeStart
		
				*!* Check for apiGetTickCount overflow after 49,7 days:
				If m.lnTimeElapsed < 0 Then
					m.lnTimeElapsed = 0xffffffff - m.lnTimeStart + apiGetTickCount()
				Endif
		
				*!* Convert from milliseconds to seconds:
				m.lnTimeElapsed = m.lnTimeElapsed / 1000
		
				*!* Update average download speed:
				If m.lnTimeElapsed > 0 Then
					m.lnBytesSpeed = m.lnBytesRead / m.lnTimeElapsed
				Endif
		
				*!* Update estimated time left counter:
				If m.lnBytesSpeed > 0 Then
					m.lnTimeLeft = m.lnBytesLeft / m.lnBytesSpeed
				Else
					m.lnTimeLeft = 0
				Endif
		
				If m.lnUpdateTime >= _UPDATE_UI_INTERVAL Then
		
					m.lnTimeElapsed = Round(m.lnTimeElapsed, 0)
					m.lnBytesSpeed = Round(m.lnBytesSpeed, 0)
					m.lnTimeLeft = Round(m.lnTimeLeft, 0)
		
					With This.FtpTransferInfo
						.FtpRemoteFile 		= m.lcRemoteFile
						.FtpBytesTotal 		= m.lnBytesTotal
						.FtpBytesComplete 	= m.lnBytesComplete
						.FtpBytesLeft 		= m.lnBytesLeft
						.FtpBytesSpeed 		= m.lnBytesSpeed
						.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
						.FtpTimeElapsed 	= m.lnTimeElapsed
						.FtpTimeLeft 		= m.lnTimeLeft
						.FtpStatus			= FALSE
					Endwith
		
					Raiseevent(This, "FtpTransfer")
					m.lnUpdateTime = 0
				Endif
		
				m.lnUpdateTime = m.lnUpdateTime + m.lnReadTime
		
			Endif
		
			*!* If InternetReadFile has no more data
			If m.lnNumberOfBytesRead = 0 Then
				Exit
			Endif
		
			If m.llRetVal = FALSE Then
				Exit
			Endif
		
		Enddo
		
		*!* Last Update of counters:
		With This.FtpTransferInfo
			.FtpRemoteFile 		= m.lcRemoteFile
			.FtpBytesTotal 		= m.lnBytesTotal
			.FtpBytesComplete 	= m.lnBytesComplete
			.FtpBytesLeft 		= m.lnBytesLeft
			.FtpBytesSpeed 		= m.lnBytesSpeed
			.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
			.FtpTimeElapsed 	= m.lnTimeElapsed
			.FtpTimeLeft 		= m.lnTimeLeft
			.FtpStatus			= FALSE
		Endwith
		
		Raiseevent(This, "FtpTransfer")
		
		*!* Close temp file:
		If m.llSaveToFile = TRUE Then
			ctlfClose(m.lnLocalFileHandle)
		Endif
		
		*!* If download was cancelled:
		If This.FtpTransferCancelled = TRUE Then
			If m.llSaveToFile = TRUE Then
				Erase (m.lcTempFile)
			Else
				This.FtpFileData = ""
			Endif
		Endif
		
		*!* FTP PROTOCOL SPECIFIC
		*!* Close file handle
		This.hFile = This._InternetCloseHandle(This.hFile)
		
		*!* Get the last response from server:
		This._ClearLastError()
		This._GetLastResponse("FtpReadFile")
		
		*!* If response is code 226 Transfer OK:
		If This.FtpResponseCode = 226 Then
			m.llRetVal = TRUE
		Else
			m.llRetVal = FALSE
		Endif
		
		If m.llSaveToFile = TRUE And m.llRetVal = TRUE Then
			*!* Delete previous local file:
			If File(m.lcLocalFile) Then
				Erase (m.lcLocalFile)
			Endif
		
			*!* Rename ".part" temp file to local file:
			Rename (m.lcTempFile) To (m.lcLocalFile)
		Endif
		
		With This.FtpTransferInfo
			.FtpRemoteFile 		= m.lcRemoteFile
			.FtpBytesTotal 		= m.lnBytesTotal
			.FtpBytesComplete 	= m.lnBytesComplete
			.FtpBytesLeft 		= m.lnBytesLeft
			.FtpBytesSpeed 		= m.lnBytesSpeed
			.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
			.FtpTimeElapsed 	= m.lnTimeElapsed
			.FtpTimeLeft 		= m.lnTimeLeft
			.FtpStatus			= m.llRetVal
		Endwith
		
		Raiseevent(This, "FtpTransferEnd")
		
		Return m.llRetVal
		
		
		
	ENDPROC

	PROCEDURE ftpreadurl
		*!* FtpReadURL(cUrl, [cLocalFile])
		
		Lparameters m.tcUrl As String, m.tcLocalFile As String
		
		Local ;
			lcRemoteFile As String, ;
			llRetVal As Boolean
		
		m.llRetVal = This.FtpOpen(m.tcUrl)
		
		If m.llRetVal = TRUE Then
			
			m.lcRemotefile = This.UrlPath + This.UrlExtraInfo
		
			m.llRetVal = This.FtpReadFile(m.lcRemotefile, m.tcLocalFile)
		
			This.FtpClose()
		
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpremovedirectory		&& Removes the specified directory on the FTP server.
		*!* FtpRemoveDirectory(cDirectory)
		
		Lparameters m.tcDirectory As String
		
		Local ;
			lcDirectory as String, ;
			lcFunction As String, ;
			lnApiRetVal as Integer, ;
			llRetVal As Boolean
		
		If Vartype(m.tcDirectory) = T_CHARACTER Then
			m.lcDirectory = Alltrim(m.tcDirectory) + NULA
		Else
			m.lcDirectory = "" + NULA
		Endif
		
		m.lnApiRetVal = apiFtpRemoveDirectory(This.hConnect, m.lcDirectory)
		
		m.lcFunction = "FtpRemoveDirectory"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftprenamefile
		*!* FtpRenameFile(cOldFileName, cNewFileName)
		
		Lparameters m.tcOldFileName As String, m.tcNewFileName As String
		
		Local ;
			lcOldFileName, ;
			lcNewFileName, ;
			lnApiRetVal As Integer, ;
			lcFunction As String, ;
			llRetVal As Boolean
		
		If Vartype(m.tcOldFileName) <> T_CHARACTER ;
				OR Vartype(m.tcNewFileName) <> T_CHARACTER Then
			Return FALSE
		Endif
		
		m.lcOldFileName =  This._AddPath(m.tcOldFileName ) + NULA
		m.lcNewFileName =  This._AddPath(m.tcNewFileName ) + NULA
		
		m.lnApiRetVal = apiFtpRenameFile( ;
			This.hConnect, ;
			m.lcOldFileName, ;
			m.lcNewFileName)
		
		m.lcFunction = "FtpRenameFile"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftpresponse
		*!* This event gets fired every time there is a new FtpResponseCode
	ENDPROC

	PROCEDURE ftpsetcurrentdirectory		&& Changes to a different working directory on the FTP server.
		*!* FtpSetCurrentDirectory(cDirectory)
		
		Lparameters m.tcDirectory As String
		
		Local ;
			lcDirectory As String, ;
			lcFunction As String, ;
			lnApiRetVal As Integer, ;
			llRetVal As Boolean
		
		If Vartype(m.tcDirectory) = T_CHARACTER Then
			m.lcDirectory = Alltrim(m.tcDirectory) + NULA
		Else
			m.lcDirectory = "" + NULA
		Endif
		
		m.lnApiRetVal = apiFtpSetCurrentDirectory(This.hConnect, m.lcDirectory)
		
		m.lcFunction = "FtpSetCurrentDirectory"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE ftptransfer
		*!* FtpTransfer()
		*!* Use this event to update your update feedback
		
		
	ENDPROC

	PROCEDURE ftptransferend
		*!* FtpTransferEnd()
		*!* Use this event to finalize your update feedback
		
	ENDPROC

	PROCEDURE ftptransferstart
		*!* FtpTransferStart()
		*!* Use this event to setup your update feedback
		
		
	ENDPROC

	PROCEDURE ftpwritefile
		*!* FtpWriteFile(cLocalFile, cRemoteFile, lResume)
		
		#Define _MIN_WRITE_BUFFER_SIZE 1024
		#Define _MAX_WRITE_BUFFER_SIZE 1024 * 1024
		
		#Define _DOEVENTS_INTERVAL 200
		#Define _UPDATE_UI_INTERVAL 1000
		
		Lparameters m.tcRemoteFile As String, m.tcLocalFile As String, m.tlResume As Boolean
		
		*!* Reset Cancel/Pause flags to false:
		This.FtpTransferCancelled = FALSE
		This.FtpTransferPaused    = FALSE
		
		If Vartype(m.tcLocalFile) <> T_CHARACTER Then
		    Return FALSE
		Endif
		
		If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
		    Return FALSE
		Endif
		
		Local ;
		    lcLocalFile As String, ;
		    lcRemoteFile As String, ;
		    lnBytesTotal As Integer, ;
		    lnBytesComplete As Integer, ;
		    lnLocalFileHandle As Integer, ;
		    lnRemoteFileHandle As Integer, ;
		    llRetVal As boolean
		
		Local ;
		    lcWriteBuffer As String, ;
		    lnWriteBufferSize As Integer, ;
		    lnNumberOfBytesWriten As Integer, ;
		    lnApiRetVal As Integer
		
		Local ;
		    lnBytesWriten As Integer, ;
		    lnBytesLeft As Integer ,;
		    lnBytesSpeed As Integer , ;
		    lnWriteTimeStart As Integer, ;
		    lnWriteTime As Integer, ;
		    lnUpdateTime As Integer, ;
		    lnTimeStart As Integer, ;
		    lnTimeElapsed As Integer, ;
		    lnTimeLeft As Integer
		
		m.llRetVal = TRUE
		
		m.lcRemoteFile = m.tcRemoteFile
		m.lcRemoteFile = This._AddPath(m.lcRemoteFile)
		
		m.lcLocalFile = Alltrim(m.tcLocalFile)
		
		m.lnLocalFileHandle = 0
		m.lnRemoteFileHandle = 0
		m.lnBytesComplete = 0
		
		*!* get size of local file:
		m.lnBytesTotal = ctlFsize(m.lcLocalFile)
		
		*!* if we have to append data to remote file
		If m.tlResume = TRUE Then
		    m.lnBytesComplete = This.FtpGetFileSize(m.lcRemoteFile)
		    If m.lnBytesComplete = -1 Then
		        m.lnBytesComplete = 0
		    Endif
		
		    *!* Send REST "Resume" command to ftp server, this has to
		    *!* be done BEFORE we open the remote file
		    If m.lnBytesComplete > 0 Then
		        If This.FtpCommand("REST " + Transform(m.lnBytesComplete)) = TRUE Then
		
		            If This.FtpResponseCode <> 350
		                *!* Rest command NOT supported
		                m.lnBytesComplete = 0
		            Endif
		        Else
		            *!* FtpCommand failed:
		            m.lnBytesComplete = 0
		        Endif
		
		    Endif
		Endif
		
		*!* Try to open remote file:
		If This._FtpOpenFile(m.lcRemoteFile, GENERIC_WRITE) = FALSE
		    Return FALSE
		Endif
		
		m.lnRemoteFileHandle = This.hFile
		
		If m.lnRemoteFileHandle = 0 Then
		    Return FALSE
		Endif
		
		*!* Open local file:
		m.lnLocalFileHandle = ctlfOpen(m.lcLocalFile, 0)
		
		*!* Move local file pointer:
		ctlFseek(m.lnLocalFileHandle, m.lnBytesComplete, FILE_BEGIN)
		
		*!* Init Counter vars:
		m.lnWriteTimeStart = 0
		m.lnWriteTime = 0
		m.lnUpdateTime = _UPDATE_UI_INTERVAL
		
		m.lnTimeStart = apiGetTickCount()
		m.lnTimeElapsed = 0
		m.lnTimeLeft = 0
		
		*!* Prevent negative values:
		m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)
		
		m.lnBytesWriten = 0
		m.lnBytesSpeed = 0
		
		With This.FtpTransferInfo
		    .FtpRemoteFile 		= m.lcRemoteFile
		    .FtpBytesTotal 		= m.lnBytesTotal
		    .FtpBytesComplete 	= m.lnBytesComplete
		    .FtpBytesLeft 		= m.lnBytesLeft
		    .FtpBytesSpeed 		= m.lnBytesSpeed
		    .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
		    .FtpTimeElapsed 	= m.lnTimeElapsed
		    .FtpTimeLeft 		= m.lnTimeLeft
		    .FtpStatus			= FALSE
		Endwith
		
		Raiseevent(This, "FtpTransferStart")
		
		m.lnWriteBufferSize = _MIN_WRITE_BUFFER_SIZE
		
		*!* Enter loop where we download file chunks:
		Do While TRUE
		
		    *!* This we use to calculate time it takes to Write a file chunk
		    m.lnWriteTimeStart = apiGetTickCount()
		
		    *!* Read chunk from local file:
		    m.lcWriteBuffer = ctlFread(m.lnLocalFileHandle, m.lnWriteBufferSize)
		    m.lnWriteBufferSize = Len(m.lcWriteBuffer)
		    m.lnNumberOfBytesWriten = 0
		
		    If m.lnWriteBufferSize = 0 Then
		        Exit
		    Endif
		
		    m.lnApiRetVal = apiInternetWriteFile( ;
		        m.lnRemoteFileHandle, ;
		        m.lcWriteBuffer, ;
		        m.lnWriteBufferSize, ;
		        @m.lnNumberOfBytesWriten)
		
		    If m.lnApiRetVal = 0 Then
		        This._GetLastError("InternetWriteFile")
		        m.llRetVal = FALSE
		    Else
		        m.llRetVal = TRUE
		    Endif
		
		    *!* This so user can cancel download
		    DoEvents
		
		    If This.FtpTransferPaused = TRUE Then
		        m.llRetVal = FALSE
		    Endif
		
		    If This.FtpTransferCancelled = TRUE Then
		        m.llRetVal = FALSE
		    Endif
		
		    If m.lnApiRetVal <> 0 Then
		        *!* Save data to temp file
		
		        *!* Here we resize Write buffer so DoEvents is run every _DOEVENTS_INTERVAL milliseconds
		        *!* This depends on download speed
		
		        *!* Calculate time it takes to Write a file chunk:
		        m.lnWriteTime = apiGetTickCount() - m.lnWriteTimeStart
		
		        *!* Check for apiGetTickCount overflow after 49,7 days:
		        If m.lnWriteTime < 0 Then
		            m.lnWriteTime = 0xffffffff - m.lnWriteTimeStart + apiGetTickCount()
		        Endif
		
		        *!* We want a _DOEVENTS_INTERVAL milliseconds between each call:
		
		        *!* Adjust Write buffer size downward
		        If m.lnWriteTime > _DOEVENTS_INTERVAL * 2 Then
		            m.lnWriteBufferSize = m.lnWriteBufferSize / 2
		        Endif
		
		        *!* Adjust Write buffer size upward
		        If m.lnWriteTime < _DOEVENTS_INTERVAL Then
		            m.lnWriteBufferSize = m.lnWriteBufferSize * 2
		        Endif
		
		        *!* Limit Write buffer size:
		        m.lnWriteBufferSize = Max(m.lnWriteBufferSize, _MIN_WRITE_BUFFER_SIZE)
		        m.lnWriteBufferSize = Min(m.lnWriteBufferSize, _MAX_WRITE_BUFFER_SIZE )
		
		        *!* Application.StatusBar = m.lnWriteBufferSize
		        *!* Update byte counters:
		        m.lnBytesWriten = m.lnBytesWriten + m.lnNumberOfBytesWriten
		        m.lnBytesComplete = m.lnBytesComplete + m.lnNumberOfBytesWriten
		
		        *!* Prevent negative values
		        m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)
		
		        *!* Update time counters:
		        m.lnTimeElapsed = apiGetTickCount() - m.lnTimeStart
		
		        *!* Check for apiGetTickCount overflow after 49,7 days:
		        If m.lnTimeElapsed < 0 Then
		            m.lnTimeElapsed = 0xffffffff - m.lnTimeStart + apiGetTickCount()
		        Endif
		
		        *!* Convert from milliseconds to seconds:
		        m.lnTimeElapsed = m.lnTimeElapsed / 1000
		
		        *!* Update average download speed:
		        If m.lnTimeElapsed > 0 Then
		            m.lnBytesSpeed = m.lnBytesWriten / m.lnTimeElapsed
		        Endif
		
		        *!* Update estimated time left counter:
		        If m.lnBytesSpeed > 0 Then
		            m.lnTimeLeft = m.lnBytesLeft / m.lnBytesSpeed
		        Else
		            m.lnTimeLeft = 0
		        Endif
		
		        If m.lnUpdateTime >= _UPDATE_UI_INTERVAL Then
		
		            m.lnTimeElapsed = Round(m.lnTimeElapsed, 0)
		            m.lnBytesSpeed = Round(m.lnBytesSpeed, 0)
		            m.lnTimeLeft = Round(m.lnTimeLeft, 0)
		
		            With This.FtpTransferInfo
		                .FtpRemoteFile 		= m.lcRemoteFile
		                .FtpBytesTotal 		= m.lnBytesTotal
		                .FtpBytesComplete 	= m.lnBytesComplete
		                .FtpBytesLeft 		= m.lnBytesLeft
		                .FtpBytesSpeed 		= m.lnBytesSpeed
		                .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
		                .FtpTimeElapsed 	= m.lnTimeElapsed
		                .FtpTimeLeft 		= m.lnTimeLeft
		                .FtpStatus			= FALSE
		            Endwith
		
		            Raiseevent(This, "FtpTransfer")
		            m.lnUpdateTime = 0
		        Endif
		
		        m.lnUpdateTime = m.lnUpdateTime + m.lnWriteTime
		
		    Endif
		
		    *!* If InternetWriteFile has no more data
		    If m.lnNumberOfBytesWriten = 0 Then
		        Exit
		    Endif
		
		    If m.llRetVal = FALSE Then
		        Exit
		    Endif
		
		Enddo
		
		*!* Last Update of counters:
		With This.FtpTransferInfo
		    .FtpRemoteFile 		= m.lcRemoteFile
		    .FtpBytesTotal 		= m.lnBytesTotal
		    .FtpBytesComplete 	= m.lnBytesComplete
		    .FtpBytesLeft 		= m.lnBytesLeft
		    .FtpBytesSpeed 		= m.lnBytesSpeed
		    .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
		    .FtpTimeElapsed 	= m.lnTimeElapsed
		    .FtpTimeLeft 		= m.lnTimeLeft
		    .FtpStatus			= FALSE
		Endwith
		
		Raiseevent(This, "FtpTransfer")
		
		*!* Close local file:
		
		ctlFclose(m.lnLocalFileHandle)
		
		*!* FTP PROTOCOL SPECIFIC
		*!* Close file handle
		This.hFile = This._InternetCloseHandle(This.hFile)
		
		*!* Get the last response from server:
		This._ClearLastError()
		This._GetLastResponse("FtpWriteFile")
		
		*!* If response is code 226 Transfer OK:
		If This.FtpResponseCode = 226 Then
		    m.llRetVal = TRUE
		Else
		    m.llRetVal = FALSE
		Endif
		
		*!* Delete remote file if transfer was cancelled:
		If This.FtpTransferCancelled = TRUE Then
		    This.FtpDeleteFile(m.lcRemoteFile)
		Endif
		
		With This.FtpTransferInfo
		    .FtpRemoteFile 		= m.lcRemoteFile
		    .FtpBytesTotal 		= m.lnBytesTotal
		    .FtpBytesComplete 	= m.lnBytesComplete
		    .FtpBytesLeft 		= m.lnBytesLeft
		    .FtpBytesSpeed 		= m.lnBytesSpeed
		    .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
		    .FtpTimeElapsed 	= m.lnTimeElapsed
		    .FtpTimeLeft 		= m.lnTimeLeft
		    .FtpStatus			= m.llRetVal
		Endwith
		
		Raiseevent(This, "FtpTransferEnd")
		
		Return m.llRetVal
		
		
		
	ENDPROC

	PROCEDURE Init
		*!* Init
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		This._AddObjects()
		This._AddProperties()
		This._SetProperties()
		
	ENDPROC

	PROCEDURE internetclose
		*!* WininetClose()
		
		*!* Closes an open hInternet handle, ends use of wininet
		
		*!* Clear password cache:
		This._InternetSetOption(This.hInternet, INTERNET_OPTION_END_BROWSER_SESSION, 0)
		
		This.hInternet = This._InternetCloseHandle(This.hInternet)
		
	ENDPROC

	PROCEDURE internetopen
		*!* InternetOpen()
		
		*!* Initializes the use of wininet functions
		
		*!* If we already have an Internet Handle, close it
		This.InternetClose()
		
		Local ;
			lcAgent As String, ;
			lnAccessType As Integer, ;
			lcProxyName As String, ;
			lcProxyBypass As String, ;
			lnFlags As Integer, ;
			lnApiRetVal As Integer, ;
			lcFunction as String, ;
			llRetVal As Boolean
		
		m.lcAgent 		= Alltrim(This.InternetUserAgent)
		m.lnAccessType 	= INTERNET_OPEN_TYPE_PRECONFIG
		m.lcProxyName 	= ""
		m.lcProxyBypass = ""
		
		*!* Determine if direct connection or proxy:
		
		*!*	#Define INTERNET_OPEN_TYPE_DIRECT						1
		*!*	#Define INTERNET_OPEN_TYPE_PRECONFIG					0
		*!*	#Define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY	4
		*!*	#Define INTERNET_OPEN_TYPE_PROXY						3
		
		Do Case
		
		Case This.InternetAccessType = INTERNET_OPEN_TYPE_PRECONFIG
			m.lnAccessType = INTERNET_OPEN_TYPE_PRECONFIG
		
		Case This.InternetAccessType = INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
			m.lnAccessType = INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
		
		Case This.InternetAccessType = INTERNET_OPEN_TYPE_DIRECT
			m.lnAccessType = INTERNET_OPEN_TYPE_DIRECT
		
		Case This.InternetAccessType = INTERNET_OPEN_TYPE_PROXY
		
			If Empty(This.InternetProxyName) Then
				m.lnAccessType = INTERNET_OPEN_TYPE_PRECONFIG
			Else
				m.lnAccessType = INTERNET_OPEN_TYPE_PROXY
				m.lcProxyName = Alltrim(This.InternetProxyName)
				m.lcProxyBypass = Alltrim(This.InternetProxyBypass)
			Endif
		
		Endcase
		
		m.lnFlags = This._GetFlagsInternet()
		
		m.lcAgent = m.lcAgent + NULA
		m.lcProxyName = m.lcProxyName + NULA
		m.lcProxyBypass = m.lcProxyBypass + NULA
		
		m.lnApiRetVal = apiInternetOpen( ;
			m.lcAgent, ;
			m.lnAccessType, ;
			m.lcProxyName, ;
			m.lcProxyBypass, ;
			m.lnFlags)
		
		This.hInternet = m.lnApiRetVal
		
		m.lcFunction = "InternetOpen"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
		Endif
		
		Return m.llRetVal
		
		
	ENDPROC

	PROCEDURE _addobjects
		*!* _AddObjects()
		
		*!* Add File Info object
		*This.AddProperty("oWin32FindData", Createobject("ctlStrwin32FindData"))
		
		This.AddProperty("FtpTransferInfo", Createobject("Empty"))
		
		AddProperty(This.FtpTransferInfo, "FtpRemoteFile", "")
		AddProperty(This.FtpTransferInfo, "FtpBytesTotal", 0)
		AddProperty(This.FtpTransferInfo, "FtpBytesComplete", 0)
		AddProperty(This.FtpTransferInfo, "FtpBytesLeft", 0)
		AddProperty(This.FtpTransferInfo, "FtpBytesPercent", 0)
		AddProperty(This.FtpTransferInfo, "FtpBytesSpeed", 0)
		AddProperty(This.FtpTransferInfo, "FtpTimeTotal", 0)
		AddProperty(This.FtpTransferInfo, "FtpTimeElapsed", 0)
		AddProperty(This.FtpTransferInfo, "FtpTimeLeft", 0)
		AddProperty(This.FtpTransferInfo, "FtpStatus", FALSE)
		
		This.AddProperty("FtpFileInfo", Createobject("Empty"))
		
		With This
			AddProperty(.FtpFileInfo, "FileName", "")
			AddProperty(.FtpFileInfo, "FilePath", "")
			AddProperty(.FtpFileInfo, "FileShortName", "")
			AddProperty(.FtpFileInfo, "FileSize", 0)
			AddProperty(.FtpFileInfo, "FileCreationTime", 0)
			AddProperty(.FtpFileInfo, "FileLastAccessTime", 0)
			AddProperty(.FtpFileInfo, "FileLastWriteTime", 0)
			AddProperty(.FtpFileInfo, "FileAttribute", Createobject("Empty"))
			AddProperty(.FtpFileInfo, "Adir1", 0)
			AddProperty(.FtpFileInfo, "Adir2", 0)
			AddProperty(.FtpFileInfo, "Adir3", 0)
			AddProperty(.FtpFileInfo, "Adir4", 0)
			AddProperty(.FtpFileInfo, "Adir5", 0)
		Endwith
		
		With This.FtpFileInfo
			AddProperty(.FileAttribute, "Archive", FALSE)
			AddProperty(.FileAttribute, "Compressed", FALSE)
			AddProperty(.FileAttribute, "Directory", FALSE)
			AddProperty(.FileAttribute, "Encrypted", FALSE)
			AddProperty(.FileAttribute, "Hidden", FALSE)
			AddProperty(.FileAttribute, "Normal", FALSE)
			AddProperty(.FileAttribute, "NotContentIndexed", FALSE)
			AddProperty(.FileAttribute, "Offline", FALSE)
			AddProperty(.FileAttribute, "ReadOnly", FALSE)
			AddProperty(.FileAttribute, "ReparsePoint", FALSE)
			AddProperty(.FileAttribute, "SparseFile", FALSE)
			AddProperty(.FileAttribute, "System", FALSE)
			AddProperty(.FileAttribute, "Temporary", FALSE)
			AddProperty(.FileAttribute, "Virtual", FALSE)
		Endwith
		
	ENDPROC

	PROCEDURE _addpath
		*!* _AddPath(cFileName)
		
		*!* Adds the current ftp directory path to a filename
		
		Lparameters m.tcFileName As String
		
		Local ;
			lcFileName As String, ;
			lcFilePath As String, ;
			lcFileName As String, ;
			lcCurrentDirectory As String
		
		m.lcFileName = Alltrim(m.tcFileName)
		m.lcFilePath = Justpath(m.lcFileName)
		m.lcFileName = Justfname(m.lcFileName)
		
		*!* if no path in lcFilePath, use current FTP directory:
		If Empty(m.lcFilePath) Then
		
			m.lcCurrentDirectory = ""
		
			If This.FtpGetCurrentDirectory(@m.lcCurrentDirectory) = TRUE Then
				m.lcFilePath = This.FtpAddfs(m.lcCurrentDirectory)
			Else
				m.lcFilePath = "/"
			Endif
		
		Else
			*!* Add a forward slash if needed at the end of lcFilePath:
			m.lcFilePath = This.FtpAddfs(m.lcFilePath)
		Endif
		
		m.lcFileName =  m.lcFilePath + m.lcFileName
		
		Return m.lcFileName
		
	ENDPROC

	PROCEDURE _addproperties
		*!* Save Kernel32.dll module handle:
		This.AddProperty("_hKernel32", apiGetModuleHandle("kernel32.dll"))
		
		*!* Save WinInet.dll module handle:
		This.AddProperty("_hWinInet", apiGetModuleHandle("wininet.dll"))
		
		*!* Indicates if the Destroy event is happening:
		This.AddProperty("_Destroying", FALSE)
		
	ENDPROC

	PROCEDURE _addtoarray
		*!* _AddToArray()
		
		*!* This method is called by FtpDirToArray, adds one array row to the FtpFiles array
		*!* The file info is stored in the FtpFileInfo object, and was filled by _FtpFindFile()
		
		*!* The FtpFiles array mimics the array created by the Adir VFP function, with the
		*!* only difference that the complete file spec is stored in the first column, file path
		*!* and name. Also "/" is used instead of "\", as "/" is used in FTP servers.
		
		Lparameters m.tnIndex As Integer
		
		If m.tnIndex = 0 Then
			Dimension This.FtpFiles(1, 5)
			This.FtpFiles(1, 1) = ".."
			This.FtpFiles(1, 2) = 0
			This.FtpFiles(1, 3) = Date()
			This.FtpFiles(1, 4) = This.FormatSeconds(Seconds())
			This.FtpFiles(1, 5) = "....D"
		
		Else
		
			m.tnIndex = m.tnIndex + 1
		
			Dimension This.FtpFiles(m.tnIndex, 5)
		
			This.FtpFiles(m.tnIndex, 1) = This.FtpFileInfo.Adir1
			This.FtpFiles(m.tnIndex, 2) = This.FtpFileInfo.Adir2
			This.FtpFiles(m.tnIndex, 3) = This.FtpFileInfo.Adir3
			This.FtpFiles(m.tnIndex, 4) = This.FtpFileInfo.Adir4
			This.FtpFiles(m.tnIndex, 5) = This.FtpFileInfo.Adir5
		
		Endif
		
		
	ENDPROC

	PROCEDURE _clearlasterror
		*!* _ClearLastError()
		
		This.FtpErrorFunction = ""
		This.FtpErrorCode	 = 0
		This.FtpErrorText	 = ""
		
		
	ENDPROC

	PROCEDURE _clearlastresponse
		*!* _ClearLastResponse()
		
		This.FtpResponseFunction = ""
		This.FtpResponseCode	 = 0
		This.FtpResponseText	 = ""
	ENDPROC

	PROCEDURE _fillftpfileinfo
		
		
		
	ENDPROC

	PROCEDURE _ftpfindfile
		*!* _FtpFindFile(cFileSkeleton)
		
		*!* This method is called by FtpDirToArray as FtpGetFileInfo
		*!* cFileSkeleton ALWAYS includes the full path at this stage
		
		*!* _FtpFindFile encapsulates the use of FtpFindFirstFile and the following
		*!* InternetFindNextFile calls into one Method
		
		*!* FtpFindFile just encapsulates a simple LIST command to the FTP server.
		*!* subsequent calls to InternetFindNextFile gives us that list one by one
		*!* This is an attempt by MS to emulate the functions for local files
		
		*!* WARNING! The file size returned by these functions is limited to 4GB
		
		Lparameters m.tcFileSkeleton As String
		
		m.tcFileSkeleton = Alltrim(m.tcFileSkeleton)
		
		Local ;
			lnApiRetVal As Integer, ;
			loWin32FindData As _WIN32_FIND_DATA, ;
			lnFlags As Integer, ;
			lnContext As Integer, ;
			lcSearchFile As String, ;
			lnLastError As Integer, ;
			lnRetVal As Integer, ;
			lnFileAttributes As Integer
		
		m.lnLastError = 0
		
		m.loWin32FindData =  Createobject("_WIN32_FIND_DATA")
		
		*!* If we do not have a FtpFindFirstFile handle, get one:
		If This.hFind = 0 Then
		
			m.lcSearchFile = m.tcFileSkeleton + NULA
		
			*!* Set flags:
			m.lnFlags = This._GetFlags()
		
			m.lnContext = 0
		
			m.lnApiRetVal = apiFtpFindFirstFile( ;
				This.hConnect, ;
				m.lcSearchFile, ;
				m.loWin32FindData.Address, ;
				m.lnFlags, ;
				m.lnContext)
		
			This.hFind = m.lnApiRetVal
		
			*!* This is here so we get the dir list transfer msg from the FTP server,
			This._ClearLastError()
			This._GetLastResponse("FtpFindFirstFile")
		
			If m.lnApiRetVal = 0
				m.lnLastError = apiGetLastError()
				This._GetLastError("FtpFindFirstFile")
			Endif
		
		Else
			*!* Just get the next file
			m.lnApiRetVal = apiInternetFindNextFile(This.hFind, m.loWin32FindData.Address)
		
			If m.lnApiRetVal = 0
				m.lnLastError = apiGetLastError()
				This._GetLastError("InternetFindNextFile")
			Endif
		
		Endif
		
		If m.lnApiRetVal = 0 Then
			*!* Close hFind Handle:
			This.hFind = This._InternetCloseHandle(This.hFind)
		
			If m.lnLastError = ERROR_NO_MORE_FILES
				*!* Return 0 when there are no more files
				m.lnRetVal = 0
			Else
				*!* Return -1 if there was an error
				m.lnRetVal = -1
			Endif
		Else
			*!* Return 1 if there is a file
			m.lnRetVal = 1
		Endif
		
		*!*	If m.lnRetVal = 1 Then
		*!*		*!* Copy returned structure and path to WIN32_FIND_DATA object
		*!*		m.loWin32FindData.Value = m.lcWin32FindData
		*!*		*	This.FtpFileInfo._SetStructure(m.lcWin32FindData, This.FtpAddfs(Justpath(m.tcFileSkeleton)))
		*!*	Endif
		
		With This.FtpFileInfo
		
			.FilePath = This.FtpAddfs(Justpath(m.tcFileSkeleton))
			.FileName = m.loWin32FindData.cFileName
			.FileShortName = m.loWin32FindData.cAlternateFileName
		
			.FileSize = m.loWin32FindData.nFileSizeHigh * 2^32 + m.loWin32FindData.nFileSizeLow
		
			If .FileSize = 0xffffffff Then
				.FileSize = This.FtpGetFileSize(.FilePath + .FileName)
			Endif
		
			.FileCreationTime 	= ctlFileTimeToDateTime(m.loWin32FindData.ftCreationTime)
			.FileLastAccessTime = ctlFileTimeToDateTime(m.loWin32FindData.ftLastAccessTime)
			.FileLastWriteTime 	= ctlFileTimeToDateTime(m.loWin32FindData.ftLastWriteTime)
		
			m.lnFileAttributes = m.loWin32FindData.dwFileAttributes
		
			.FileAttribute.Archive 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_ARCHIVE) = FILE_ATTRIBUTE_ARCHIVE)
			.FileAttribute.Compressed 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_COMPRESSED) = FILE_ATTRIBUTE_COMPRESSED)
			.FileAttribute.Directory 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY)
			.FileAttribute.Encrypted 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_ENCRYPTED) = FILE_ATTRIBUTE_ENCRYPTED)
			.FileAttribute.Hidden 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_HIDDEN) = FILE_ATTRIBUTE_HIDDEN)
			.FileAttribute.Normal 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_NORMAL) = FILE_ATTRIBUTE_NORMAL)
			.FileAttribute.NotContentIndexed	= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) = FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
			.FileAttribute.Offline 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_OFFLINE) = FILE_ATTRIBUTE_OFFLINE)
			.FileAttribute.ReadOnly 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_READONLY) = FILE_ATTRIBUTE_READONLY)
			.FileAttribute.ReparsePoint 		= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_REPARSE_POINT) = FILE_ATTRIBUTE_REPARSE_POINT)
			.FileAttribute.SparseFile 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_SPARSE_FILE) = FILE_ATTRIBUTE_SPARSE_FILE)
			.FileAttribute.System 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_SYSTEM) = FILE_ATTRIBUTE_SYSTEM)
			.FileAttribute.Temporary 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_TEMPORARY) = FILE_ATTRIBUTE_TEMPORARY)
			.FileAttribute.Virtual 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_VIRTUAL) = FILE_ATTRIBUTE_VIRTUAL)
		
		
			.Adir1 = .FilePath + .FileName
			.Adir2 = .FileSize
			.Adir3 = Ttod(.FileLastWriteTime)
		
			.Adir4 = Padl(Transform(Hour(.FileLastWriteTime)), 2, "0") + ":" ;
				+ Padl(Transform(Minute(.FileLastWriteTime)), 2, "0") + ":" ;
				+ Padl(Transform(Sec(.FileLastWriteTime)), 2, "0")
		
			.Adir5 = ""
		
			If .FileAttribute.ReadOnly Then
				.Adir5 = .Adir5 + "R"
			Else
				.Adir5 = .Adir5 + "."
			Endif
			If .FileAttribute.Archive Or .FileAttribute.Normal Then
				.Adir5 = .Adir5 + "A"
			Else
				.Adir5 = .Adir5 + "."
			Endif
			If .FileAttribute.System Then
				.Adir5 = .Adir5 + "S"
			Else
				.Adir5 = .Adir5 + "."
			Endif
			If .FileAttribute.Hidden Then
				.Adir5 = .Adir5 + "H"
			Else
				.Adir5 = .Adir5 + "."
			Endif
			If .FileAttribute.Directory Or Not .FileAttribute.Normal Then
				.Adir5 = .Adir5 + "D"
			Else
				.Adir5 = .Adir5 + "."
			Endif
		
		
		Endwith
		
		
		m.loWin32FindData = .Null.
		
		Return m.lnRetVal
		
	ENDPROC

	PROCEDURE _ftpgetfilesize
		*!* _FtpGetFileSize(cRemoteFile, @nFileSize)
		
		*!* Returns the size of a file (up to 4gb)
		
		Lparameters m.tcRemoteFile As String, m.tnFileSize As Integer
		
		Local ;
		    lnFileSizeLow As Integer, ;
		    lnFileSizeHigh As Integer, ;
		    llRetVal As Boolean
		
		If This._FtpOpenFile(m.tcRemoteFile, GENERIC_READ) = TRUE Then
		
		    m.lnFileSizeHigh = 0
		    m.lnFileSizeLow = apiFtpGetFileSize(This.hFile, @m.lnFileSizeHigh)
		    *!* ?m.lnFileSizeLow, m.lnFileSizeHigh
		    *!* Convert signed integer to unsigned:
		    If m.lnFileSizeLow < 0 Then
		        m.lnFileSizeLow = m.lnFileSizeLow + MAXDWORD + 1
		    Endif
		
		    If apiGetLastError() = NO_ERROR Then
		        m.tnFileSize = m.lnFileSizeHigh * MAXDWORD + m.lnFileSizeLow
		        m.llRetVal = TRUE
		    Else
		        m.llRetVal = FALSE
		    Endif
		
		    *!* Close file handle:
		    This.hFile = This._InternetCloseHandle(This.hFile)
		
		Else
		    m.llRetVal = FALSE
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE _ftpopenfile
		*!* _FtpOpenFile(cRemoteFile, nAccess)
		
		Lparameters m.tcRemoteFile As String, m.tnAccess As Integer
		
		*!* close open file if we have one:
		This.hFile = This._InternetCloseHandle(This.hFile)
		
		Local ;
			lcRemoteFile As String, ;
			lnAccess As Integer, ;
			lnFlags As Integer, ;
			lnContext As Integer, ;
			lnApiRetVal As Integer, ;
			lcFunction as String, ;
			llRetVal As Boolean
		
		m.lcRemoteFile = Alltrim(m.tcRemoteFile) + NULA
		m.lnAccess = m.tnAccess
		
		*!* Set flags:
		m.lnFlags = This._GetFlags()
		
		m.lnContext = 0
		
		m.lnApiRetVal = apiFtpOpenFile( ;
			This.hConnect, ;
			m.lcRemoteFile, ;
			m.lnAccess, ;
			m.lnFlags, ;
			m.lnContext)
		
		This.hFile = m.lnApiRetVal
		
		m.lcFunction = "FtpOpenFile"
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
			This._GetLastError(m.lcFunction)
		Else
			m.llRetVal = TRUE
			This._GetLastResponse(m.lcFunction, TRUE)
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE _ftpreadcommand
		*!* _FtpReadCommand
		
		*!* Reads response from FtpCommand when lExpectRespose is TRUE
		
		Local ;
			lnBytesRead, ;
			lnReadBufferSize, ;
			lcReadBuffer, ;
			lnNumberOfBytesRead, ;
			lnApiRetVal, ;
			llRetVal
		
		m.lnBytesRead = 0
		m.lnReadBufferSize = 1024
		m.lcReadBuffer = Space(m.lnReadBufferSize)
		m.lnNumberOfBytesRead = 0
		m.lnApiRetVal = 0
		
		This.FtpCommandData = ""
		
		*!* Enter loop where we download response:
		Do While TRUE
		
			m.lnApiRetVal = apiInternetReadFile( ;
				This.hFtpCommand, ;
				@m.lcReadBuffer, ;
				m.lnReadBufferSize, ;
				@m.lnNumberOfBytesRead)
		
			If m.lnApiRetVal = 0 Then
				This._GetLastError("InternetReadFile")
				m.llRetVal = FALSE
			Else
				m.llRetVal = TRUE
			Endif
		
			*!* This so user can cancel download
			DoEvents
		
			If m.lnApiRetVal <> 0 Then
				*!* 16711680 bytes is the maximum size of a string in VFP:
				If m.lnBytesRead + m.lnNumberOfBytesRead > VFP_MAX_STRING_SIZE Then
					m.lnNumberOfBytesRead = VFP_MAX_STRING_SIZE - m.lnBytesRead
					m.llRetVal = FALSE
				Endif
				This.FtpCommandData = This.FtpCommandData + Left(m.lcReadBuffer, m.lnNumberOfBytesRead)
				m.lnBytesRead = m.lnBytesRead + m.lnNumberOfBytesRead
			Endif
		
			*!* If InternetReadFile has no more data
			If m.lnNumberOfBytesRead = 0 Then
				Exit
			Endif
		
			If m.llRetVal = FALSE Then
				Exit
			Endif
		
		Enddo
		
	ENDPROC

	PROCEDURE _getflags
		*!* _GetFlags(cFunction)
		
		Lparameters m.tcFunction As String
		
		Local lnFlags As Integer
		
		m.lnFlags = 0
		
		*!* Allows a lazy cache write
		If This.FlagCacheAsync Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_CACHE_ASYNC)
		Endif
		
		*!* Returns the resource from the cache if the network request for the resource
		*!* fails due to an ERROR_INTERNET_CONNECTION_RESET or ERROR_INTERNET_CANNOT_CONNECT error
		If This.FlagCacheIfNetFail Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_CACHE_IF_NET_FAIL)
		Endif
		
		*!* Forces a reload if there is no Expires time and no LastModified time returned
		*!* from the server when determining whether to reload the item from the network.
		If This.FlagHyperlink = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_HYPERLINK)
		Endif
		
		*!* Causes a temporary file to be created if the file cannot be cached.
		If This.FlagNeedFile = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_NEED_FILE)
		Endif
		
		*!* Does not add the returned entity to the cache.
		If This.FlagNoCacheWrite = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_NO_CACHE_WRITE)
		Endif
		
		*!* Uses passive FTP semantics. Only InternetConnect and
		*!* InternetOpenUrl use this flag
		If This.FlagPassive = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_PASSIVE)
		Endif
		
		
		*!* Forces a download of the requested file, object,
		*!* or directory listing from the origin server, not from the cache
		If This.FlagReload = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_RELOAD)
		Endif
		
		*!* Reloads HTTP resources if the resource has been modified since
		*!* the last time it was downloaded. All FTP and Gopher resources are reloaded.
		If This.FlagResynchronize = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_RESYNCHRONIZE)
		Endif
		
		*!* Transfers file as binary or ASCII (FTP only).
		If This.FlagTransferBinary = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, FTP_TRANSFER_TYPE_BINARY)
		Else
			m.lnFlags = Bitor(m.lnFlags, FTP_TRANSFER_TYPE_ASCII)
		Endif
		
		Return m.lnFlags
		
	ENDPROC

	PROCEDURE _getflagsinternet
		Local lnFlags As Integer
		
		m.lnFlags = 0
		
		*!* This flags only apply to InternetOpen
		
		If This.InternetFlagAsync = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_ASYNC)
		Endif
		
		*!* Does not make network requests. All entities are returned from the cache.
		*!* If the requested item is not in the cache, a suitable error, such as
		*!* ERROR_FILE_NOT_FOUND, is returned. Only the InternetOpen function uses this flag.
		
		If This.InternetFlagFromCache = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_FROM_CACHE)
		Endif
		
		*!*	Identical to INTERNET_FLAG_FROM_CACHE. Does not make network requests.
		*!*	All entities are returned from the cache. If the requested item is not
		*!*	in the cache, a suitable error, such as ERROR_FILE_NOT_FOUND, is returned.
		*!*	Only the InternetOpen function uses this flag.
		
		If This.InternetFlagOffline = TRUE Then
			m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_OFFLINE)
		Endif
		
		Return m.lnFlags
		
	ENDPROC

	PROCEDURE _getlasterror
		*!* _GetLastError(cFunction)
		
		Lparameters m.tcFunction As String
		
		*!* We are here only because an error was raised, so we clear last response info:
		This._ClearLastResponse()
		
		Local ;
			lnErrorCode As Integer, ;
			lcErrorInfo As String, ;
			lnBuffer As Integer, ;
			lcBuffer As String, ;
			lnBufferLen As Integer, ;
			lnRetVal As Integer
		
		*!* Init vars:
		m.lnErrorCode = 0
		m.lcErrorInfo = "-"
		
		*!* Get Last error code:
		m.lnErrorCode = apiGetLastError()
		
		*!* Get last error text:
		
		*!* Initialize buffer vars:
		m.lnBuffer = 0
		m.lnBufferLen = 1024
		m.lcBuffer = Replicate(NULA, m.lnBufferLen)
		
		m.lnRetVal = apiFormatMessage( ;
			FORMAT_MESSAGE_FROM_HMODULE, ;
			This._hKernel32, ;
			m.lnErrorCode, ;
			0, ;
			@m.lcBuffer, ;
			m.lnBufferLen, ;
			0)
		
		*!* If nothing found then search in wininet.dll
		If m.lnRetVal = 0 Then
		
			m.lnRetVal = apiFormatMessage( ;
				FORMAT_MESSAGE_FROM_HMODULE, ;
				This._hWinInet, ;
				m.lnErrorCode, ;
				0, ;
				@m.lcBuffer, ;
				m.lnBufferLen, ;
				0)
		
		Endif
		
		*!* If something was found, get the text from the buffer:
		If m.lnRetVal <> 0 Then
			m.lcErrorInfo = Left(m.lcBuffer, m.lnRetVal)
		
			*!* Remove last carriage return/line feed
			If Right(m.lcErrorInfo, 2) = CRLF Then
				m.lcErrorInfo = Left(m.lcBuffer, m.lnRetVal - 2)
			Endif
		Endif
		
		This.FtpErrorFunction = m.tcFunction
		This.FtpErrorCode	 = m.lnErrorCode
		This.FtpErrorText	 = m.lcErrorInfo
		
		If This.OptionDebug = TRUE Then
			?"ErrorFunction: ", This.FtpErrorFunction
			?"ErrorCode: ", This.FtpErrorCode
			?"ErrorInfo:"
			?This.FtpErrorText
			?"---------------------------------------"
		Endif
		
		If This.FtpErrorCode = ERROR_INTERNET_EXTENDED_ERROR Then
			This._GetLastResponse(m.tcFunction, FALSE)
		Endif
		
		
		
	ENDPROC

	PROCEDURE _getlastresponse
		*!* _GetLastResponse(cFunction, [lClearLastError])
		
		Lparameters m.tcFunction As String, m.tlClearLastError As Boolean
		
		If m.tlClearLastError = TRUE Then
		    This._ClearLastError()
		Endif
		
		This.FtpResponseFunction = m.tcFunction
		
		Local ;
		    lnResponseCode As Integer, ;
		    lcResponseInfo As String, ;
		    lnBuffer As Integer, ;
		    lcBuffer As String, ;
		    lnBufferLen As Integer, ;
		    lnRetVal As Integer
		
		*!* FTP PROTOCOL SPECIFIC
		
		*!* Init vars:
		m.lnResponseCode = 0
		m.lcResponseInfo = ""
		
		*!* Get last internet response:
		
		m.lnBuffer = 0
		m.lnBufferLen = 255
		m.lcBuffer = Replicate(NULA, m.lnBufferLen)
		
		m.lnRetVal = apiInternetGetLastResponseInfo(;
		    @m.lnBuffer, ;
		    @m.lcBuffer, ;
		    @m.lnBufferLen)
		
		If m.lnRetVal = 0 And apiGetLastError() = ERROR_INSUFFICIENT_BUFFER
		    m.lcBuffer = Replicate(NULA, m.lnBufferLen)
		    m.lnRetVal = apiInternetGetLastResponseInfo(;
		        @m.lnBuffer, ;
		        @m.lcBuffer, ;
		        @m.lnBufferLen)
		Endif
		
		If m.lnRetVal = 1 Then
		    m.lnResponseCode = m.lnBuffer
		    m.lcResponseInfo = Left(m.lcBuffer, m.lnBufferLen)
		Endif
		
		This.FtpResponseCode = m.lnResponseCode
		This.FtpResponseText = m.lcResponseInfo
		
		If m.lnResponseCode = 0 Then
		    This.FtpResponseCode = Int(Val(Left(Getwordnum(m.lcResponseInfo, Getwordcount(m.lcResponseInfo, LF), LF), 3)))
		Else
		    This.FtpResponseCode = m.lnResponseCode
		Endif
		
		If This._Destroying = FALSE And Not Empty(This.FtpResponseText) Then
		    Raiseevent(This, "FtpResponse")
		Endif
		
		If This.OptionDebug = TRUE Then
		    ?"ResponseFunction", This.FtpResponseFunction
		    ?"ResponseCode: ", This.FtpResponseCode
		    ?"ResponseInfo:"
		    ?This.FtpResponseText
		    ?"---------------------------------------"
		Endif
		
		
	ENDPROC

	PROCEDURE _internetclosehandle
		*!* _InternetCloseHandle()
		
		Lparameters m.lnHandle As Integer
		
		Local lnApiRetVal As Integer
		
		If m.lnHandle <> 0 Then
		
			m.lnApiRetVal = apiInternetCloseHandle(m.lnHandle)
		
			If m.lnApiRetVal = 0 Then
				This._GetLastError("InternetCloseHandle")
			Endif
		
		Endif
		
		Return 0
		
	ENDPROC

	PROCEDURE _internetcrackurl
		*!* _InternetCrackUrl
		
		Lparameters m.lcUrlString As String
		
		Local ;
			lcUrlStruct As String, ;
			lnScheme As Integer, ;
			lnPos As Integer, ;
			lnLen As Integer, ;
			oURL As _URL_COMPONENTS
		
		m.oURL = Createobject("_URL_COMPONENTS")
		
		*!* Set FTP as default scheme:
		m.lnScheme = INTERNET_SCHEME_FTP
		
		*!* Find Scheme and strip scheme prefix:
		Do Case
			Case Lower(Left(m.lcUrlString, 6)) == "ftp://"
				m.lnScheme = INTERNET_SCHEME_FTP
				m.lcUrlString = Right(m.lcUrlString, Len(m.lcUrlString) - 6)
		
			Case Lower(Left(m.lcUrlString, 7)) == "http://"
				m.lnScheme = INTERNET_SCHEME_HTTP
				m.lcUrlString = Right(m.lcUrlString, Len(m.lcUrlString) - 7)
		
			Case Lower(Left(m.lcUrlString, 8)) == "https://"
				m.lnScheme = INTERNET_SCHEME_HTTPS
				m.lcUrlString = Right(m.lcUrlString, Len(m.lcUrlString) - 8)
		
			Case Lower(Left(m.lcUrlString, 4)) == "ftp."
				m.lnScheme = INTERNET_SCHEME_FTP
		
			Case Lower(Left(m.lcUrlString, 4)) == "www."
				m.lnScheme = INTERNET_SCHEME_HTTP
		
		Endcase
		
		*!* lets see if we still have some other scheme in the URL
		*!* maximum scheme len is INTERNET_MAX_SCHEME_LENGTH
		
		m.lnPos = Atc("://", Left(m.lcUrlString, INTERNET_MAX_SCHEME_LENGTH))
		
		If m.lnPos > 0 Then
			m.lnLen = Len(m.lcUrlString) - (m.lnPos + 2)
			m.lcUrlString = Right(m.lcUrlString, m.lnLen)
		Endif
		
		*!* Add protocol prefix based on scheme found:
		Do Case
			Case m.lnScheme = INTERNET_SCHEME_FTP
				m.lcUrlString = "ftp://" + m.lcUrlString
		
			Case m.lnScheme = INTERNET_SCHEME_HTTP
				m.lcUrlString = "http://" + m.lcUrlString
		
			Case m.lnScheme = INTERNET_SCHEME_HTTPS
				m.lcUrlString = "https://" + m.lcUrlString
		Endcase
		
		*!* Initialize oUrl structure
		With m.oURL
			.lpszExtraInfo	= Replicate(NULCHAR, INTERNET_MAX_PATH_LENGTH)
			.lpszHostName	= Replicate(NULCHAR, INTERNET_MAX_HOST_NAME_LENGTH)
			.lpszPassword	= Replicate(NULCHAR, INTERNET_MAX_PASSWORD_LENGTH)
			.lpszScheme		= Replicate(NULCHAR, INTERNET_MAX_SCHEME_LENGTH)
			.lpszUrlPath	= Replicate(NULCHAR, INTERNET_MAX_PATH_LENGTH)
			.lpszUserName	= Replicate(NULCHAR, INTERNET_MAX_USER_NAME_LENGTH)
		Endwith
		
		*!* get a copy of the structure to a memory variable:
		m.lcUrlStruct = m.oURL.Value
		
		apiInternetCrackUrl( ;
			m.lcUrlString, ;
			Len(m.lcUrlString), ;
			ICU_DECODE, ;
			@m.lcUrlStruct)
		
		*!* Assign returned structure to url object:
		m.oURL.Value = m.lcUrlStruct
		
		This.UrlText		= m.oURL.lpszScheme + "://" + m.oURL.lpszHostName
		This.UrlExtraInfo	= m.oURL.lpszExtraInfo
		This.UrlHostName	= m.oURL.lpszHostName
		This.UrlPassword	= m.oURL.lpszPassword
		This.UrlPath		= m.oURL.lpszUrlPath
		This.UrlPort		= m.oURL.nPort
		This.UrlSchemeName	= m.oURL.lpszScheme
		This.UrlSchemeCode	= m.oURL.nScheme
		This.UrlUsername	= m.oURL.lpszUserName
		
		*!* Add port to url if using non-default
		Do Case
		
			Case This.UrlSchemeName == "http" And This.UrlPort <> 80
				This.UrlText = This.UrlText + ":" + Transform(This.UrlPort)
		
			Case This.UrlSchemeName == "https" And This.UrlPort <> 443
		*This.Urltext = This.Urltext + ":" + Transform(This.UrlPort)
		
			Case This.UrlSchemeName == "ftp" And This.UrlPort <> 21
				This.UrlText = This.UrlText + ":" + Transform(This.UrlPort)
		
		Endcase
		
		*!* add path and extra info:
		This.UrlText = This.UrlText + This.UrlPath + This.UrlExtraInfo
		
		This._UpdateUrlProperties()
		
		?This.UrlHostName
		?This.UrlPort
		?This.UrlSchemeName
		?This.Urltext
		?This.UrlSchemeCode
		?This.UrlPath
		?This.UrlExtraInfo
		?This.UrlUsername
		?This.UrlPassword
		
		m.oURL = .Null.
		Release m.oURL
		
		Return
		
	ENDPROC

	PROCEDURE _internetqueryoption
		*!* _InternetQueryOption(nHandle, nOption, @vValue)
		
		Lparameters m.tnHandle As Integer, m.tnOption As Integer, m.tvValue As Variant
		
		Local ;
			lcBuffer As String, ;
			lcBufferLen As Integer, ;
			lnApiRetVal As Integer, ;
			llRetVal As Boolean
		
		m.lcBufferLen = 255
		m.lcBuffer = Space(m.lcBufferLen)
		
		m.lnApiRetVal = apiInternetQueryOption(m.tnHandle, m.tnOption, @m.lcBuffer, @m.lcBufferLen)
		
		If m.lnApiRetVal = 0 And apiGetLastError() = ERROR_INSUFFICIENT_BUFFER Then
			m.lcBuffer = Space(m.lcBufferLen)
			m.lnApiRetVal = apiInternetQueryOption(m.tnHandle, m.tnOption, @m.lcBuffer, @m.lcBufferLen)
		Endif
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
		Else
			m.llRetVal = TRUE
			If Vartype(m.tvValue) = T_numeric Then
				m.tvValue = CToBin(Left(m.lcBuffer, m.lcBufferLen), "4RS")
			Else
				m.tvValue = Left(m.lcBuffer, m.lcBufferLen)
			Endif
		
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE _internetsetoption
		*!* _InternetSetOption(nHandle, nOption, vValue)
		
		Lparameters m.tnHandle As Integer, m.tnOption As Integer, m.tvValue As Variant
		
		Local ;
			lcBuffer As String, ;
			lnBufferLen As Integer, ;
			lnApiRetVal As Integer, ;
			llRetVal As Boolean
		
		If Vartype(m.tvValue) = T_NUMERIC Then
			m.lcBuffer = BinToC(m.tvValue, "4RS")
		Else
			m.lcBuffer = Alltrim(m.tvValue)
		Endif
		
		m.lnBufferLen = Len(m.lcBuffer)
		
		m.lnApiRetVal = apiInternetSetOption(;
			m.tnHandle, ;
			m.tnOption, ;
			m.lcBuffer, ;
			m.lnBufferLen)
		
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
		Else
			m.llRetVal = TRUE
		Endif
		
		Return m.llRetVal
		
	ENDPROC

	PROCEDURE _setproperties
		
		*!* _SetProperties()
		
		If Type("This.InternetAccessType") <> T_NUMERIC Then
			This.InternetAccessType = 0
		Endif
		
		If Type(This.InternetUserAgent) <> T_CHARACTER Then
			This.InternetUserAgent = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
		Endif
		
		This.FtpErrorCode = 0
		This.FtpErrorFunction = ""
		This.FtpErrorText = ""
		
		This.FtpResponseCode = 0
		This.FtpResponseFunction = ""
		This.FtpResponseText = ""
		
		If Type("This.InternetProxyBypass") <> T_CHARACTER Then
			This.InternetProxyBypass = "<local>"
		Endif
		
		If Type("This.FtpUsername") <> T_CHARACTER Then
			This.FtpUsername = Transform(This.FtpUsername)
		Endif
		
		If Type("This.FtpPassword") <> T_CHARACTER Then
			This.FtpPassword = Transform(This.FtpPassword)
		Endif
		
		
		Dimension This.FtpFiles(1, 5)
		
		
		
	ENDPROC

	PROCEDURE _updateurlproperties
		*!* _UpdateUrlProperties()
		
		Local ;
			lcOptPassword As String, ;
			lcOptUserName As String
		
		If This.hConnect <> 0 Then
		
			m.lcOptPassword = ""
			m.lcOptUserName = ""
		
			If This._InternetQueryOption(This.hConnect, INTERNET_OPTION_PASSWORD, @m.lcOptPassword) Then
				This.UrlPassword = m.lcOptPassword
			Endif
		
			If This._InternetQueryOption(This.hConnect, INTERNET_OPTION_USERNAME, @m.lcOptUserName)
				This.UrlUsername = m.lcOptUserName
			Endif
		
		Else
		
			If Not Empty(This.FtpPassword) And Empty(This.UrlPassword) Then
				This.UrlPassword = Alltrim(This.FtpPassword)
			Endif
		
			If Not Empty(This.FtpUsername) And Empty(This.UrlUsername) Then
				This.UrlUsername = Alltrim(This.FtpUsername)
			Endif
		
		Endif
		
		*!* Check for empty username and existing password:
		If Empty(This.UrlUsername) Then
			This.UrlPassword = ""
		Endif
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_gripper AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlstyle_assign
		*m: ctlvisible_assign
		*m: _adddotsvista
		*m: _adddotsxp
		*m: _addlines
		*m: _addmousetrap
		*m: _bindevents
		*m: _create
		*m: _getcolors
		*m: _onformactivate
		*m: _onformborderstyle
		*m: _onformresize
		*m: _onmousedown
		*m: _setstyle
		*m: _setvisible
		*p: ctlautosize
		*p: ctlscale
		*p: ctlstyle		&& Specifies the style of sizing grip.
		*p: ctlvisible
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	ctlautosize = .T.
	ctlscale = 1
	ctlstyle = 1		&& Specifies the style of sizing grip.
	ctlvisible = .T.
	Height = 21
	Name = "ctl32_gripper"
	Width = 96
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_gripper", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 4, ;
		Width = 65
		*< END OBJECT: BaseClass="label" />
	
	HIDDEN PROCEDURE ctlstyle_assign
		*!* ctlStyle_Assign()
		
		Lparameters vNewVal
		
		This.ctlstyle = m.vNewVal
		
		This._SetStyle()
		
	ENDPROC

	HIDDEN PROCEDURE ctlvisible_assign
		*!* ctlVisible_Assign()
		
		Lparameters vNewVal
		
		This.ctlVisible = m.vNewVal
		
		This._SetVisible()
	ENDPROC

	PROCEDURE Init
		*!* Init()
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		This._Create()
		This._BindEvents()
		
		
		
	ENDPROC

	PROCEDURE _adddotsvista
		*!* _AddDotsVista()
		
		*!* This is for Vista, colors are hardcoded
		
		*!* This method creates a container and adds the six square dots
		*!* of the gripper, like this:
		*!*     #
		*!*   # #
		*!* # # #
		
		Local ;
			lnx As Integer, ;
			lny As Integer, ;
			lcName As String
		
		*!* Add container that will hold the dots
		This.AddObject("oDots6", "Container")
		
		With This.oDots6
			.Anchor = 0
			.BackStyle = 0
			.BorderWidth = 0
			.Height = 17 * This.ctlScale
			.Width = 17 * This.ctlScale
		
			*!* This is here just in case someone wants to use the dots in 98 or 2000 to look cool,
			*!* we adjust the position slightly
			If ctlIsThemeActive() = TRUE Then
				.Left = This.Width - 17 * This.ctlScale
				.Top = This.Height - 17 * This.ctlScale
			Else
				.Left = This.Width - 16 * This.ctlScale
				.Top = This.Height - 16 * This.ctlScale
			Endif
			.ZOrder(1)
			.Anchor = 12
		Endwith
		
		For m.lnx = 7 * This.ctlScale To 13 * This.ctlScale Step 3 * This.ctlScale
			For m.lny = 7 * This.ctlScale To 13 * This.ctlScale Step 3 * This.ctlScale
				*!* Skip 3 unwanted shapes
				If (m.lnx * m.lny) < 88  * This.ctlScale * This.ctlScale
					Loop
				Endif
		
				*!* Add dot 1
				m.lcName = "o" + Sys(2015)
				This.oDots6.AddObject(m.lcName, "Shape")
				With Evaluate("This.oDots6." + m.lcName)
					.Width = 1 * This.ctlScale
					.Height = 1 * This.ctlScale
					.BorderWidth = 0
					.BorderStyle = 0
					.BackColor = 16777215	&& rgb(255,255,255)
					.Visible = TRUE
					.Left = m.lnx
					.Top =  m.lny
				Endwith
		
				*!* Add dot 2
				m.lcName = "o" + Sys(2015)
				This.oDots6.AddObject(m.lcName, "Shape")
				With Evaluate("This.oDots6." + m.lcName)
					.Width = 1 * This.ctlScale
					.Height = 1 * This.ctlScale
					.BorderWidth = 0
					.BorderStyle = 0
					.BackColor = 13619151	&& rgb(207,207,207)
					.Visible = TRUE
					.Left = m.lnx + 1 * This.ctlScale
					.Top  = m.lny  * This.ctlScale
				Endwith
		
				*!* Add dot 3
				m.lcName = "o" + Sys(2015)
				This.oDots6.AddObject(m.lcName, "Shape")
				With Evaluate("This.oDots6." + m.lcName)
					.Width = 1 * This.ctlScale
					.Height = 1 * This.ctlScale
					.BorderWidth = 0
					.BorderStyle = 0
					.BackColor = 15198183	&& rgb(231,231,231)
					.Visible = TRUE
					.Left = m.lnx
					.Top =  m.lny + 1
				Endwith
		
				*!* Add dot 4
				m.lcName = "o" + Sys(2015)
				This.oDots6.AddObject(m.lcName, "Shape")
				With Evaluate("This.oDots6." + m.lcName)
					.Width = 1 * This.ctlScale
					.Height = 1 * This.ctlScale
					.BorderWidth = 0
					.BorderStyle = 0
					.BackColor = 11513775	&& rgb(175,175,175)
					.Visible = TRUE
					.Left = m.lnx + 1
					.Top =  m.lny + 1
				Endwith
		
			Endfor
		Endfor
		
	ENDPROC

	HIDDEN PROCEDURE _adddotsxp
		*!* _AddDots()
		
		*!* This is for XP, colors are hardcoded, are the same in all 3 stock XP themes
		
		*!* This method creates a container and adds the six square dots with
		*!* shadow of the gripper, like this:
		*!*     #
		*!*   # #
		*!* # # #
		
		Local ;
			lnx As Integer, ;
			lny As Integer, ;
			lcName As String
		
		*!* Add container that will hold the dots
		This.AddObject("oDots5", "Container")
		
		With This.oDots5
			.Anchor = 0
			.BackStyle = 0
			.BorderWidth = 0
			.Height = 17 * This.ctlScale
			.Width = 17 * This.ctlScale
		
			*!* This is here just in case someone wants to use the dots in 98 or 2000 to look cool,
			*!* we adjust the position slightly
			If ctlIsThemeActive() = TRUE Then
				.Left = This.Width - 17 * This.ctlScale
				.Top = This.Height - 17 * This.ctlScale
			Else
				.Left = This.Width - 16 * This.ctlScale
				.Top = This.Height - 16 * This.ctlScale
			Endif
			.ZOrder(1)
			.Anchor = 12
		Endwith
		
		For m.lnx = 6 * This.ctlScale To 14 * This.ctlScale Step 4 * This.ctlScale
			For m.lny = 6 * This.ctlScale To 14 * This.ctlScale Step 4 * This.ctlScale
				*!* Skip 3 unwanted shapes
				If (m.lnx * m.lny) < 84 * This.ctlScale * This.ctlScale
					Loop
				Endif
				*!* Add light dot
				m.lcName = "o" + Sys(2015)
				This.oDots5.AddObject(m.lcName, "Shape")
				With Evaluate("This.oDots5." + m.lcName)
					.Width = 2 * This.ctlScale
					.Height = 2 * This.ctlScale
					.BorderWidth = 0
					.BorderStyle = 0
					.BackColor = 16777215	&& rgb(255,255,255)
					.Visible = TRUE
					.Left = m.lnx
					.Top =  m.lny
				Endwith
				*!* Add dark dot
				m.lcName = "o" + Sys(2015)
				This.oDots5.AddObject(m.lcName, "Shape")
				With Evaluate("This.oDots5." + m.lcName)
					.Width = 2 * This.ctlScale
					.Height = 2 * This.ctlScale
					.BorderWidth = 0
					.BorderStyle = 0
					.BackColor = 10728632	&& rgb(184,180,163)
					.Visible = TRUE
					.Left = m.lnx - 1 * This.ctlScale
					.Top  = m.lny - 1 * This.ctlScale
				Endwith
			Endfor
		Endfor
		
	ENDPROC

	HIDDEN PROCEDURE _addlines
		*!* _AddLines()
		
		*!* Add a container that will hold 2 labels with Marlett lines character
		This.AddObject("oLines", "Container")
		
		With This.oLines
			.Anchor = 0
			.BackStyle = 0
			.BorderWidth = 0
			.Height = 17 * This.ctlScale
			.Width = 17 * This.ctlScale
		
			*!* This is here just in case someone wants to use the lines in XP, to look "retro",
			*!* we adjust the position slightly
			If ctlIsThemeActive() = TRUE Then
				.Left = This.Width - 17 * This.ctlScale
				.Top  = This.Height - 17 * This.ctlScale
			Else
				.Left = This.Width - 16 * This.ctlScale
				.Top  = This.Height - 16 * This.ctlScale
			Endif
			.ZOrder(1)
			.Anchor = 12
		Endwith
		
		*!* Light diagonal lines.
		*!* Marlett is a hidden Windows font used to render non themed controls
		This.oLines.AddObject("oLines1", "Label")
		With This.oLines.oLines1
			.Anchor = 0
			.BackStyle = 0
			.Caption = "o"
			.FontName = "Marlett"
			.FontSize = Int(12 * This.ctlScale)
			.ForeColor = apiGetSysColor(COLOR_BTNHIGHLIGHT)
			.Height = .Parent.Height
			.Width = .Parent.Width
			.Left =  0
			.Top =  0
			.Visible = TRUE
		Endwith
		
		*!* dark diagonal lines
		This.oLines.AddObject("oLines2", "Label")
		With This.oLines.oLines2
			.Anchor = 0
			.BackStyle = 0
			.Caption = "p"
			.FontName = "Marlett"
			.FontSize = 12 * This.ctlScale
			.ForeColor = apiGetSysColor(COLOR_BTNSHADOW)
			.Height = .Parent.Height
			.Width = .Parent.Width
			.Left = 0
			.Top = 0
			.Visible = TRUE
		Endwith
		
		
	ENDPROC

	HIDDEN PROCEDURE _addmousetrap
		*!* _AddMouseTrap()
		
		This.AddObject("oMouseTrap", "Shape")
		
		With This.oMouseTrap
			.Anchor = 0
			.BackStyle = 0
			.BorderStyle = 0
			.Height = This.Height
			.Width = This.Width
			.Left = 0
			.MousePointer = MOUSE_SIZE_NW_SE
			.Top = 0
			.Visible = TRUE
			.ZOrder(0)
			.Anchor = 15
		Endwith
	ENDPROC

	HIDDEN PROCEDURE _bindevents
		*!* _BindEvents()
		
		Bindevent(Thisform, "Activate", This, "_OnFormActivate", 1)
		
		*!* 20070723 WM_NCHITTEST not used any more, now we use oMouseTrap.MouseDown
		*!* Anton
		
		Bindevent(This.oMouseTrap, "MouseDown", This, "_OnMouseDown", 1)
		
		Bindevent(Thisform, "BorderStyle", This, "_OnFormBorderStyle", 1)
		Bindevent(Thisform, "Resize", This, "_OnFormResize", 1)
		
	ENDPROC

	HIDDEN PROCEDURE _create
		*!* _Create()
		
		*!* If XP and theme active, draw dots, else draw lines
		*!* We dont care about _screen.themes or thisform.themes
		*!* because is the non-client frame that determines the grip
		*!* style (the form border themed or not)
		
		With This
			.BackStyle = 0
			.BorderWidth = 0
			.Anchor = 0
			If .ctlAutoSize = TRUE Then
				.Height = Sysmetric(SYSMETRIC_HSCROLLBARHEIGHT) * This.ctlScale
				.Width =  Sysmetric(SYSMETRIC_VSCROLLBARWIDTH) * This.ctlScale
			Endif
			.Left = Thisform.Width - This.Width
			.Top = Thisform.Height - This.Height
			.Anchor = 12
			.ZOrder(0)
		Endwith
		
		This._AddLines()
		This._AddDotsXP()
		This._AddDotsVista()
		This._AddMouseTrap()
		
		This._SetStyle()
		This._SetVisible()
		
	ENDPROC

	HIDDEN PROCEDURE _getcolors
		*!* _GetColors()
		
		Local ;
			lnColor, ;
			lnTheme, ;
			lnApiRetVal
		
		m.lnColor = 0
		m.lnTheme = 0
		m.lnApiRetVal = -1
		
		*!* 20080630 changed to COLOR_SCROLLBAR
		This._Color1 = apiGetSysColor(COLOR_SCROLLBAR)
		This._Color2 = apiGetSysColor(COLOR_BTNHIGHLIGHT)
		
		*!*	If ctlIsThemeActive() Then
		*!*		m.lnTheme = apiOpenThemeData(0, VSCLASS_STATUS)
		*!*		If m.lnTheme <> 0 Then
		
		*!*			If apiGetThemeColor(m.lnTheme, SP_GRIPPER, 0, TMT_FILLCOLORHINT, @m.lnColor) = ERROR_SUCCESS Then
		*!*				This._Color1 = m.lnColor
		*!*			Endif
		
		*!*			If apiGetThemeColor(m.lnTheme, SP_GRIPPER, 0, TMT_EDGEHIGHLIGHTCOLOR, @m.lnColor) = ERROR_SUCCESS Then
		*!*				This._Color2 = m.lnColor
		*!*			Endif
		*!*			apiCloseThemeData(m.lnTheme)
		*!*		Endif
		*!*	Endif
		
		
	ENDPROC

	HIDDEN PROCEDURE _onformactivate
		*!* _OnFormActivate
		
		*!* Just in case anyone did a zOrder() of a control that 
		*!* is over this control, after the control Init:
		This.ZOrder(0)
		
		
	ENDPROC

	HIDDEN PROCEDURE _onformborderstyle
		*!* _OnFormBorderStyle
		
		This._SetVisible()
		
	ENDPROC

	HIDDEN PROCEDURE _onformresize
		*!* _OnFormResize
		
		This._SetVisible()
	ENDPROC

	HIDDEN PROCEDURE _onmousedown
		*!* _OnMouseDown(nButton, nShift, nXCoord, nYCoord)
		
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		*!* Here we send a WM_LBUTTONDOWN message to the window, with the coordinates of the right
		*!* bottom point of the form.
		
		If m.nButton = BUTTON_LEFT Then
		
			Local lnLparam As Integer
		
			*!*	The low-order word specifies the x-coordinate of the cursor.
			*!*	The high-order word specifies the y-coordinate of the cursor.
			*!*	The coordinates are relative to the upper-left corner of the client area.
			*!* MAKELPARAM
		
			*!* 20070831 Added some pixels to Width and Height, so it works right in
			*!* Windows Vista.
			m.lnLparam = Int((Thisform.Width + Sysmetric(SYSMETRIC_SIZINGBORDERWIDTH) / 2)) ;
				+ Int((Thisform.Height + Sysmetric(SYSMETRIC_SIZINGBORDERHEIGHT) / 2) * 0x10000)
		
			*m.lnLparam = Thisform.Width + 2 + (Thisform.Height + 2) * 0x10000
		
		
			*Thisform.Show()
			apiSendMessageInteger(Thisform.HWnd, WM_LBUTTONDOWN, MK_LBUTTON, m.lnLparam)
			*!* Let Windows proccess the message while the user drags the gripper:
			DoEvents
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE _setstyle
		*!* _SetStyle()
		
		This.oLines.Visible = FALSE
		This.oDots5.Visible = FALSE
		This.oDots6.Visible = FALSE
		
		Do Case
			Case This.ctlstyle = 2	&& Lines
				This.oLines.Visible = TRUE
		
			Case This.ctlstyle = 3	&& Dots
				This.oDots5.Visible = TRUE
		
			Otherwise
				&& we choose dots if XP and theme active
				If ctlIsThemeActive(Thisform) = TRUE Then
					If ctlGetOsVersion() < NTDDI_VISTA
						This.oDots5.Visible = TRUE
					Else
						This.oDots6.Visible = TRUE
					Endif
				Else
					This.oLines.Visible = TRUE
				Endif
		Endcase
		
	ENDPROC

	HIDDEN PROCEDURE _setvisible
		*!* _SetVisible()
		
		Local llVisible As Boolean
		
		m.llVisible = TRUE
		
		If Thisform.BorderStyle # BORDER_SYSTEM
			m.llVisible = FALSE
		Endif
		
		If Thisform.WindowState = WINDOWSTATE_MAXIMIZED
			m.llVisible = FALSE
		Endif
		
		If This.ctlVisible = FALSE
			m.llVisible = FALSE
		Endif
		
		If This.Visible <> m.llVisible Then
			This.Visible = m.llVisible
		Endif
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_monthcalendar AS ctl32_controlbase OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_monthcalendar.bmp" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctladdannuallyboldeddate		&& Adds a day that is displayed in bold on an annual basis in the month calendar.
		*m: ctladdboldeddate		&& Adds a day to be displayed in bold in the month calendar.
		*m: ctladdmonthlyboldeddate		&& Adds a day that is displayed in bold on a monthly basis in the month calendar.
		*m: ctladdweeklyboldeddate
		*m: ctlborderwidth_assign
		*m: ctlcalendardimensionsheight_assign
		*m: ctlcalendardimensionswidth_assign
		*m: ctldefaultmonthbackcolor_access
		*m: ctldefaulttitlebackcolor_access
		*m: ctldefaulttitleforecolor_access
		*m: ctldefaulttrailingforecolor_access
		*m: ctlfirstdayofweek_assign
		*m: ctlmaxdate_assign
		*m: ctlmaxselectioncount_assign
		*m: ctlmindate_assign
		*m: ctlremoveallannuallyboldeddates		&& Removes all the annually bold dates.
		*m: ctlremoveallboldeddates		&& Removes all the nonrecurring bold dates.
		*m: ctlremoveallmonthlyboldeddates		&& Removes all the monthly bold dates.
		*m: ctlremoveallweeklyboldeddates		&& Removes all the weekly bold dates.
		*m: ctlremoveannuallyboldeddate		&& Removes the specified date from the list of annually bold dates.
		*m: ctlremoveboldeddate		&& Removes the specified date from the list of nonrecurring bold dates.
		*m: ctlremovemonthlyboldeddate		&& Removes the specified date from the list of monthly bolded dates.
		*m: ctlremoveweeklyboldeddate		&& Removes the specified date from the list of weekly bolded dates.
		*m: ctlscrollchange_assign
		*m: ctlselectionend_access
		*m: ctlselectionstart_access
		*m: ctlshowtodaycircle_assign
		*m: ctlshowtoday_assign
		*m: ctlshowweeknumbers_assign
		*m: ctlsinglemonthheight_access
		*m: ctlsinglemonthwidth_access
		*m: ctltitlebackcolor_assign
		*m: ctltitleforecolor_assign
		*m: ctltodaydateset_access
		*m: ctltodaydate_assign
		*m: ctltrailingforecolor_assign
		*m: ctlupdateboldeddates		&& Repaints the bold dates to reflect the dates set in the lists of bold dates.
		*m: _daystatessetup		&& Sets up _DayStates
		*m: _setborderwidth
		*m: _setcalendarcolumns
		*m: _setcalendarrows
		*m: _setfirstdayofweek
		*m: _setrange
		*m: _setscrollchange
		*m: _setshowtoday
		*m: _setshowtodaycircle
		*m: _setshowweeknumbers
		*m: _settitlebackcolor
		*m: _settitleforecolor
		*m: _settodaydate
		*m: _settrailingforecolor
		*m: _updatedaystates		&& Updates the date states array stored in the _DayStatesAddress memory address.
		*p: ctlborderwidth
		*p: ctlcalendardimensionsheight		&& Gets or sets the number of rows of months displayed.
		*p: ctlcalendardimensionswidth		&& Gets or sets the number of columns of months displayed.
		*p: ctldefaultmonthbackcolor		&& Gets a value indicating the default background color of the month area of the calendar.
		*p: ctldefaulttitlebackcolor		&& Gets a value indicating the default background color of the title area of the calendar.
		*p: ctldefaulttitleforecolor		&& Gets a value indicating the default foreground color of the title area of the calendar.
		*p: ctldefaulttrailingforecolor		&& Gets a value indicating the default color of days in months that are not fully displayed in the control.
		*p: ctlfirstdayofweek		&& Gets or sets the first day of the week as displayed in the month calendar.
		*p: ctlmaxdate		&& Gets or sets the maximum allowable date.
		*p: ctlmaxselectioncount		&& Gets or sets the maximum number of days that can be selected in a month calendar control.
		*p: ctlmindate		&& Gets or sets the minimum allowable date.
		*p: ctlscrollchange		&& Gets or sets the scroll rate for a month calendar control.
		*p: ctlselectionend		&& Gets or sets the end date of the selected range of dates.
		*p: ctlselectionstart		&& Gets or sets the start date of the selected range of dates.
		*p: ctlshowtoday		&& Gets or sets a value indicating whether the date represented by the TodayDate property is displayed at the bottom of the control.
		*p: ctlshowtodaycircle		&& Gets or sets a value indicating whether today's date is identified with a circle or a square.
		*p: ctlshowweeknumbers		&& Gets or sets a value indicating whether the month calendar control displays week numbers (1-52) to the left of each row of days.
		*p: ctlsinglemonthheight		&& Gets the minimum height to display one month of the calendar.
		*p: ctlsinglemonthwidth		&& Gets the minimum width to display one month of the calendar.
		*p: ctltitlebackcolor		&& Gets or sets a value indicating the background color of the title area of the calendar.
		*p: ctltitleforecolor		&& Gets or sets a value indicating the foreground color of the title area of the calendar.
		*p: ctltodaydate		&& Gets or sets the value that is used by MonthCalendar as today's date.
		*p: ctltodaydateset		&& Gets a value indicating whether the TodayDate property has been explicitly set.
		*p: ctltrailingforecolor		&& Gets or sets a value indicating the color of days in months that are not fully displayed in the control.
		*a: ctlannuallyboldeddates[1,0]		&& Gets or sets the array of DateTime objects that determines which annual days are displayed in bold.
		*a: ctlboldeddates[1,0]		&& Gets or sets the array of DateTime objects that determines which nonrecurring dates are displayed in bold.
		*a: ctlmonthlyboldeddates[1,0]		&& Gets or sets the array of DateTime objects that determine which monthly days to bold.
		*a: ctlweeklyboldeddates[1,0]
		*a: _daystates[13,0]
		*p: _calendarheight
		*p: _calendarwidth
		*p: _columns
		*p: _daystatesaddress		&& Pointer to a string buffer that holds a day states array.
		*p: _rows
		*p: _showtodayheight
		*p: _showweeknumberswidth
		*p: _todaydateset
	*</DefinedPropArrayMethod>

	BorderWidth = 1
	ctlborderwidth = 0
	ctlcalendardimensionsheight = 1		&& Gets or sets the number of rows of months displayed.
	ctlcalendardimensionswidth = 1		&& Gets or sets the number of columns of months displayed.
	ctlcanfocus = .T.
	ctldefaultmonthbackcolor = 0		&& Gets a value indicating the default background color of the month area of the calendar.
	ctldefaulttitlebackcolor = 0		&& Gets a value indicating the default background color of the title area of the calendar.
	ctldefaulttitleforecolor = 0		&& Gets a value indicating the default foreground color of the title area of the calendar.
	ctldefaulttrailingforecolor = 0		&& Gets a value indicating the default color of days in months that are not fully displayed in the control.
	ctlfirstdayofweek = 0		&& Gets or sets the first day of the week as displayed in the month calendar.
	ctlmaxdate = {^9998/12/31}		&& Gets or sets the maximum allowable date.
	ctlmaxselectioncount = 1		&& Gets or sets the maximum number of days that can be selected in a month calendar control.
	ctlmindate = {^1800/01/01}		&& Gets or sets the minimum allowable date.
	ctlscrollchange = 0		&& Gets or sets the scroll rate for a month calendar control.
	ctlselectionend = {}		&& Gets or sets the end date of the selected range of dates.
	ctlselectionstart = {}		&& Gets or sets the start date of the selected range of dates.
	ctlshowtoday = .T.		&& Gets or sets a value indicating whether the date represented by the TodayDate property is displayed at the bottom of the control.
	ctlshowtodaycircle = .T.		&& Gets or sets a value indicating whether today's date is identified with a circle or a square.
	ctlshowweeknumbers = .F.		&& Gets or sets a value indicating whether the month calendar control displays week numbers (1-52) to the left of each row of days.
	ctlsinglemonthheight = 0		&& Gets the minimum height to display one month of the calendar.
	ctlsinglemonthwidth = 0		&& Gets the minimum width to display one month of the calendar.
	ctltitlebackcolor = -1		&& Gets or sets a value indicating the background color of the title area of the calendar.
	ctltitleforecolor = -1		&& Gets or sets a value indicating the foreground color of the title area of the calendar.
	ctltodaydate = {}		&& Gets or sets the value that is used by MonthCalendar as today's date.
	ctltodaydateset = .F.		&& Gets a value indicating whether the TodayDate property has been explicitly set.
	ctltrailingforecolor = -1		&& Gets or sets a value indicating the color of days in months that are not fully displayed in the control.
	ctlvalue = (date())
	Height = 161
	Name = "ctl32_monthcalendar"
	Width = 247
	_calendarheight = 0
	_calendarwidth = 0
	_columns = 1
	_controlhasownfocuscue = .F.
	_daystatesaddress = 0		&& Pointer to a string buffer that holds a day states array.
	_rows = 1
	_showtodayheight = 0
	_showweeknumberswidth = 0
	_todaydateset = .F.
	ctlTextBox.Name = "ctlTextBox"
	lblname.Caption = "ctl32_monthcalendar"
	lblname.Name = "lblname"
	
	PROCEDURE ctladdannuallyboldeddate		&& Adds a day that is displayed in bold on an annual basis in the month calendar.
		*!* ctlAddAnnuallyBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local ;
			lnRows As Integer
		
		m.lnRows = Alen(This.ctlAnnuallyBoldedDates, 1)
		
		If Vartype(This.ctlAnnuallyBoldedDates(m.lnRows)) # T_LOGICAL Then
			m.lnRows = m.lnRows + 1
		Endif
		
		Dimension This.ctlAnnuallyBoldedDates(m.lnRows)
		
		This.ctlAnnuallyBoldedDates(m.lnRows) = m.tdDate
		
		*!* Update DayState string for month:
		This._DayStates(Month(m.tdDate)) = Bitset(This._DayStates(Month(m.tdDate)), Day(m.tdDate) - 1 , 1)
		
		
	ENDPROC

	PROCEDURE ctladdboldeddate		&& Adds a day to be displayed in bold in the month calendar.
		*!* ctlAddBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local lnRows As Integer
		
		m.lnRows = Alen(This.ctlBoldedDates, 1)
		
		If Vartype(This.ctlBoldedDates(m.lnRows)) # T_LOGICAL Then
			m.lnRows = m.lnRows + 1
		Endif
		
		Dimension This.ctlBoldedDates(m.lnRows)
		
		This.ctlBoldedDates(m.lnRows) = m.tdDate
		
		
	ENDPROC

	PROCEDURE ctladdmonthlyboldeddate		&& Adds a day that is displayed in bold on a monthly basis in the month calendar.
		*!* ctlAddMonthlyBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local ;
		lnRows As Integer
		
		m.lnRows = Alen(This.ctlMonthlyBoldedDates, 1)
		
		If Vartype(This.ctlMonthlyBoldedDates(m.lnRows)) # T_LOGICAL Then
			m.lnRows = m.lnRows + 1
		Endif
		
		Dimension This.ctlMonthlyBoldedDates(m.lnRows)
		
		This.ctlMonthlyBoldedDates(m.lnRows) = m.tdDate
		
		*!* Update DayState string for monthly days:
		This._DayStates(13) = Bitset(This._DayStates(13), Day(m.tdDate) - 1 , 1)
		
	ENDPROC

	PROCEDURE ctladdweeklyboldeddate
		*!* ctlAddWeeklyBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local lnRows As Integer
		
		m.lnRows = Alen(This.ctlWeeklyBoldedDates, 1)
		
		If Vartype(This.ctlWeeklyBoldedDates(m.lnRows)) # T_LOGICAL Then
			m.lnRows = m.lnRows + 1
		Endif
		
		Dimension This.ctlWeeklyBoldedDates(m.lnRows)
		
		This.ctlWeeklyBoldedDates(m.lnRows) = m.tdDate
		
	ENDPROC

	PROCEDURE ctlborderwidth_assign
		*!* ctlBorderWidth_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlBorderWidth # m.tuNewValue Then
			This.ctlBorderWidth = m.tuNewValue
			This._SetBorderWidth()
		Endif
		
	ENDPROC

	PROCEDURE ctlcalendardimensionsheight_assign
		*!* ctlCalendarDimensionsHeight_Assign()
		
		Lparameters m.tuNewValue
		
		m.tuNewValue = Max(Min(12 / This.ctlCalendarDimensionsWidth, m.tuNewValue), 1)
		
		If This.ctlCalendarDimensionsHeight # m.tuNewValue Then
			This.ctlCalendarDimensionsHeight = m.tuNewValue
			This._SetCalendarRows()
		Endif
		
	ENDPROC

	PROCEDURE ctlcalendardimensionswidth_assign
		*!* ctlCalendarDimensionsWidth_Assign()
		
		Lparameters m.tuNewValue
		
		m.tuNewValue = Max(Min(12 / This.ctlCalendarDimensionsHeight, m.tuNewValue), 1)
		
		If This.ctlCalendarDimensionsWidth # m.tuNewValue Then
			This.ctlCalendarDimensionsWidth = m.tuNewValue
			This._SetCalendarColumns()
		Endif
		
	ENDPROC

	PROCEDURE ctldefaultmonthbackcolor_access
		Return This.ctlDefaultBackColor
		
	ENDPROC

	PROCEDURE ctldefaulttitlebackcolor_access
		Local lnColor As Integer
		
		m.lnColor = apiGetSysColor(COLOR_ACTIVECAPTION)	&& ActiveCaption
		
		Return m.lnColor
		
	ENDPROC

	PROCEDURE ctldefaulttitleforecolor_access
		Local lnColor As Integer
		
		m.lnColor = apiGetSysColor(COLOR_CAPTIONTEXT)	&&  ActiveCaptionText
		
		Return m.lnColor
		
	ENDPROC

	PROCEDURE ctldefaulttrailingforecolor_access
		Local lnColor As Integer
		
		m.lnColor = apiGetSysColor(COLOR_GRAYTEXT)	&& GrayText
		
		Return m.lnColor
	ENDPROC

	PROCEDURE ctlfirstdayofweek_assign
		*!* ctlFirstDayOfWeek_Assign()
		
		Lparameters m.tuNewValue
		
		m.tuNewValue = Max(Min(m.tuNewValue, 7), 0)
		
		If This.ctlFirstDayOfWeek # m.tuNewValue Then
			This.ctlFirstDayOfWeek = m.tuNewValue
			This._SetFirstDayOfWeek()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlmaxdate_assign
		*!* ctlMaxDate_Assign
		Lparameters m.tuNewValue
		
		m.tuNewValue = Min(m.tuNewValue, Date(9998,12,31))
		
		If This.ctlMaxDate # m.tuNewValue Then
			This.ctlMaxDate = m.tuNewValue
			This._SetRange()
		Endif
		
	ENDPROC

	PROCEDURE ctlmaxselectioncount_assign
		lparameters tuNewValue
		This.ctlmaxselectioncount = tuNewValue
		
	ENDPROC

	PROCEDURE ctlmindate_assign
		*!* ctlMinDate_Assign
		Lparameters m.tuNewValue
		
		m.tuNewValue = Max(m.tuNewValue, Date(1753,01,01))
		
		If This.ctlMinDate # m.tuNewValue Then
			This.ctlMinDate= m.tuNewValue
			This._SetRange()
		Endif
		
	ENDPROC

	PROCEDURE ctlremoveallannuallyboldeddates		&& Removes all the annually bold dates.
		*!* ctlRemoveAllAnnuallyBoldedDates()
		
		Local m.lnMonth As Integer
		
		Dimension This.ctlAnnuallyBoldedDates(1)
		This.ctlAnnuallyBoldedDates(1) = FALSE
		
		For m.lnMonth = 1 To 12
			This._DayStates(m.lnMonth) = 0h00000000
		Endfor
		
		
	ENDPROC

	PROCEDURE ctlremoveallboldeddates		&& Removes all the nonrecurring bold dates.
		*!* ctlRemoveAllBoldedDates()
		
		Dimension This.ctlBoldedDates(1)
		This.ctlBoldedDates(1) = FALSE
		
		
	ENDPROC

	PROCEDURE ctlremoveallmonthlyboldeddates		&& Removes all the monthly bold dates.
		*!* ctlRemoveAllMonthlyBoldedDates()
		
		Dimension This.ctlMonthlyBoldedDates(1)
		This.ctlMonthlyBoldedDates(1) = FALSE
		
		This._DayStates(13) = 0h00000000
		
		
	ENDPROC

	PROCEDURE ctlremoveallweeklyboldeddates		&& Removes all the weekly bold dates.
		*!* ctlRemoveAllWeeklyBoldedDates()
		
		Dimension This.ctlWeeklyBoldedDates(1)
		This.ctlWeeklyBoldedDates(1) = FALSE
		
		
	ENDPROC

	PROCEDURE ctlremoveannuallyboldeddate		&& Removes the specified date from the list of annually bold dates.
		*!* ctlRemoveAnnuallyBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local ;
			m.lnRow As Integer, ;
			m.lnRows As Integer
		
		m.lnRows = Alen(This.ctlAnnuallyBoldedDates, 1)
		
		For m.lnRow = 1 To m.lnRows
			If Day(m.tdDate) = Day(This.ctlAnnuallyBoldedDates(m.lnRow)) ;
					And Month(m.tdDate) = Month(This.ctlAnnuallyBoldedDates(m.lnRow)) Then
				Adel(This.ctlAnnuallyBoldedDates, m.lnRow)
				Dimension This.ctlAnnuallyBoldedDates(m.lnRows - 1)
			Endif
		Endfor
		
		*!* Update DayState string for month:
		This._DayStates(Month(m.tdDate)) = Bitclear(This._DayStates(Month(m.tdDate)), Day(m.tdDate) - 1 , 1)
		
		
	ENDPROC

	PROCEDURE ctlremoveboldeddate		&& Removes the specified date from the list of nonrecurring bold dates.
		*!* ctlRemoveBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local ;
			m.lnRow As Integer, ;
			m.lnRows As Integer
		
		m.lnRows = Alen(This.ctlBoldedDates, 1)
		
		For m.lnRow = 1 To m.lnRows
			If m.tdDate = This.ctlBoldedDates(m.lnRow) Then
				Adel(This.ctlBoldedDates, m.lnRow)
				Dimension This.ctlBoldedDates(m.lnRows - 1)
			Endif
		Endfor
	ENDPROC

	PROCEDURE ctlremovemonthlyboldeddate		&& Removes the specified date from the list of monthly bolded dates.
		*!* ctlRemoveMonthlyBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local ;
			m.lnRow As Integer, ;
			m.lnRows As Integer
		
		m.lnRows = Alen(This.ctlMonthlyBoldedDates, 1)
		
		For m.lnRow = 1 To m.lnRows
			If Day(m.tdDate) = Day(This.ctlMonthlyBoldedDates(m.lnRow)) Then
				Adel(This.ctlMonthlyBoldedDates, m.lnRow)
				Dimension This.ctlMonthlyBoldedDates(m.lnRows - 1)
			Endif
		Endfor
		
		*!* Update DayState string for monthly days:
		This._DayStates(13) = Bitclear(This._DayStates(13), Day(m.tdDate) - 1 , 1)
		
	ENDPROC

	PROCEDURE ctlremoveweeklyboldeddate		&& Removes the specified date from the list of weekly bolded dates.
		*!* ctlRemoveWeeklyBoldedDate()
		
		Lparameters tdDate As Date
		
		If Vartype(m.tdDate) = T_DATETIME Then
			m.tdDate = Ttod(m.tdDate)
		Endif
		
		If Vartype(m.tdDate) # T_DATE Then
			Return
		Endif
		
		Local ;
			m.lnRow As Integer, ;
			m.lnRows As Integer
		
		m.lnRows = Alen(This.ctlWeeklyBoldedDates, 1)
		
		For m.lnRow = 1 To m.lnRows
			If Dow(m.tdDate) = Dow(This.ctlWeeklyBoldedDates(m.lnRow)) Then
				Adel(This.ctlWeeklyBoldedDates, m.lnRow)
				Dimension This.ctlWeeklyBoldedDates(m.lnRows - 1)
			Endif
		Endfor
		
	ENDPROC

	PROCEDURE ctlscrollchange_assign
		Lparameters tuNewValue
		
		m.tuNewValue = Min(Max(m.tuNewValue, 0), 20000)
		
		This.ctlScrollChange = m.tuNewValue
		
		This._SetScrollChange()
		
	ENDPROC

	PROCEDURE ctlselectionend_access
		Return This.ctlValue
		
	ENDPROC

	PROCEDURE ctlselectionstart_access
		Return This.ctlValue
		
	ENDPROC

	PROCEDURE ctlshowtodaycircle_assign
		*!* ctlShowTodayCircle_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlShowTodayCircle # m.tuNewValue Then
			This.ctlShowTodayCircle = m.tuNewValue
			This._SetShowTodayCircle()
		Endif
		
	ENDPROC

	PROCEDURE ctlshowtoday_assign
		*!* ctlShowToday_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue= m.tuNewValue # 0
		Endif
		
		If This.ctlShowToday # m.tuNewValue Then
			This.ctlShowToday = m.tuNewValue
			This._SetShowToday()
		Endif
		
		
		
	ENDPROC

	PROCEDURE ctlshowweeknumbers_assign
		*!* ctlShowWeekNumbers_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlShowWeekNumbers # m.tuNewValue Then
			This.ctlShowWeekNumbers = m.tuNewValue
			This._SetShowWeekNumbers()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlsinglemonthheight_access
		Return This._CalendarHeight + This._ShowTodayHeight
		
		
	ENDPROC

	PROCEDURE ctlsinglemonthwidth_access
		If This.ctlShowWeekNumbers = TRUE Then
			Return This._CalendarWidth + This._ShowWeekNumbersWidth
		Else
			Return This._CalendarWidth
		Endif
		
		
	ENDPROC

	PROCEDURE ctltitlebackcolor_assign
		*!* ctlTitleBackColor_Assign(tuNewValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) <> "N"
			m.tuNewValue = -1
		Endif
		
		If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
			m.tuNewValue = -1
		Endif
		
		If This.ctlTitleBackColor # m.tuNewValue Then
			This.ctlTitleBackColor = m.tuNewValue
			This._SetTitleBackColor()
		Endif
	ENDPROC

	PROCEDURE ctltitleforecolor_assign
		*!* ctlTitleForeColor_Assign(tuNewValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) <> "N"
			m.tuNewValue = -1
		Endif
		
		If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
			m.tuNewValue = -1
		Endif
		
		If This.ctlTitleForeColor # m.tuNewValue Then
			This.ctlTitleForeColor = m.tuNewValue
			This._SetTitleForeColor()
		Endif
	ENDPROC

	PROCEDURE ctltodaydateset_access
		Return This._TodayDateSet
		
	ENDPROC

	PROCEDURE ctltodaydate_assign
		Lparameters tuNewValue
		
		If Not Empty(m.tuNewValue) Then
			m.tuNewValue = Min(This.ctlMaxDate, m.tuNewValue)
			m.tuNewValue = Max(This.ctlMinDate, m.tuNewValue)
		Endif
		
		This.ctlTodayDate = m.tuNewValue
		
		This._SetTodayDate()
		
	ENDPROC

	PROCEDURE ctltrailingforecolor_assign
		*!* ctlTrailingForeColor_Assign(tuNewValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) <> "N"
			m.tuNewValue = -1
		Endif
		
		If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
			m.tuNewValue = -1
		Endif
		
		If This.ctlTrailingForeColor # m.tuNewValue Then
			This.ctlTrailingForeColor = m.tuNewValue
			This._SetTrailingForeColor()
		Endif
	ENDPROC

	PROCEDURE ctlupdateboldeddates		&& Repaints the bold dates to reflect the dates set in the lists of bold dates.
		*!* ctlUpdateBoldedDates()
		
		Local ;
			loSystemTimeArray As _SYSTEMTIMEARRAY, ;
			ldStartDate As Date, ;
			lnMonths As Integer
		
		*!* Get number of visible months and start date:
		m.loSystemTimeArray = Createobject("_SYSTEMTIMEARRAY")
		
		m.lnMonths = apiSendMessageInteger(This._ControlHwnd, MCM_GETMONTHRANGE, GMR_DAYSTATE, m.loSystemTimeArray.Address)
		
		With m.loSystemTimeArray.Min
			m.ldStartDate = Date(.wYear, .wMonth, .wDay)
		Endwith
		
		m.loSystemTimeArray = .Null.
		
		*!* This updates the daystates array:
		This._UpdateDayStates(m.ldStartDate, m.lnMonths)
		
		apiSendMessageInteger(This._ControlHwnd, MCM_SETDAYSTATE, m.lnMonths, This._DayStatesAddress)
		
		
	ENDPROC

	PROCEDURE ctlvalue_assign
		*!* ctlValue_Assign(nValue)
		
		Lparameters m.tuNewValue
		
		m.tuNewValue = Min(This.ctlMaxDate, m.tuNewValue)
		m.tuNewValue = Max(This.ctlMinDate, m.tuNewValue)
		
		If This.ctlValue # m.tuNewValue Then
			This.ctlValue = m.tuNewValue
			This._SetValue()
		Endif
		
	ENDPROC

	PROCEDURE Destroy
		DoDefault()
		
		If This._DayStatesAddress # 0 Then
			apiHeapFree(apiGetProcessHeap(), 0, This._DayStatesAddress)
		Endif
		
	ENDPROC

	PROCEDURE _bindevents
		*!* _BindEvents()
		
		DoDefault()
		
		Bindevent(This.ctlHostFormhWnd, WM_NOTIFY, Thisform.BindWindowsEventsProxy, "_MsgHandler", 4)
		
	ENDPROC

	PROCEDURE _callbackproc
		*!* _CallbackProc
		
		Lparameters nHWnd As Integer, Msg As Integer, wParam As Integer, Lparam As Integer
		
		Do Case
		
			Case m.Msg = WM_MOUSEWHEEL
		
				Local m.lnWheelTick As Short, lnDelta
		
				If Vartype(This.ctlValue) = T_DATETIME Then
					m.lnDelta = 1 * 60 * 60 * 24
				Else
					m.lnDelta = 1
				Endif
		
				m.lnWheelTicks = ctlHiWord(wParam)
		
				If m.lnWheelTicks > 32767 Then
					m.lnWheelTicks = m.lnWheelTicks - 0xffff - 1
				Endif
		
				m.lnWheelTicks = Int(m.lnWheelTicks / WHEEL_DELTA)
		
				This.ctlValue = This.ctlValue + m.lnWheelTicks * m.lnDelta
		
				Return 0
		
		Endcase
		
		Return DoDefault(m.nHWnd, m.Msg, m.wParam, m.Lparam)
		
	ENDPROC

	PROCEDURE _daystatessetup		&& Sets up _DayStates
		*!* _DayStatesSetup()
		
		Local lnx As Integer
		
		For m.lnx = 1 To 13
			If Vartype(This._DayStates(m.lnx)) # T_VARBINARY Then
				This._DayStates(m.lnx) = 0h00000000
			Endif
		Endfor
		
		
		
	ENDPROC

	PROCEDURE _formmessagehandler
		*!* _FormMessageHandler()
		
		DoDefault()
		
		Do Case
		
			Case Thisform.BindWindowsEventsProxy._Msg = WM_NOTIFY
		
				*!* Get NMHDR structure from pointer
				Local m.loNMHdr As _NMHDR
				m.loNMHdr = Createobject("_NMHDR", Thisform.BindWindowsEventsProxy._lParam)
		
				*!* If the message is not for this control, just return
				If m.loNMHdr.hwndFrom # This._ControlHwnd Then
					m.loNMHdr = .Null.
					Return
				Endif
		
				Do Case
		
						*!* The selected date was changed
					Case m.loNMHdr.Code = MCN_SELCHANGE
						Local m.loSelChange As _NMSELCHANGE
						m.loSelChange = Createobject("_NMSELCHANGE", Thisform.BindWindowsEventsProxy._lParam)
						With m.loSelChange.stSelStart
							This.ctlValue = Date(.wYear, .wMonth, .wDay)
						Endwith
						m.loSelChange = .Null.
		
						*!* requests information about how individual days should be displayed
					Case m.loNMHdr.Code = MCN_GETDAYSTATE
						Local m.loNmDayState As _NMDAYSTATE
						m.loNmDayState = Createobject("_NMDAYSTATE", Thisform.BindWindowsEventsProxy._lParam)
						With m.loNmDayState.stStart
							This._UpdateDayStates(Date(.wYear, .wMonth, .wDay), m.loNmDayState.cDayState)
						Endwith
						m.loNmDayState.prgDayState = This._DayStatesAddress
						m.loNmDayState = .Null.
				Endcase
		
				m.loNMHdr = .Null.
		
		Endcase
		
		
		
	ENDPROC

	PROCEDURE _getdefaultsize
		*!* _GetDefaultSize()
		
		*!* This method finds and stores the default calendar height and width
		*!* The width of the weeks column and the height of the showtoday line
		
		*!* This method is not necessary in Vista, where we use MCM_SIZERECTTOMIN to
		*!* get the size of the window needed to display the calendar(s)
		
		*!* _CalendarHeight
		*!* _CalendarWidth
		*!* _ShowTodayHeight
		*!* _ShowWeekNumbersWidth
		
		Local ;
			lnStyle As Integer, ;
			lnOldStyle As Integer, ;
			loRect As _RECT
		
		If This._DefaultHeight = 0 Then
			This._DefaultHeight = This.Height
			This._DefaultWidth = This.Width
		Endif
		
		*!* Get current styles:
		m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
		m.lnOldStyle = m.lnStyle
		
		*!* Remove week numbers
		m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)
		m.lnStyle = Bitxor(m.lnStyle, MCS_WEEKNUMBERS)
		
		*!* Do not show today date
		m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)
		
		*!* Set style:
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)
		
		*!* Calc control size:
		m.loRect = Createobject("_RECT")
		
		apiSendMessageInteger(This._ControlHwnd, MCM_GETMINREQRECT, 0, m.loRect.Address)
		
		This._CalendarHeight 	= m.loRect.Height
		This._CalendarWidth 	= m.loRect.Width
		
		*!* Add week numbers
		m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)
		
		*!* Add Today date
		m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)
		m.lnStyle = Bitxor(m.lnStyle, MCS_NOTODAY)
		
		*!* Set style:
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)
		
		*!* Calc control size:
		
		apiSendMessageInteger(This._ControlHwnd, MCM_GETMINREQRECT, 0, m.loRect.Address)
		
		*!* Calc height of show today and width of week numbers:
		This._ShowTodayHeight 		= m.loRect.Height - This._CalendarHeight
		This._ShowWeekNumbersWidth 	= m.loRect.Width - This._CalendarWidth
		
		*!* Reset style:
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnOldStyle)
		
	ENDPROC

	PROCEDURE _getdwexstyle
		Return BITOR(WS_EX_TOPMOST, WS_EX_TOOLWINDOW)
		
	ENDPROC

	PROCEDURE _getdwstyle
		*!* _GetdwStyle()
		
		Local dwStyle As Integer
		
		m.dwStyle = Bitor(WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS, MCS_DAYSTATE) &&, WS_TABSTOP, WS_POPUP) WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS,
		
		If This.ctlShowToday = FALSE Then
			m.dwStyle = Bitor(m.dwStyle, MCS_NOTODAY)
		Endif
		
		If This.ctlShowTodayCircle = FALSE Then
			m.dwStyle = Bitor(m.dwStyle, MCS_NOTODAYCIRCLE)
		Endif
		
		If This.ctlShowWeekNumbers = TRUE Then
			m.dwStyle = Bitor(m.dwStyle, MCS_WEEKNUMBERS)
		Endif
		
		Return m.dwStyle
		
	ENDPROC

	PROCEDURE _getlpclassname
		*!* _GetlpClassName()
		
		Return MONTHCAL_CLASSA
		
	ENDPROC

	PROCEDURE _postcreate
		*!* _PostCreate()
		
		This._DayStatesSetup()
		
		This._SetScrollChange()
		This._SetRange()
		This._SetAutoSize()
		This._SetBackColor()
		This._SetBorderColor()
		This._SetFirstDayOfWeek()
		This._SetForeColor()
		This._SetTitleBackColor()
		This._SetTitleForeColor()
		This._SetTrailingForeColor()
		
		This.ctlUpdateBoldedDates()
		
		*This._GetDefaultColors()
		*This._GetCalendarMetrics()
		
		
	ENDPROC

	PROCEDURE _setautosize
		*!* _SetAutoSize()
		
		Local ;
			lnWidth As Integer, ;
			lnHeight As Integer, ;
			lnWidthMargin As Integer, ;
			lnHeightMargin As Integer, ;
			loRect As _RECT
		
		If This.ctlAutoSize = FALSE Then
			This.Height = This._DefaultHeight
			This.Width = This._DefaultWidth
			Return
		Endif
		
		*!* Determine Width padding:
		m.lnWidthMargin = 6 * (This.ctlCalendarDimensionsWidth - 1)
		
		If This.ctlShowWeekNumbers = TRUE Then
			m.lnWidthMargin = m.lnWidthMargin + This._ShowWeekNumbersWidth * This.ctlCalendarDimensionsWidth
		Endif
		
		*!* Determine Height padding:
		m.lnHeightMargin = 6 * (This.ctlCalendarDimensionsHeight - 1)
		
		*!* Always add _ShowTodayHeight
		m.lnHeightMargin = m.lnHeightMargin + This._ShowTodayHeight
		
		*!* Determine width and height:
		m.lnWidth = This._CalendarWidth * This.ctlCalendarDimensionsWidth + m.lnWidthMargin
		m.lnHeight = This._CalendarHeight * This.ctlCalendarDimensionsHeight + m.lnHeightMargin
		
		*!* In Vista, we use MCM_SIZERECTTOMIN to get the exact window size:
		If ctlGetOsVersion() = CON_OS_WINVISTA Then
		
			*!* Determine Top and Left of Calendar window:
			*!*		m.lnLeft = This.ctlLocationLeft
			*!*		m.lnTop  = This.ctlLocationTop
		
			*!* add half a calendar width and height just in case:
			m.lnWidth = m.lnWidth + Int(This._CalendarWidth / 2)
			m.lnHeight = m.lnHeight + Int(This._CalendarHeight / 2)
		
			m.loRect = Createobject("_RECT")
			m.lcRect = m.loRect.Value
		
			m.loRect.Left   = 0
			m.loRect.Top    = 0
			m.loRect.Right  = m.lnWidth
		
			m.loRect.Bottom = m.lnHeight
		
			apiSendMessageInteger(This._ControlHwnd, MCM_SIZERECTTOMIN, 0, m.loRect.Address)
		
			*!* Here we have exact width and height of Calendar window:
			m.lnWidth = m.loRect.Width
			m.lnHeight = m.loRect.Height
		
		Endif
		
		*!* Up to here we have standard width and height needed to display
		*!* number of calendars specified in ctlCalendarDimensionsHeight and ctlCalendarDimensionsWidth
		
		*!* Add specified border:
		m.lnHeight = m.lnHeight + This.ctlBorderWidth * 2
		m.lnWidth = m.lnWidth + This.ctlBorderWidth * 2
		
		
		*!* Now we will make minor adjustments:
		
		*!*	Do Case
		
		*!*			*!* If we are in a toolbar, we adjust the size of oBorder so the toolbar
		*!*			*!* sizes just right to contain calendar window
		*!*		Case This.Parent.BaseClass = "Toolbar"
		
		*!*			Thisform.BackColor = This._DefaultMonthBackColor
		*!*			m.lnLeft = m.lnLeft - 6
		*!*			m.lnTop = m.lnTop - 2
		
		*!*			This.Height = m.lnHeight - 6
		*!*			This.Width = m.lnWidth - 6 - 6
		
		
		*!*			*!*			With Evaluate(This._BorderName)
		*!*			*!*				.Height = m.lnHeight - 5
		*!*			*!*				.Width = m.lnWidth - 6 - 6
		*!*			*!*			Endwith
		
		*!*			*!* If we are in Vista with themes, do not use border, control has one:
		*!*		Case ctlGetOsVersion() >= CON_OS_WINVISTA And ;
		*!*				This.ctlIsThemeActive(This) = TRUE
		
		*!*			*!*			With Evaluate(This._BorderName)
		*!*			*!*				.Left = This.Left
		*!*			*!*				.Top = This.Top
		*!*			*!*				.Height = m.lnHeight
		*!*			*!*				.Width = m.lnWidth
		*!*			*!*			Endwith
		
		*!*		Otherwise
		
		*!*			This.Height = m.lnHeight
		*!*			This.Width = m.lnWidth
		
		*!*			*!*			With Evaluate(This._BorderName)
		*!*			*!*				.Left = This.Left
		*!*			*!*				.Top = This.Top
		*!*			*!*				.Height = m.lnHeight + 2
		*!*			*!*				.Width = m.lnWidth + 2
		*!*			*!*			Endwith
		
		*!*	Endcase
		
		This.Height = m.lnHeight
		This.Width = m.lnWidth
		
	ENDPROC

	PROCEDURE _setbackcolor
		*!* _SetBackColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlBackColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_MONTHBK, This.ctlDefaultBackColor)
		Else
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_MONTHBK, This.ctlBackColor)
		Endif
	ENDPROC

	PROCEDURE _setbordercolor
		*!* _SetBorderColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlBorderColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_BACKGROUND, This.ctlDefaultBorderColor)
		Else
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_BACKGROUND, This.ctlBorderColor)
		Endif
	ENDPROC

	PROCEDURE _setborderwidth
		This._SetAutoSize()
		
	ENDPROC

	PROCEDURE _setcalendarcolumns
		This._SetAutoSize()
		
	ENDPROC

	PROCEDURE _setcalendarrows
		This._SetAutoSize()
		
	ENDPROC

	PROCEDURE _setfirstdayofweek
		*!* _SetFirstDayOfWeek()
		
		
		*!* API   FOX
		*!*	MON 0 2 -2
		*!*	TUE 1 3 -2
		*!*	WED 2 4 -2
		*!*	THU 3 5 -2
		*!*	FRI 4 6 -2
		*!*	SAT 5 7 -2
		*!*	SUN 6 1
		*!* def 7 0
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		Local m.lnDayOfWeek As Integer
		
		*!* Convert VFP DOW to API DOW
		Do Case
			Case This.ctlFirstDayOfWeek = 0
				m.lnDayOfWeek = -1
			Case This.ctlFirstDayOfWeek = 1
				m.lnDayOfWeek = 6
			Otherwise
				m.lnDayOfWeek = This.ctlFirstDayOfWeek - 2
		Endcase
		
		apiSendMessageInteger(This._ControlHwnd, MCM_SETFIRSTDAYOFWEEK, 0, m.lnDayOfWeek)
		
		*!* Damn you! REDRAW the damn calendar already!:
		
		If This.ctlVisible = TRUE Then
			This.ctlVisible = FALSE
			This.ctlShowWeekNumbers = Not This.ctlShowWeekNumbers
			This.ctlShowWeekNumbers = Not This.ctlShowWeekNumbers
			This.ctlVisible = TRUE
		Endif
		
		*!*	?ctlHiWord(apiSendMessageInteger(This._ControlHwnd, MCM_GETFIRSTDAYOFWEEK, 0, 0))
		*!*	??ctlLoWord(apiSendMessageInteger(This._ControlHwnd, MCM_GETFIRSTDAYOFWEEK, 0, 0))
		
		
	ENDPROC

	PROCEDURE _setfont
		*!* _SetFont()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This._EnableUpdates = FALSE Then
			Return
		Endif
		
		DoDefault()
		
		This._GetDefaultSize()
		This._SetAutoSize()
		
	ENDPROC

	PROCEDURE _setforecolor
		*!* _SetForeColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlForeColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TEXT, This.ctlDefaultForeColor)
		Else
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TEXT, This.ctlForeColor)
		Endif
	ENDPROC

	PROCEDURE _setrange
		*!* _SetRange()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This._EnableUpdates = FALSE
			Return
		Endif
		
		Local loSystemTimeArray As _SYSTEMTIMEARRAY
		
		m.loSystemTimeArray = Createobject("_SYSTEMTIMEARRAY")
		
		With This
			m.loSystemTimeArray.Min.wYear = Year(.ctlMinDate)
			m.loSystemTimeArray.Min.wMonth = Month(.ctlMinDate)
			m.loSystemTimeArray.Min.wDayOfWeek = Dow(.ctlMinDate)
			m.loSystemTimeArray.Min.wDay = Day(.ctlMinDate)
		
			m.loSystemTimeArray.Max.wYear = Year(.ctlMaxDate)
			m.loSystemTimeArray.Max.wMonth = Month(.ctlMaxDate)
			m.loSystemTimeArray.Max.wDayOfWeek = Dow(.ctlMinDate)
			m.loSystemTimeArray.Max.wDay = Day(.ctlMaxDate)
		Endwith
		
		apiSendMessageInteger(This._ControlHwnd, MCM_SETRANGE, GDTR_MIN + GDTR_MAX, m.loSystemTimeArray.Address)
		
		m.loSystemTimeArray = .Null.
		
	ENDPROC

	PROCEDURE _setscrollchange
		*!* _SetScrollChange()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, MCM_SETMONTHDELTA, This.ctlScrollChange, 0)
	ENDPROC

	PROCEDURE _setshowtoday
		*!* _SetShowToday()
		
		Local lnStyle As Integer
		
		*!* Get current styles:
		m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
		
		*!* Remove week numbers
		m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)
		m.lnStyle = Bitxor(m.lnStyle, MCS_NOTODAY)
		
		If This.ctlShowToday = FALSE Then
			*!* Add week numbers
			m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)
		Endif
		
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)
		
		This._SetAutoSize()
	ENDPROC

	PROCEDURE _setshowtodaycircle
		*!* _SetShowTodayCircle()
		
		Local lnStyle As Integer
		
		*!* Get current styles:
		m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
		
		*!* Remove week numbers
		m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAYCIRCLE)
		m.lnStyle = Bitxor(m.lnStyle, MCS_NOTODAYCIRCLE)
		
		If This.ctlShowTodayCircle = FALSE Then
			*!* Add week numbers
			m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAYCIRCLE)
		Endif
		
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)
		
		This._SetAutoSize()
	ENDPROC

	PROCEDURE _setshowweeknumbers
		*!* _SetShowWeekNumbers()
		
		Local lnStyle As Integer
		
		*!* Get current styles:
		m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
		
		*!* Remove week numbers
		m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)
		m.lnStyle = Bitxor(m.lnStyle, MCS_WEEKNUMBERS)
		
		If This.ctlShowWeekNumbers = TRUE Then
			*!* Add week numbers
			m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)
		Endif
		
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)
		
		This._SetAutoSize()
	ENDPROC

	PROCEDURE _setthemes
		DoDefault()
		
		This._SetAutoSize()
		
	ENDPROC

	PROCEDURE _settitlebackcolor
		*!* _SetTitleBackColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlTitleBackColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLEBK, This.ctlDefaultTitleBackColor)
		Else
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLEBK, This.ctlTitleBackColor)
		Endif
	ENDPROC

	PROCEDURE _settitleforecolor
		*!* _SetTitleForeColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlTitleForeColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLETEXT, This.ctlDefaultTitleForeColor)
		Else
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLETEXT, This.ctlTitleForeColor)
		Endif
	ENDPROC

	PROCEDURE _settodaydate
		*!* _SetTodaydate()
		
		?This.ctlTodayDate
		If Empty(This.ctlTodayDate) Then
			This._TodayDateSet = FALSE
		Else
			This._TodayDateSet = TRUE
		Endif
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		Local lpSysTime As _SYSTEMTIME
		
		If Empty(This.ctlTodayDate) Then
			apiSendMessageInteger(This._ControlHwnd, MCM_SETTODAY , 0, 0)
		Else
			m.lpSysTime = Createobject("_SYSTEMTIME")
			m.lpSysTime.wYear = Year(This.ctlTodayDate)
			m.lpSysTime.wMonth = Month(This.ctlTodayDate)
			m.lpSysTime.wDay = Day(This.ctlTodayDate)
		
			apiSendMessageInteger(This._ControlHwnd, MCM_SETTODAY , 0, m.lpSysTime.Address)
		Endif
		
		m.lpSysTime = .Null.
		Release m.lpSysTime
		
	ENDPROC

	PROCEDURE _settrailingforecolor
		*!* _SetTrailingForeColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlTrailingForeColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TRAILINGTEXT, This.ctlDefaultTrailingForeColor)
		Else
			apiSendMessageInteger(This._ControlHwnd, MCM_SETCOLOR, MCSC_TRAILINGTEXT, This.ctlTrailingForeColor)
		Endif
	ENDPROC

	PROCEDURE _setvalue
		*!* _SetValue()
		
		DoDefault()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		If This._EnableUpdates = FALSE
			Return
		Endif
		
		Local lcSysTime As String, lpSysTime As _SYSTEMTIME
		
		m.lpSysTime = Createobject("_SYSTEMTIME")
		
		m.lpSysTime.wYear = Year(This.ctlValue)
		m.lpSysTime.wMonth = Month(This.ctlValue)
		m.lpSysTime.wDay = Day(This.ctlValue)
		
		
		
		apiSendMessageInteger(This._ControlHwnd, MCM_SETCURSEL , 0, m.lpSysTime.Address)
		
		m.lpSysTime = .Null.
		RELEASE m.lpSysTime
	ENDPROC

	PROCEDURE _updatecolors
		*!* _UpdateColors()
		
		This._SetBackColor()
		This._SetBorderColor()
		This._SetForeColor()
		This._SetTitleBackColor()
		This._SetTitleForeColor()
		This._SetTrailingForeColor()
		
	ENDPROC

	PROCEDURE _updatedaystates		&& Updates the date states array stored in the _DayStatesAddress memory address.
		*!* _UpdateDayStates()
		
		*!* 32 bits * 14 months = 448 bits
		*!* 32 bits * 14 months / 8 bytes = 56 bytes
		
		Lparameters pdStartDate As Date, pnMonths As Integer
		
		Local ;
			ldStartDate As Date, ;
			ldDate As Date, ;
			lcMonthDayState As String, ;
			lcDayState As String, ;
			lnMonthIdx As Integer, ;
			lnBitIdx As Integer, ;
			lnIndex As Integer, ;
			lnMonth As Integer
		
		*!* Allocate the buffer for the daystates array if not yet allocated:
		If This._DayStatesAddress = 0 Then
			This._DayStatesAddress = apiHeapAlloc(apiGetProcessHeap(), HEAP_ZERO_MEMORY, 56)
		Endif
		
		*!* Array of days
		m.lcMonthDayState = ""
		
		*!* StartDate should be always the first day of a month
		m.ldStartDate = Date(Year(m.pdStartDate), Month(m.pdStartDate), 1)
		
		*!* Init date for first month
		m.ldDate = m.ldStartDate
		
		For m.lnMonthIdx = 1 To m.pnMonths
		
			*!* Array of days for one month
			*m.lcDayState = 0h00000000
		
			*!* Save current month # so we can check if we finished with month
			m.lnMonth = Month(m.ldDate)
		
			m.lcDayState = Bitor(This._DayStates(m.lnMonth), This._DayStates(13))
		
			For m.lnBitIdx  = 0 To 30
		
				*!* Do we have any dates in WeeklyBoldedDates?
				If Vartype(This.ctlWeeklyBoldedDates(1)) = T_DATE
					For m.lnIndex = 1 To Alen(This.ctlWeeklyBoldedDates, 1)
						If Dow(m.ldDate) = Dow(This.ctlWeeklyBoldedDates(m.lnIndex)) Then
							m.lcDayState = Bitset(m.lcDayState, m.lnBitIdx , 1)
						Endif
					Endfor
				Endif
		
				*!* Do we have any dates in BoldedDates?
				If Vartype(This.ctlBoldedDates(1)) = T_DATE
					For m.lnIndex= 1 To Alen(This.ctlBoldedDates, 1)
						If m.ldDate = This.ctlBoldedDates(m.lnIndex) Then
							m.lcDayState = Bitset(m.lcDayState, m.lnBitIdx , 1)
						Endif
					Endfor
				Endif
		
				*!* Do next day in month
				m.ldDate = m.ldDate + 1
		
				*!* Are we still in the same month?
				If Month(m.ldDate) # m.lnMonth
					Exit
				Endif
			Endfor
		
			*!* We finished one month, add array of days of month to array of days:
			m.lcMonthDayState = m.lcMonthDayState + m.lcDayState
		
			*!* go to first day of next month:
			m.ldDate = Gomonth(m.ldStartDate, m.lnMonthIdx)
		Endfor
		
		*!* pad 'array' to cover 14 months always 
		*!* 14 months * 4 bytes each = 56 bytes
		m.lcMonthDayState = Padr(m.lcMonthDayState, 56, 0h00)
		
		*!* Write array back to memory pointer:
		Sys(2600, This._DayStatesAddress, Len(m.lcMonthDayState), m.lcMonthDayState)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_openfiledialog AS ctl32_filedialog OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_openfiledialog.bmp" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*p: ctlmultiselect		&& Gets or sets a value indicating whether the dialog box allows multiple files to be selected.
		*p: ctlreadonlychecked		&& Gets or sets a value indicating whether the read-only check box is selected.
		*p: ctlshowreadonly		&& Gets or sets a value indicating whether the dialog box contains a read-only check box.
	*</DefinedPropArrayMethod>

	ctlmultiselect = .F.		&& Gets or sets a value indicating whether the dialog box allows multiple files to be selected.
	ctlreadonlychecked = .F.		&& Gets or sets a value indicating whether the read-only check box is selected.
	ctlshowreadonly = .F.		&& Gets or sets a value indicating whether the dialog box contains a read-only check box.
	Name = "ctl32_openfiledialog"
	_dialogtype = OPEN
	lblname.Caption = "ctl32_openfiledialog"
	lblname.Name = "lblname"

ENDDEFINE

DEFINE CLASS ctl32_openpictdialog AS ctl32_openfiledialog OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "ctl32_openpictdialog"
	lblname.Caption = "ctl32_openpictdialog"
	lblname.Name = "lblname"

ENDDEFINE

DEFINE CLASS ctl32_progressbar AS ctl32_controlbase OF "ctl32.vcx" 		&& progress bar class
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="backup\ctl32_progressbar.bmp" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlbarcolor_access
		*m: ctlbarcolor_assign
		*m: ctlcaption_access
		*m: ctlincrement		&& Advances the current position of the progress bar by the specified amount.
		*m: ctlmarqueeanimationspeed_access
		*m: ctlmarqueeanimationspeed_assign
		*m: ctlmarqueespeed_assign
		*m: ctlmarquee_assign
		*m: ctlmaximumbytes_access
		*m: ctlmaximum_assign
		*m: ctlminimumbytes_access
		*m: ctlminimum_assign
		*m: ctlpercent_access
		*m: ctlperformstep		&& Advances the current position of the progress bar by the amount of the ctlStep property.
		*m: ctlplay_assign
		*m: ctlreset		&& Resets the Value property to ctlMinimum or to ctlMaximum with an optional parameter.
		*m: ctlsizeadjust_access
		*m: ctlsizeadjust_assign
		*m: ctlsmooth_assign
		*m: ctlstate_assign
		*m: ctlstepit		&& Increments the value of the control by the amount specified in ctlStep.
		*m: ctlstep_assign
		*m: ctlstyle_assign
		*m: ctlvaluebytes_access
		*m: ctlvaluepercent_access
		*m: ctlvertical_assign
		*m: _playtimertick
		*m: _setmarquee
		*m: _setmarqueespeed
		*m: _setplay
		*m: _setrange
		*m: _setsmooth
		*m: _setstate
		*m: _setstep
		*m: _setstyle
		*p: ctlbarcolor		&& DEPRECATED. Replaced by the .NET ctlForeColor property.
		*p: ctlcaption		&& DEPRECATED.
		*p: ctlformat		&& DEPRECATED.
		*p: ctlmarquee		&& Indicates progress by continuously scrolling a block across a ProgressBar in a marquee fashion.
		*p: ctlmarqueeanimationspeed		&& Gets or sets the time period, in milliseconds, that it takes the progress block to scroll across the progress bar.
		*p: ctlmarqueespeed		&& DEPRECATED. Replaced by the .NET ctlMarqueeAnimationSpeed property.
		*p: ctlmaximum		&& Gets or sets the maximum value of the range of the control.
		*p: ctlmaximumbytes		&& Gets the Maximum value as a string formatted in Bytes/MB/GB/TB.
		*p: ctlminimum		&& Gets or sets the minimum value of the range of the control.
		*p: ctlminimumbytes		&& Gets the Minimum value as a string formatted in Bytes/MB/GB/TB.
		*p: ctlpercent		&& Gets a value representing a percent of Value vs Maximum - Minimum
		*p: ctlplay		&& Specifies if the progress bar should increment its value automatically.
		*p: ctlrepeat		&& DEPRECATED.
		*p: ctlsizeadjust		&& DEPRECATED. Replaced by the .NET ctlAutoSize property.
		*p: ctlsmooth		&& Specifies if the bar will be shown as one continous block, or as a group of small individual blocks.
		*p: ctlstate		&& VISTA. Sets the state of the progress bar: Normal, Error or Paused.
		*p: ctlstep		&& Gets or sets the amount by which the PerformStep method increases the current position of the progress bar.
		*p: ctlstyle		&& NOT LIKE THE .NET PROPERTY. Specifies the style of the progress bar border.
		*p: ctlvaluebytes		&& Gets the current value as a string formatted in Bytes/MB/GB/TB.
		*p: ctlvaluepercent		&& Returns a character string of the current ctlPercent value formatted with a % sign.
		*p: ctlvertical		&& DEPRECATED. Replaced by the .NET ctlOrientation property.
		*p: _playtimerid
	*</DefinedPropArrayMethod>

	ctlbarcolor = -1		&& DEPRECATED. Replaced by the .NET ctlForeColor property.
	ctlcaption = .F.		&& DEPRECATED.
	ctlformat = .F.		&& DEPRECATED.
	ctlmarquee = .F.		&& Indicates progress by continuously scrolling a block across a ProgressBar in a marquee fashion.
	ctlmarqueeanimationspeed = 100		&& Gets or sets the time period, in milliseconds, that it takes the progress block to scroll across the progress bar.
	ctlmarqueespeed = 100		&& DEPRECATED. Replaced by the .NET ctlMarqueeAnimationSpeed property.
	ctlmaximum = 100		&& Gets or sets the maximum value of the range of the control.
	ctlmaximumbytes = 0		&& Gets the Maximum value as a string formatted in Bytes/MB/GB/TB.
	ctlminimum = 0		&& Gets or sets the minimum value of the range of the control.
	ctlminimumbytes = 0		&& Gets the Minimum value as a string formatted in Bytes/MB/GB/TB.
	ctlpercent = 0		&& Gets a value representing a percent of Value vs Maximum - Minimum
	ctlplay = .F.		&& Specifies if the progress bar should increment its value automatically.
	ctlrepeat = .F.		&& DEPRECATED.
	ctlsizeadjust = .F.		&& DEPRECATED. Replaced by the .NET ctlAutoSize property.
	ctlsmooth = .F.		&& Specifies if the bar will be shown as one continous block, or as a group of small individual blocks.
	ctlstate = 1		&& VISTA. Sets the state of the progress bar: Normal, Error or Paused.
	ctlstep = 1		&& Gets or sets the amount by which the PerformStep method increases the current position of the progress bar.
	ctlstyle = 1		&& NOT LIKE THE .NET PROPERTY. Specifies the style of the progress bar border.
	ctlvaluebytes = .F.		&& Gets the current value as a string formatted in Bytes/MB/GB/TB.
	ctlvaluepercent = .F.		&& Returns a character string of the current ctlPercent value formatted with a % sign.
	ctlvertical = .F.		&& DEPRECATED. Replaced by the .NET ctlOrientation property.
	Height = 18
	Name = "ctl32_progressbar"
	Width = 301
	_playtimerid = 0
	ctlTextBox.Name = "ctlTextBox"
	lblname.Caption = "ctl32_progressbar"
	lblname.Name = "lblname"
	
	PROCEDURE ctlbarcolor_access
		*!* ctlBarColor_Access()
		
		Return This.ctlForeColor
		
	ENDPROC

	PROCEDURE ctlbarcolor_assign
		*!* ctlBarColor_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		This.ctlForeColor = m.tuNewValue
		
		
	ENDPROC

	PROCEDURE ctlcaption_access
		*!* ctlCaption_Access()
		
		If Empty(This.ctlFormat) Then
		    Return ""
		Endif
		
		Local ;
		    lcValB, ;
		    lcValN, ;
		    lcValP, ;
		    lcMaxB, ;
		    lcMaxN, ;
		    lcMaxP, ;
		    lcMinB, ;
		    lcMinN, ;
		    lcMinP, ;
		    lcOut
		
		m.lcValN = Transform(This.ctlValue,   "999,999,999,999")
		m.lcMaxN = Transform(This.ctlMaximum, "999,999,999,999")
		m.lcMinN = Transform(This.ctlMinimum, "999,999,999,999")
		
		m.lcValP = Transform(This.ctlPercent, "999%")
		m.lcMaxP = "100%"
		m.lcMinP = "0%"
		
		m.lcValB = ctlStrFormatByteSize(This.ctlValue)
		m.lcMaxB = ctlStrFormatByteSize(This.ctlMaximum)
		m.lcMinB = ctlStrFormatByteSize(This.ctlMinimum)
		
		m.lcOut = This.ctlFormat
		m.lcOut = Strtran(m.lcOut , "ValBytes",   Alltrim(m.lcValB), 1, 99, 1)
		m.lcOut = Strtran(m.lcOut , "ValNumber",  Alltrim(m.lcValN), 1, 99, 1)
		m.lcOut = Strtran(m.lcOut , "ValPercent", Alltrim(m.lcValP), 1, 99, 1)
		
		m.lcOut = Strtran(m.lcOut , "MaxBytes",   Alltrim(m.lcMaxB), 1, 99, 1)
		m.lcOut = Strtran(m.lcOut , "MaxNumber",  Alltrim(m.lcMaxN), 1, 99, 1)
		m.lcOut = Strtran(m.lcOut , "MaxPercent", Alltrim(m.lcMaxP), 1, 99, 1)
		
		m.lcOut = Strtran(m.lcOut , "MinBytes",   Alltrim(m.lcMinB), 1, 99, 1)
		m.lcOut = Strtran(m.lcOut , "MinNumber",  Alltrim(m.lcMinN), 1, 99, 1)
		m.lcOut = Strtran(m.lcOut , "MinPercent", Alltrim(m.lcMinP), 1, 99, 1)
		
		Return m.lcOut
		
	ENDPROC

	PROCEDURE ctldefaultheight_access
		*!* ctlDefaultHeight_Access()
		
		Return Round((This.Height - 8)/8,0) * 8 + 5
		
	ENDPROC

	PROCEDURE ctldefaultwidth_access
		*!* ctlDefaultWidth_Access()
		
		Return Round((This.Width - 5)/8,0) * 8 + 5
		
	ENDPROC

	PROCEDURE ctldispose
		*!* ctlDispose()
		
		If This._PlayTimerId # 0 Then
			apiKillTimer(This.ctlHostFormhWnd, This._PlayTimerId)
			This._PlayTimerId = 0
		Endif
		
		DoDefault()
	ENDPROC

	PROCEDURE ctlincrement		&& Advances the current position of the progress bar by the specified amount.
		*!* ctlIncrement(nValue)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) # T_NUMERIC Then
			m.tuNewValue= This.ctlStep
		Endif
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		*!* 20070812 Only send this message if Marquee style is off
		If This.ctlMarquee = TRUE Then
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, PBM_DELTAPOS, m.tuNewValue, 0)
		
		This._EnableUpdates = FALSE
		This.ctlValue = apiSendMessageInteger(This._ControlHwnd, PBM_GETPOS, 0, 0)
		This._EnableUpdates = TRUE
		
	ENDPROC

	PROCEDURE ctlmarqueeanimationspeed_access
		*!* ctlMarqueeAnimationSpeed_Access()
		
		Return This.ctlMarqueeSpeed
		
	ENDPROC

	PROCEDURE ctlmarqueeanimationspeed_assign
		*!* ctlMarqueeAnimationSpeed_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		This.ctlMarqueeSpeed = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlmarqueespeed_assign
		*!* ctlMarqueeSpeed_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If This.ctlMarqueeSpeed # m.tuNewValue Then
			This.ctlMarqueeSpeed = m.tuNewValue
			This._SetMarqueeSpeed()
		Endif
		
	ENDPROC

	PROCEDURE ctlmarquee_assign
		*!* ctlMarquee_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlMarquee # m.tuNewValue Then
			This.ctlMarquee = m.tuNewValue
			This._SetMarquee()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlmaximumbytes_access
		Return ctlStrFormatByteSize(This.ctlMaximum)
		
	ENDPROC

	PROCEDURE ctlmaximum_assign
		*!* ctlSetMaximum_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If This.ctlMaximum # m.tuNewValue Then
			This.ctlMaximum = m.tuNewValue
			This._SetRange()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlminimumbytes_access
		Return ctlStrFormatByteSize(This.ctlMinimum)
		
	ENDPROC

	PROCEDURE ctlminimum_assign
		*!* ctlSetMinimum_Assign(nValue)
		
		Lparameters m.tuNewValue
		
		If This.ctlMinimum # m.tuNewValue Then
			This.ctlMinimum = m.tuNewValue
			This._SetRange()
		Endif
		
	ENDPROC

	PROCEDURE ctlpercent_access
		Return Int(100 * (This.ctlValue - This.ctlMinimum) / (Abs(This.ctlMaximum - This.ctlMinimum)))
		
		
	ENDPROC

	PROCEDURE ctlperformstep		&& Advances the current position of the progress bar by the amount of the ctlStep property.
		*!* ctlPerformStep()
		
		This.ctlIncrement(This.ctlStep)
	ENDPROC

	PROCEDURE ctlplay_assign
		*!* ctlPlay_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue = m.tuNewValue # 0
		Endif
		
		If This.ctlPlay # m.tuNewValue Then
			This.ctlPlay = m.tuNewValue
			This._SetPlay()
		Endif
		
		
		
	ENDPROC

	PROCEDURE ctlreset		&& Resets the Value property to ctlMinimum or to ctlMaximum with an optional parameter.
		*!* ctlReset(ToMaximum)
		
		Lparameters m.ToMaximum
		
		If Pcount() = 0 Then
			This.ctlValue = This.ctlMinimum
		Else
			This.ctlValue = This.ctlMaximum
		Endif
		
	ENDPROC

	PROCEDURE ctlsizeadjust_access
		*!* ctlSizeAdjust_Access()
		
		Return This.ctlAutoSize
		
	ENDPROC

	PROCEDURE ctlsizeadjust_assign
		*!* ctlSizeAdjust_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		This.ctlAutoSize = m.tuNewValue
		
	ENDPROC

	PROCEDURE ctlsmooth_assign
		*!* ctlSmooth_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue= m.tuNewValue # 0
		Endif
		
		If This.ctlSmooth # m.tuNewValue Then
			This.ctlSmooth = m.tuNewValue
			This._SetSmooth()
		Endif
		
		
		
	ENDPROC

	PROCEDURE ctlstate_assign
		*!* ctlState_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If This.ctlState # m.tuNewValue Then
			This.ctlState = m.tuNewValue
			This._SetState()
		Endif
		
		
		
	ENDPROC

	PROCEDURE ctlstepit		&& Increments the value of the control by the amount specified in ctlStep.
		*!* ctlStepIt(nStep)
		
		Lparameters m.tnStep As Integer
		
		If This.ctlMarquee = TRUE Then
			Return
		Endif
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		*!* If numeric parameter, set step value
		If Vartype(m.tnStep) = T_NUMERIC And m.tnStep <> This.ctlStep Then
			apiSendMessageInteger(This._ControlHwnd, PBM_SETSTEP, m.tnStep, 0)
		Endif
		
		*!* Send ctlStepIt message:
		apiSendMessageInteger(This._ControlHwnd, PBM_STEPIT, 0, 0)
		
		*!* If numeric parameter, reset step value
		If Vartype(m.tnStep) = T_NUMERIC And m.tnStep <> This.ctlStep Then
			apiSendMessageInteger(This._ControlHwnd, PBM_SETSTEP, This.ctlStep, 0)
		Endif
		
		*!* Prevent value updating recursion
		This._EnableUpdates = FALSE
		This.ctlValue = apiSendMessageInteger(This._ControlHwnd, PBM_GETPOS, 0, 0)
		This._EnableUpdates = TRUE
		
		
	ENDPROC

	PROCEDURE ctlstep_assign
		*!* ctlStep_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If This.ctlStep # m.tuNewValue Then
			This.ctlStep = m.tuNewValue
			This._SetStep()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlstyle_assign
		*!* ctlStyle_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If This.ctlStyle # m.tuNewValue Then
			This.ctlStyle = m.tuNewValue
			This._SetStyle()
		Endif
		
		*!* 1 normal 3d border (only when theme is off)
		*!* 2 flat no border
		*!* 3 flat with border (adds proxy window and uses container border)
		
		
	ENDPROC

	PROCEDURE ctlvaluebytes_access
		Return ctlStrFormatByteSize(This.ctlValue)
		
	ENDPROC

	PROCEDURE ctlvaluepercent_access
		Return Transform(Int(100 * (This.ctlValue - This.ctlMinimum) / (Abs(This.ctlMaximum - This.ctlMinimum)))) + " %"
		
	ENDPROC

	PROCEDURE ctlvertical_assign
		*!* ctlVertical_Assign(vNewVal)
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue= m.tuNewValue # 0
		Endif
		
		This.ctlVertical = m.tuNewValue
		
		This.ctlOrientation = Iif(This.ctlVertical, 1, 0)
		
		
	ENDPROC

	PROCEDURE _formmessagehandler
		*!* _FormMessageHandler()
		
		DoDefault()
		
		Do Case
		
			Case Thisform.BindWindowsEventsProxy._Msg = WM_TIMER And Thisform.BindWindowsEventsProxy._wParam = This._PlayTimerId
				This._PlayTimerTick()
		Endcase
		
	ENDPROC

	PROCEDURE _getdwstyle
		*!* _GetdwStyle()
		
		Local dwStyle As Integer
		
		m.dwStyle = Bitor(WS_CHILD, WS_CLIPSIBLINGS)
		
		*!* Setup Control specific Styles that have to be set at window creation:
		*!* ctlMarquee
		If This.ctlMarquee = TRUE Then
			m.dwStyle = Bitor(m.dwStyle, PBS_MARQUEE)
		Endif
		
		*!* ctlSmooth
		If This.ctlSmooth = TRUE And This.ctlMarquee = FALSE Then
			m.dwStyle = Bitor(m.dwStyle, PBS_SMOOTH)
		Endif
		
		*!* Orientation
		If This.ctlOrientation = 1 Or This.ctlVertical Then
			m.dwStyle = Bitor(m.dwStyle, PBS_VERTICAL)
		Endif
		
		Return m.dwStyle
		
	ENDPROC

	PROCEDURE _getlpclassname
		*!* _GetlpClassName()
		
		Return PROGRESS_CLASSA
		
	ENDPROC

	PROCEDURE _onresize
		*!* _OnResize()
		
		DoDefault()
		
		*!* If ctlStyle # 1 then we have to update the window region:
		If This.ctlStyle # 1 Then
			This._SetStyle()
		Endif
		
	ENDPROC

	PROCEDURE _playtimertick
		*!* _PlayTimerTick()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlMarquee = TRUE Then
			Return
		Endif
		
		*!* Send ctlStepIt message:
		apiSendMessageInteger(This._ControlHwnd, PBM_STEPIT, 0, 0)
		
		*!* Prevent value updating recursion
		This._EnableUpdates = FALSE
		This.ctlValue = apiSendMessageInteger(This._ControlHwnd, PBM_GETPOS, 0, 0)
		This._EnableUpdates = TRUE
		
	ENDPROC

	PROCEDURE _postcreate
		*!* Set ctlMinimum and ctlMaximum values:
		This._SetRange()
		
		*!* Set Control ctlStep Value
		This._SetStep()
		
		*!* Set ctlMarqueeSpeed Value
		This._SetMarqueeSpeed()
		
		*!* Set ctlPlay state
		This._SetPlay()
		
		*!* Set Colors
		This._SetBackColor()
		This._SetForeColor()
		This._SetBorderColor()
		
		This._SetState()
		
		This._SetStyle()
	ENDPROC

	PROCEDURE _precreate
		*!* _PreCreate()
		
		If This.ctlAutoSize Or This.ctlSizeAdjust = TRUE Then
			This._SetAutoSize()
		Endif
		
	ENDPROC

	PROCEDURE _setautosize
		*!* _SetAutosize()
		
		Local lnAnchor As Integer
		
		m.lnAnchor = This.Anchor
		
		This.Anchor = 0
		
		If This.ctlAutoSize = TRUE Then
		
			If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
				This.Height = This.ctlDefaultHeight
			Else
				This.Width = This.ctlDefaultWidth
			Endif
		
		Endif
		
		This.Anchor = m.lnAnchor
		
	ENDPROC

	PROCEDURE _setbackcolor
		*!* _SetBackColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlBackColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, PBM_SETBKCOLOR, 0, CLR_DEFAULT)
		Else
			apiSendMessageInteger(This._ControlHwnd, PBM_SETBKCOLOR, 0, This.ctlBackColor)
		Endif
	ENDPROC

	PROCEDURE _setbordercolor
		*!* _SetBorderColor()
		
		This.BorderColor = Iif(This.ctlBorderColor = -1, This.ctlDefaultBorderColor, This.ctlBorderColor)
		
		
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE _setforecolor
		*!* _SetForeColor()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If This.ctlForeColor = -1 Then
			apiSendMessageInteger(This._ControlHwnd, PBM_SETBARCOLOR, 0, CLR_DEFAULT)
		Else
			apiSendMessageInteger(This._ControlHwnd, PBM_SETBARCOLOR, 0, This.ctlForeColor)
		Endif
		
	ENDPROC

	PROCEDURE _setmarquee
		*!* _SetMarquee()
		
		*!* change needs to recreate Control
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		This._Create()
	ENDPROC

	PROCEDURE _setmarqueespeed
		*!* _SetMarqueeSpeed()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, PBM_SETMARQUEE, 1, This.ctlMarqueeSpeed)
		
	ENDPROC

	PROCEDURE _setorientation
		*!* _SetOrientation()
		
		Local ;
			lnAnchor As Integer, ;
			lnWidth As Integer, ;
			llVisible As Boolean
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		m.lnAnchor = This.Anchor
		m.lnWidth = This.Width
		m.llVisible = This.ctlVisible
		
		This.ctlVisible = FALSE
		This.Anchor = 0
		
		*!* ctlVertical change needs to recreate Control
		This._Create()
		
		This.Width = This.Height
		This.Height = m.lnWidth
		
		This.Anchor = m.lnAnchor
		This.ctlVisible = m.llVisible
		
	ENDPROC

	PROCEDURE _setplay
		*!* _SetPlay()
		
		If This._PlayTimerId # 0 Then
			apiKillTimer(This.ctlHostFormhWnd, This._PlayTimerId)
			This._PlayTimerId = 0
		Endif
		
		If This.ctlPlay = TRUE Then
			This._PlayTimerId = apiGetTickCount()
			apiSetTimer(This.ctlHostFormhWnd, This._PlayTimerId, 200, 0)
		Endif
		
	ENDPROC

	PROCEDURE _setrange
		*!* _SetRange()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		*!* Set ctlMinimum and ctlMaximum values:
		apiSendMessageInteger(This._ControlHwnd, PBM_SETRANGE32, This.ctlMinimum, This.ctlMaximum)
		
	ENDPROC

	PROCEDURE _setsmooth
		*!* _SetSmooth()
		
		*!* ctlSmooth change needs to recreate Control
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		This._Create()
	ENDPROC

	PROCEDURE _setstate
		*!* _SetState()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		If ctlGetOsVersion() >= NTDDI_VISTA Then
			apiSendMessageInteger(This._ControlHwnd, PBM_SETSTATE, This.ctlState, 0)
		Endif
		
		
	ENDPROC

	PROCEDURE _setstep
		*!* _SetStep()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		*!* Set ctlStep Value
		apiSendMessageInteger(This._ControlHwnd, PBM_SETSTEP, This.ctlStep, 0)
		
	ENDPROC

	PROCEDURE _setstyle
		*!* _SetStyle()
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		Local ;
			lnRegion As Integer, ;
			lnStyle As Integer
		
		m.lnStyle = Min(Max(This.ctlStyle, 1), 3)
		
		Do Case
		
			Case ctlIsThemeActive(This)
				apiSetWindowRgn(This._ControlHwnd, 0, 1)
				apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, 0)
				*!* Refresh control window so border gets redrawn
				apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))
		
			Case m.lnStyle = 1
				apiSetWindowRgn(This._ControlHwnd, 0, 1)
				apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, WS_EX_STATICEDGE)
				*!* Refresh control window so border gets redrawn
				apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))
		
			Case m.lnStyle = 2
				apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, 0)
				*!* Refresh control window so border gets redrawn
				apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))
				m.lnRegion = apiCreateRectRgn(1, 1, This.Width - 1, This.Height - 1)
				apiSetWindowRgn(This._ControlHwnd, m.lnRegion, 1)
				apiDeleteObject(m.lnRegion)
		
			Case m.lnStyle = 3
				apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, 0)
				*!* Refresh control window so border gets redrawn
				apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))
				m.lnRegion = apiCreateRectRgn(1, 1, This.Width - 1, This.Height - 1)
				apiSetWindowRgn(This._ControlHwnd, m.lnRegion, 1)
				apiDeleteObject(m.lnRegion)
		
		Endcase
		
		This._SetVisible()
		
		
	ENDPROC

	PROCEDURE _setthemes
		*!* _SetThemes()
		
		DoDefault()
		
		This._SetStyle()
	ENDPROC

	PROCEDURE _setvalue
		*!* _SetValue()
		
		DoDefault()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		*!* 20070812 Only send this message if Marquee style is off
		If This.ctlMarquee = TRUE Then
			Return
		Endif
		
		If This._EnableUpdates = FALSE
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, PBM_SETPOS, This.ctlValue, 0)
		
		
		
	ENDPROC

	PROCEDURE _setvisible
		DoDefault()
		
		If This.ctlStyle # 3 Then
			This.Visible = FALSE
		Endif
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_rawprint AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlcloseprinter
		*m: ctlfoxprinter_access
		*m: ctlgetrawprinter
		*m: ctlisprinteropen
		*m: ctlopenprinter
		*m: ctlprint		&& Prints a character string on a Form object.
		*m: ctlprintercount_access
		*m: ctlprinterexists
		*m: ctlprintfile
		*m: ctlrestorerawprinter
		*m: ctlsaverawprinter
		*m: ctlwindowsprinter_access
		*m: _addobjects
		*m: _addproperties
		*m: _clearlasterror
		*m: _getlasterror
		*m: _initproperties
		*m: _startdocprinter
		*p: ctlautocrlf		&& Specifies if ctlPrint appends a CRLF
		*p: ctldocumentname
		*p: ctlfoxprinter
		*p: ctllasterrorcode
		*p: ctllasterrortext
		*p: ctloutputfile
		*p: ctlprintercount
		*p: ctlrawprinter
		*p: ctlwindowsprinter
		*p: _docstarted
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _printerhandle
	*</DefinedPropArrayMethod>

	HIDDEN _docstarted,_printerhandle
	BackColor = 140,200,200
	ctlautocrlf = .F.		&& Specifies if ctlPrint appends a CRLF
	ctldocumentname = 
	ctlfoxprinter = 
	ctllasterrorcode = 
	ctllasterrortext = 
	ctloutputfile = 
	ctlprintercount = 0
	ctlrawprinter = 
	ctlwindowsprinter = 
	Height = 23
	Name = "ctl32_rawprint"
	Visible = .F.
	Width = 96
	_docstarted = .F.
	_printerhandle = 0

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_rawprint", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 3, ;
		Width = 71
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE ctlcloseprinter
		*!* ClosePrinter()
		
		Local ;
			lnApiRetVal As Integer, ;
			llClosePrinter As Boolean
		
		m.llClosePrinter = FALSE
		
		If This._DocStarted Then
			apiEndDocPrinter(This._PrinterHandle)
			This._DocStarted = FALSE
		Endif
		
		m.lnApiRetVal = apiClosePrinter(This._PrinterHandle)
		
		This._PrinterHandle = 0
		
		If m.lnApiRetVal = 0 Then
			This._GetLastError()
			m.llClosePrinter = FALSE
		Else
			This._ClearLastError()
			m.llClosePrinter = TRUE
		Endif
		
		Return m.llClosePrinter
		
		
	ENDPROC

	PROCEDURE ctlfoxprinter_access
		Return Set("Printer", 3)
		
	ENDPROC

	PROCEDURE ctlgetrawprinter
		*!* GetRawPrinter()
		
		Local ;
			lcRawPrinter As String, ;
			lcFoxPrinter As String, ;
			llGetRawPrinter As Boolean
		
		m.llGetRawPrinter = FALSE
		
		*!* Save current default printer
		m.lcFoxPrinter = This.ctlFoxPrinter
		
		*!* Set current Fox printer to current Raw printer,
		*!* so it shows selected in printer selection
		*!* dialog box
		If This.ctlPrinterExists(This.ctlRawPrinter) Then
			Set Printer To Name (This.ctlRawPrinter)
		Endif
		
		*!* Save current value of RawPrinter in case user cancels
		m.lcRawPrinter =This.ctlRawPrinter
		
		*!* Show Choose a printer dialog
		This.ctlRawPrinter = Getprinter()
		
		*!* Restore Fox default printer
		Set Printer To Name (m.lcFoxPrinter)
		
		*!* If nothing was selected, revert to old value
		If Empty(This.ctlRawPrinter) Then
			This.ctlRawPrinter = m.lcRawPrinter
			m.llGetRawPrinter = FALSE
		Else
			m.llGetRawPrinter = TRUE
		Endif
		
		*!* If printer was changed, close (if open) previous printer
		If Not m.lcRawPrinter == This.ctlRawPrinter Then
			If This.ctlIsPrinterOpen() Then
				This.ctlClosePrinter()
			Endif
		Endif
		
		*!* Specifies if a RawPrinter was selected, or the dialog was cancelled
		Return m.llGetRawPrinter
		
	ENDPROC

	PROCEDURE ctlisprinteropen
		*!* IsPrinterOpen()
		
		Return This._PrinterHandle <> 0
		
	ENDPROC

	PROCEDURE ctlopenprinter
		*!* OpenPrinter(cRawPrinter)
		
		Lparameters m.pcRawPrinter As String
		
		Local ;
			lnPrinterHandle As Integer, ;
			lnDefault As Integer, ;
			lnApiRetVal As Integer
		
		If Vartype(m.pcRawPrinter) <> "C" Then
			m.pcRawPrinter = This.ctlRawPrinter
		Endif
		
		*!* Close printer if it is already open
		If This.ctlIsprinterOpen() = TRUE Then
			This.ctlClosePrinter()
		Endif
		
		m.lnPrinterHandle = 0
		m.lnDefault  = 0
		
		m.lnApiRetVal = apiOpenPrinter(m.pcRawPrinter, @m.lnPrinterHandle, m.lnDefault)
		
		If m.lnApiRetVal = 0 Then
			This._GetLastError()
			Return FALSE
		Else
			This._ClearLastError()
		Endif
		
		This._PrinterHandle = m.lnPrinterHandle
		
		Return
		
	ENDPROC

	PROCEDURE ctlprint		&& Prints a character string on a Form object.
		*!* Print(cString)
		Lparameters m.pcString As String
		
		Local ;
			lnStringLen As Integer, ;
			lnPrintedBytes As Integer, ;
			lnApiRetVal As Integer
		
		If Empty(m.pcString) Then
			Return 0
		Endif
		
		If This._PrinterHandle = 0 Then
			If This.ctlOpenPrinter() = FALSE
				Return 0
			Endif
		Endif
		
		If This.ctlAutoCrLf = TRUE And Right(m.pcString, 2) # CRLF Then
			m.pcString = m.pcString + CRLF
		Endif
		
		m.lnStringLen = Len(m.pcString)
		m.lnPrintedBytes = 0
		
		If This._DocStarted = FALSE Then
			If This._StartDocPrinter() = FALSE Then
				Return 0
			Endif
		Endif
		
		m.lnApiRetVal = apiWritePrinter(This._PrinterHandle, m.pcString, m.lnStringLen, @m.lnPrintedBytes)
		
		If m.lnApiRetVal = 0 Then
			This._GetLastError()
			Return FALSE
		Else
			This._ClearLastError()
		Endif
		
		Return m.lnPrintedBytes
		
	ENDPROC

	HIDDEN PROCEDURE ctlprintercount_access
		*!* PrinterCount_Access()
		
		Local Array laPrinters(1)
		
		Return Aprinters(m.laPrinters)
		
		
		
	ENDPROC

	PROCEDURE ctlprinterexists
		*!* PrinterExists(cPrinterName)
		
		Lparameters m.pcPrinterName As String
		
		Local Array laPrinters(1, 2)
		Local lnPrinterCount
		
		m.lnPrinterCount = Aprinters(m.laPrinters)
		
		If m.lnPrinterCount = 0 Then
			Return FALSE
		Endif
		
		Return Ascan(m.laPrinters, m.pcPrinterName) <> 0
		
		
		
		
	ENDPROC

	PROCEDURE ctlprintfile
		*!* PrintFile(cFileName)
		
		Lparameters m.pcFileName As String
		
		Local lcString As String
		
		If Vartype(m.pcFileName) <> "C" Then
			Return 0
		Endif
		
		If Empty(m.pcFileName) Then
			Return 0
		Endif
		
		If Not File(m.pcFileName) Then
			Return 0
		Endif
		
		If This._PrinterHandle = 0 Then
			If This.ctlOpenPrinter() = FALSE
				Return 0
			Endif
		Endif
		
		m.lcString = Filetostr(m.pcFileName)
		
		Return This.ctlPrint(m.lcString)
		
	ENDPROC

	PROCEDURE ctlrestorerawprinter
		*!* RestoreRawPrinter()
		
		If Vartype(This.ctlRawPrinter) <> "C" Then
			This.ctlRawPrinter = ""
		Endif
		
		If Empty(This.ctlRawPrinter) Then
			This.ctlRawPrinter = This.ctlFoxPrinter
		Endif
		
		*!* Get registry data, if any, use actual form data as default
		This.ctlRawPrinter = This.oRegistry.GetValue("RawPrint\RawPrinterName", This.ctlRawPrinter)
		
	ENDPROC

	PROCEDURE ctlsaverawprinter
		*!* SaveRawPrinter()
		
		*!* Store data in Windows registry:
		This.oRegistry.SetValue("RawPrint\RawPrinterName", This.ctlRawPrinter)
		
	ENDPROC

	PROCEDURE ctlwindowsprinter_access
		Return Set("Printer", 2)
	ENDPROC

	PROCEDURE Destroy
		This.ctlSaveRawPrinter()
		This.ctlClosePrinter()
		
	ENDPROC

	PROCEDURE Init
		*!* Init
		
		*!* Based on the rawprint class downloaded from the Internet
		*!* Unknown source, please report original author to acknowledge credit.
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		This._AddObjects()
		This._AddProperties()
		This._InitProperties()
		
		*!* Restore RawPrinterName from the registry
		This.ctlRestoreRawPrinter()
		
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _addobjects
		*!* _AddObjects()
		
		*!* Add registry object
		This.AddObject("oRegistry", "ctl32_Registry")
		This.oRegistry.RegistryKey = HKEY_CURRENT_USER
		
	ENDPROC

	HIDDEN PROCEDURE _addproperties
	ENDPROC

	HIDDEN PROCEDURE _clearlasterror
		*!* _ClearLastError()
		
		This.ctlLastErrorCode = 0
		This.ctlLastErrorText = ""
		
	ENDPROC

	PROCEDURE _getlasterror
		*!* _GetLastError()
		
		Local ;
			lnLastErrorCode As Integer, ;
			lcLastErrorText As String, ;
			lnBuffer As Integer, ;
			lcBuffer As String, ;
			lnBufferLen As Integer, ;
			lnRetVal As Integer
		
		*!* Init vars:
		This.ctlLastErrorCode = 0
		This.ctlLastErrorText = ""
		
		m.lnLastErrorCode = This.ctlLastErrorCode
		m.lcLastErrorText = This.ctlLastErrorText
		
		*!* Get Last error code:
		m.lnLastErrorCode = apiGetLastError()
		
		*!* Get Kernel32.dll module handle:
		If Type("This._hKernel32") <> "N" Then
			This.AddProperty("_hKernel32", apiGetModuleHandle("kernel32.dll"))
		Endif
		
		*!* Get last error text:
		
		*!* Initialize buffer vars:
		m.lnBuffer = 0
		m.lnBufferLen = 1024
		m.lcBuffer = Replicate(NULA, m.lnBufferLen)
		
		m.lnRetVal = apiFormatMessage( ;
			FORMAT_MESSAGE_FROM_HMODULE, ;
			This._hKernel32, ;
			m.lnLastErrorCode, ;
			0, ;
			@m.lcBuffer, ;
			m.lnBufferLen, ;
			0)
		
		*!* If something was found, get the text from the buffer:
		If m.lnRetVal <> 0 Then
			m.lcLastErrorText = Left(m.lcBuffer, m.lnRetVal)
		
			*!* Remove last carriage return/line feed
			If Right(m.lcLastErrorText, 2) = CRLF Then
				m.lcLastErrorText = Left(m.lcBuffer, m.lnRetVal - 2)
			Endif
		Endif
		
		This.ctlLastErrorCode = m.lnLastErrorCode
		This.ctlLastErrorText = m.lcLastErrorText
		
	ENDPROC

	HIDDEN PROCEDURE _initproperties
		*!* _InitProperties()
		
		This.ctlLastErrorCode = 0
		This.ctlLastErrorText = ""
		
		This.Visible = FALSE
	ENDPROC

	HIDDEN PROCEDURE _startdocprinter
		*!* _StartDocPrinter()
		
		********************************************************************************
		*!*	typedef struct _DOC_INFO_1 {
		*!*	  LPTSTR pDocName;
		*!*	  LPTSTR pOutputFile;
		*!*	  LPTSTR pDatatype;
		*!*	} DOC_INFO_1;
		********************************************************************************
		If This._PrinterHandle = 0 Then
			Return FALSE
		Endif
		
		Local ;
			loDocInfo1 As _DOC_INFO_1, ;
			lcDocInfo1 As String, ;
			lnApiRetVal As Integer
		
		m.loDocInfo1 = Createobject("_DOC_INFO_1")
		
		If Empty(This.ctlDocumentName) Then
			m.loDocInfo1.pDocName = Juststem(Application.ServerName) + NULA
		Else
			m.loDocInfo1.pDocName = This.ctlDocumentName + NULA
		Endif
		
		If Vartype(This.ctlOutputFile) = "C" And Not Empty(This.ctlOutputFile) Then
			m.loDocInfo1.pOutputFile = This.ctlOutputFile + NULA
		Endif
		
		*!*	m.loDocInfo1.pDatatype = NULL
		
		m.lcDocInfo1 = m.loDocInfo1.Value &&Left(m.loDocInfo1.Value, 4) + Replicate(NULA, 8)
		
		m.lnApiRetVal = apiStartDocPrinter(This._PrinterHandle, 1, m.lcDocInfo1)
		
		m.loDocInfo1 = .Null.
		Release m.loDocInfo1
		
		If m.lnApiRetVal = 0 Then
			This._GetLastError()
			This.ctlClosePrinter()
			Return FALSE
		Else
			This._ClearLastError()
		Endif
		
		This._DocStarted = TRUE
		
		Return
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_registry AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_registry.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: decrypt
		*m: deletesubkey		&& Deletes the values and current subkey if it has no child subkeys.
		*m: deletesubkeytree		&& Deleting a particular key will remove all entries below the key in the tree. No warning will be provided. If you want to delete a subkey only when it has no child subkeys, use the DeleteSubKey method.
		*m: deletevalue		&& Deletes the specified value from the current registry key.
		*m: encrypt
		*m: getvalue		&& Retrieves the value associated with the specified name, in the current registry key. If the name is not found in the specified key, returns a default value that you provide, or null, if the specified key does not exist.
		*m: getvaluekind		&& Retrieves the registry data type of the value associated with the specified name.
		*m: getvalues
		*m: registrydefaultkey_assign
		*m: registrydefaulttype_assign
		*m: registrykey_assign
		*m: registrysubkey_assign
		*m: seekvalue		&& Specifies if a value name exists in the registry.
		*m: setvalue		&& Sets the value of a name/value pair in the current registry key. The registry data type is determined from the type of data being stored.
		*m: setvalues
		*m: _addproperties
		*m: _extractnamefromname
		*m: _extractsubkeyfromname		&& Extracts a subkey preffix appended to a value name.
		*m: _getvalueini
		*m: _getvalueregistry
		*m: _setvalueini
		*m: _validatedefaultkey
		*m: _validatedefaulttype
		*m: _validatekey
		*m: _validatesubkey
		*p: lasterrorcode		&& Specifies the last error code returned by the API functions.
		*p: registrydefaultkey		&& Specifies the default registry key to use. If empty, it defaults to HKEY_CURRENT_USER.
		*p: registrydefaultsubkey		&& Specifies the default registry subkey to use. If empty, it defaults to "Software\ExeName" at runtime, "Software\Vfp9\ProjectName" at design time.
		*p: registrydefaulttype		&& Specifies the default value type to use for storing values in the registry. Valid values are REG_BINARY or REG_SZ. Integers will be saved as DWORDs.
		*p: registrykey		&& Specifies the value of the registry key to use. If empty, RegistryDefaultKey is used.
		*p: registrysubkey		&& Specifies the value of the registry subkey to use. If empty, RegistryDefaultSubKey is used.
		*p: _defaultkey
		*p: _defaulttype
		*p: _key
		*p: _keyhandle
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _subkey
	*</DefinedPropArrayMethod>

	HIDDEN _defaultkey,_defaulttype,_key,_subkey
	BackColor = 140,200,200
	Height = 23
	lasterrorcode = 0		&& Specifies the last error code returned by the API functions.
	Name = "ctl32_registry"
	registrydefaultkey = HKEY_CURRENT_USER		&& Specifies the default registry key to use. If empty, it defaults to HKEY_CURRENT_USER.
	registrydefaultsubkey = 		&& Specifies the default registry subkey to use. If empty, it defaults to "Software\ExeName" at runtime, "Software\Vfp9\ProjectName" at design time.
	registrydefaulttype = REG_SZ		&& Specifies the default value type to use for storing values in the registry. Valid values are REG_BINARY or REG_SZ. Integers will be saved as DWORDs.
	registrykey = 		&& Specifies the value of the registry key to use. If empty, RegistryDefaultKey is used.
	registrysubkey = 		&& Specifies the value of the registry subkey to use. If empty, RegistryDefaultSubKey is used.
	Visible = .F.
	Width = 96
	_defaultkey = 
	_defaulttype = 
	_key = 0
	_keyhandle = 0
	_subkey = 

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_registry", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 4, ;
		Width = 68
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE decrypt
		Lparameters pcString
		
		Local lcString As String
		
		*!* Decrypt
		m.lcString = Strconv(Strconv(m.pcString, 16), 14)
		
		Return m.lcString
		
	ENDPROC

	PROCEDURE deletesubkey		&& Deletes the values and current subkey if it has no child subkeys.
		*!* Delete SubKey(cSubKey)
		
		*!* If cSubKey is empty, delete the current subkey
		*!* This will not delete subkeys that contain subkeys!
		
		Lparameters m.tcSubKey As String
		
		Local ;
			lnKey As Integer,;
			lcSubKey As String, ;
			lcSubKeyName As String, ;
			lnApiRetVal As Integer, ;
			lnKeyHandle As Integer
		
		m.lnKey = This._Key
		
		If Pcount() = 0 Then
			m.lcSubKey = Justpath(This._SubKey)
			m.lcSubKeyName = Justfname(This._SubKey)
		Else
			If Vartype(m.tcSubKey) = T_CHARACTER Then
				m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcSubKey)
				m.lcSubKeyName 	= This._ExtractNameFromName(m.tcSubKey)
			Else
				Return FALSE
			Endif
		Endif
		
		Debugout m.lcSubKey, m.lcSubKeyName
		
		m.lnApiRetVal = 0
		m.lnKeyHandle = 0
		
		*!*	If This._KeyHandle <> 0 Then
		*!*		apiRegCloseKey(This._KeyHandle)
		*!*	Endif
		
		*!* Open registry key
		m.lnApiRetVal = apiRegOpenKeyEx( ;
			m.lnKey, ;
			m.lcSubKey, ;
			0, ;
			KEY_WRITE, ;
			@m.lnKeyHandle)
		
		Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegOpenKeyEx"
		
		If m.lnApiRetVal = ERROR_SUCCESS Then
			m.lnApiRetVal = apiRegDeleteKey(m.lnKeyHandle, m.lcSubKeyName)
			Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegDeleteKeyEx"
		Endif
		
		This.LastErrorCode = m.lnApiRetVal
		
		Return m.lnApiRetVal = ERROR_SUCCESS
		
		
	ENDPROC

	PROCEDURE deletesubkeytree		&& Deleting a particular key will remove all entries below the key in the tree. No warning will be provided. If you want to delete a subkey only when it has no child subkeys, use the DeleteSubKey method.
		*!* DeleteSubKeyTree(cSubKey)
		
		*!* How To Implement a Recursive RegDeleteKey for Windows NT
		*!* /http://support.microsoft.com/?scid=kb%3Ben-us%3B142491&x=16&y=11
		
		Lparameters m.tcSubKey As String
		
		Local ;
			lnKey As Integer,;
			lcSubKey As String, ;
			lcSubKeyName As String, ;
			lnApiRetVal As Integer, ;
			lnKeyHandle As Integer
		
		m.lnKey = This._Key
		
		If Pcount() = 0 Then
			m.lcSubKey = Justpath(This._SubKey)
			m.lcSubKeyName = Justfname(This._SubKey)
		Else
			If Vartype(m.tcSubKey) = T_CHARACTER Then
				m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcSubKey)
				m.lcSubKeyName 	= This._ExtractNameFromName(m.tcSubKey)
			Else
				Return FALSE
			Endif
		Endif
		
		Debugout m.lcSubKey, m.lcSubKeyName
		
		m.lnApiRetVal = 0
		m.lnKeyHandle = 0
		
		*!*	If This._KeyHandle <> 0 Then
		*!*		apiRegCloseKey(This._KeyHandle)
		*!*	Endif
		
		*!* Open registry key
		m.lnApiRetVal = apiRegOpenKeyEx( ;
			m.lnKey, ;
			m.lcSubKey, ;
			0, ;
			KEY_WRITE, ;
			@m.lnKeyHandle)
		
		Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegOpenKeyEx"
		
		If m.lnApiRetVal = ERROR_SUCCESS Then
			m.lnApiRetVal = apiSHDeleteKey(m.lnKeyHandle, m.lcSubKeyName)
			Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegDeleteKeyEx"
		Endif
		
		This.LastErrorCode = m.lnApiRetVal
		
		Return m.lnApiRetVal = ERROR_SUCCESS
		
		
	ENDPROC

	PROCEDURE deletevalue		&& Deletes the specified value from the current registry key.
		*!* DeleteValue(cValueName)
		
		Lparameters m.tcValueName As Character
		
		Local ;
			lnKey As Integer,;
			lcSubKey As String, ;
			lcValueName As String, ;
			lnApiRetVal As Integer, ;
			lnKeyHandle As Integer
		
		m.lnKey 		= This._Key 
		m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
		m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)
		
		Debugout m.lnKey, m.lcSubKey, m.lcValueName, "DeleteValue"
		
		m.lnApiRetVal = 0
		m.lnKeyHandle = 0
		
		*!* Open registry key
		m.lnApiRetVal = apiRegOpenKeyEx( ;
			m.lnKey, ;
			m.lcSubKey, ;
			0, ;
			KEY_WRITE, ;
			@m.lnKeyHandle)
		
		Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegOpenKeyEx"
		
		If m.lnApiRetVal = ERROR_SUCCESS Then
			
			This._KeyHandle = m.lnKeyHandle
			m.lnApiRetVal = apiRegDeleteValue(m.lnKeyHandle, m.lcValueName)
		
			Assert m.lnApiRetVal = ERROR_SUCCESS Message "ApiRegDeleteValue"
		
			*!* 20080404 there is no need to close predefined registry keys
			*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
			*!* If the key is not one of the predefined registry keys, call 
			*!* the RegCloseKey function after you have finished using the handle.
			*!* Close registry key
			*!* apiRegCloseKey(m.lnKeyHandle)
		
		Endif
		
		This.LastErrorCode = m.lnApiRetVal
		
		Return m.lnApiRetVal = ERROR_SUCCESS
		
	ENDPROC

	PROCEDURE encrypt
		Lparameters pcString
		
		Local lcString As String
		
		*!* Encrypt
		m.lcString = Strconv(Strconv(m.pcString, 13), 15)
		
		Return m.lcString
		
	ENDPROC

	PROCEDURE getvalue		&& Retrieves the value associated with the specified name, in the current registry key. If the name is not found in the specified key, returns a default value that you provide, or null, if the specified key does not exist.
		*!* GetValue(cValueName, eDefaultValue)
		
		Lparameter tcValueName, tvDefaultValue
		
		Return This._GetValueRegistry(m.tcValueName, m.tvDefaultValue)
		
	ENDPROC

	PROCEDURE getvaluekind		&& Retrieves the registry data type of the value associated with the specified name.
		*!* GetValueKind(cValueName)
		
		*!*	#Define REG_SZ                                                       1 
		*!*	#Define REG_EXPAND_SZ                                                2 
		*!*	#Define REG_BINARY                                                   3 
		*!*	#Define REG_DWORD                                                    4 
		*!*	#Define REG_DWORD_BIG_ENDIAN                                         5 
		*!*	#Define REG_MULTI_SZ                                                 7 
		
		Lparameter m.tcValueName As Character
		
		Local ;
			lnKey As Integer,;
			lcSubKey As String, ;
			lcValueName As String, ;
			lcData As String, ;
			lnType As Integer, ;
			lnRetVal As Integer, ;
			lnDataLen As Integer, ;
			lnApiRetVal As Integer, ;
			lnKeyHandle As Integer
		
		m.lnKey 		= This._Key
		m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
		m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)
		
		m.lnRetVal      = 0
		
		m.lnApiRetVal = 0
		m.lnKeyHandle = 0
		
		**********************************************************
		
		*!* Open registry key
		m.lnApiRetVal = apiRegOpenKeyEx( ;
			m.lnKey, ;
			m.lcSubKey, ;
			0, ;
			KEY_READ, ;
			@m.lnKeyHandle)
		
		If m.lnApiRetVal = ERROR_SUCCESS Then
			This._KeyHandle = m.lnKeyHandle
			*!* Find out Value Kind and length of data:
			m.lnType 		= 0
			m.lcData 		= ""
			m.lnDataLen 	= 0
		
			m.lnApiRetVal = apiRegQueryValueEx( ;
				m.lnKeyHandle, ;
				m.lcValueName, ;
				0, ;
				@m.lnType, ;
				@m.lcData , ;
				@m.lnDataLen )
		
			If Inlist(m.lnApiRetVal, ERROR_SUCCESS, ERROR_MORE_DATA) Then
				m.lnApiRetVal = ERROR_SUCCESS
				m.lnRetVal = m.lnType
			Endif
		
			*!* 20080404 there is no need to close predefined registry keys
			*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
			*!* If the key is not one of the predefined registry keys, call
			*!* the RegCloseKey function after you have finished using the handle.
			*!* Close registry key
			*!* apiRegCloseKey(m.lnKeyHandle)
		
		Endif
		
		This.LastErrorCode = m.lnApiRetVal
		
		Return m.lnRetVal
		
	ENDPROC

	PROCEDURE getvalues
		*!* GetValues
		Lparameters poObject As Object, pcSubKey As String
		
		Local ;
			loControl As Control, ;
			lvValue As Variant
		
		m.pcSubKey = Addbs(m.pcSubKey)
		
		For Each m.loControl In m.poObject.Controls
		
			Do Case
		
				Case Vartype(m.loControl.ctlValue) # "U"
		
					If "ENCRYPTED" $ m.loControl.Tag Then
						m.lvValue = This.Encrypt(Transform(m.loControl.ctlValue))
					Else
						m.lvValue = m.loControl.ctlValue
					Endif
		
					m.lvValue = This.GetValue(m.pcSubKey + m.loControl.Name, m.lvValue)
		
					If "ENCRYPTED" $ m.loControl.Tag Then
						m.lvValue = This.Decrypt(m.lvValue)
					Endif
		
					m.loControl.ctlValue = m.lvValue
		
				Case Vartype(m.loControl.Value) # "U"
		
					If "ENCRYPTED" $ m.loControl.Tag Then
						m.lvValue = This.Encrypt(Transform(m.loControl.Value))
					Else
						m.lvValue = m.loControl.Value
					Endif
		
					m.lvValue = This.GetValue(m.pcSubKey + m.loControl.Name, m.lvValue)
		
					If "ENCRYPTED" $ m.loControl.Tag Then
						m.lvValue = This.Decrypt(m.lvValue)
					Endif
		
					m.loControl.Value = m.lvValue
		
			Endcase
		Endfor
		
		m.loControl = .Null.
		
	ENDPROC

	PROCEDURE Init
		*!* Init
		
		*!* Use these values to set RegistryDefaultKey:
		*!*	#Define HKEY_CLASSES_ROOT 		2147483648
		*!*	#Define HKEY_CURRENT_CONFIG 	2147483653
		*!*	#Define HKEY_CURRENT_USER 		2147483649
		*!*	#Define HKEY_DYN_DATA 			2147483654
		*!*	#Define HKEY_LOCAL_MACHINE 		2147483650
		*!*	#Define HKEY_PERFORMANCE_DATA 	2147483652
		*!*	#Define HKEY_USERS 				2147483651
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		This._DefaultKey	= This._ValidateDefaultKey(This.RegistryDefaultKey)
		This._Key  		 	= This._ValidateKey(This.RegistryKey)
		This._Subkey 	 	= This._ValidateSubKey(This.RegistrySubkey)
		This._DefaultType 	= This._ValidateDefaultType(This.RegistryDefaultType)
		
		*!* Windows Registry Structure and class properties
		*!*	RegistryKey
		*!*      |
		*°*      - RegistrySubKey
		*°*                |
		*°*                - cValueName1 = vValue1 (*See Note)
		*°*                - cValueName2 = vValue2
		*!*                ...
		*!*                - cValueNamen = vValuen
		*!* *Note: tcValueName and tvValue are parameters passed to
		*!* GetValue and SetValue
		
		*!* HKEY_CLASSES_ROOT						0x80000000
		*!* HKEY_CURRENT_CONFIG						0x80000005
		*!* HKEY_CURRENT_USER						0x80000001
		*!* HKEY_LOCAL_MACHINE						0x80000002
		*!* HKEY_USERS								0x80000003
		
		
		
	ENDPROC

	HIDDEN PROCEDURE registrydefaultkey_assign
		*!* RegistryDefaultKey_Assign(eNewValue)
		
		Lparameters tvNewValue
		This._DefaultKey  = This._ValidateDefaultKey(m.tvNewValue)
		
		
		
	ENDPROC

	HIDDEN PROCEDURE registrydefaulttype_assign
		*!* RegistryDefaultlType_Assign(eNewValue)
		
		lparameters tvNewValue
		This._DefaultType = This._ValidateDefaultType(m.tvNewValue)
		
	ENDPROC

	HIDDEN PROCEDURE registrykey_assign
		*!* RegistryKey_Assign(eNewValue)
		
		Lparameters tvNewValue
		This._Key  = This._ValidateKey(m.tvNewValue)
		
	ENDPROC

	HIDDEN PROCEDURE registrysubkey_assign
		*!* RegistrySubKey_Assign(eNewValue)
		
		Lparameters tvNewValue
		This._SubKey = This._ValidateSubKey(m.tvNewValue)
		
	ENDPROC

	PROCEDURE seekvalue		&& Specifies if a value name exists in the registry.
		*!* SeekValue(cValueName)
		
		Lparameters m.cValueName As String
		
		Return This.GetValueKind(m.cValueName) <> 0
		
	ENDPROC

	PROCEDURE setvalue		&& Sets the value of a name/value pair in the current registry key. The registry data type is determined from the type of data being stored.
		*!* SetValue(cValueName, eValue)
		
		Lparameter m.tcValueName, m.tvValue
		
		Local ;
			lnKey As Integer,;
			lcSubKey As String, ;
			lcValueName As String, ;
			lcValue As String, ;
			lnValueKind As Integer, ;
			lnApiRetVal As Integer, ;
			lnKeyHandle As Integer, ;
			lpdwDisposition As Integer, ;
			lnValueLen As Integer
		
		m.lnKey 		= This._Key
		m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
		m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)
		
		*!* Determine ValueKind to use and convert Value:
		Do Case
		
			Case Vartype(m.tvValue) = T_CHARACTER
				*!* If there are any nul characters, save as binary
				If NULA $ m.tvValue Then
					m.lnValueKind = REG_BINARY
				Else
					m.lnValueKind = This._DefaultType
				Endif
				m.lcValue = m.tvValue
		
			Case Vartype(m.tvValue) = T_DATE
				m.lnValueKind = This._DefaultType
				m.lcValue = Dtos(m.tvValue)
		
			Case Vartype(m.tvValue) = T_LOGICAL
				m.lnValueKind = REG_DWORD
				*!* Store 1 for TRUE, 0 for FALSE, convert to DWORD
				m.lcValue = Iif(m.tvValue, 0h01000000, 0h00000000)
		
			Case Vartype(m.tvValue) = T_NUMERIC
				*!* Check if we can store the number in a DWORD
				If m.tvValue - Int(m.tvValue) = 0 And Abs(m.tvValue) <= 2147483647 Then
					m.lnValueKind = REG_DWORD
					m.lcValue = BinToC(m.tvValue,"4RS")
				Else
					m.lnValueKind = This._DefaultType
					m.lcValue = Strtran(Transform(m.tvValue), Set("Point"), '.')
				Endif
		
			Case Vartype(m.tvValue) = T_VARBINARY
				m.lnValueKind = REG_BINARY
				m.lcValue = m.tvValue
		
			Case Vartype(m.tvValue) = T_DATETIME
				m.lnValueKind = This._DefaultType
				m.lcValue = Ttoc(m.tvValue, 3)
		
			Case Vartype(m.tvValue) = T_CURRENCY
				m.lnValueKind = This._DefaultType
				m.lcValue = Strtran(Transform(m.tvValue), Set("Point"), '.')
		
			Otherwise
				m.lcValue = Transform(m.tvValue)
				If NULA $ m.tvValue Then
					m.lnValueKind = REG_BINARY
				Else
					m.lnValueKind = This._DefaultType
				Endif
		
		Endcase
		
		*!* Do API stuff
		
		m.lnApiRetVal = 0
		m.lnKeyHandle = 0
		m.lpdwDisposition = 0
		
		*!* Open/Create registry key
		m.lnApiRetVal = apiRegCreateKeyEx( ;
			m.lnKey, ;
			m.lcSubKey, ;
			0, ;
			0, ;
			REG_OPTION_NON_VOLATILE, ;
			KEY_ALL_ACCESS, ;
			0, ;
			@m.lnKeyHandle, ;
			@m.lpdwDisposition)
		
		If m.lnApiRetVal = ERROR_SUCCESS
		
			m.lnValueLen = Len(m.lcValue)
		
			*!* Save data
			m.lnApiRetVal = apiRegSetValueEx( ;
				m.lnKeyHandle, ;
				m.lcValueName, ;
				0,;
				m.lnValueKind, ;
				m.lcValue, ;
				m.lnValueLen)
		
			*!* 20080404 there is no need to close predefined registry keys
			*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
			*!* If the key is not one of the predefined registry keys, call
			*!* the RegCloseKey function after you have finished using the handle.
			*!* Close registry key
			*!* apiRegCloseKey(m.lnKeyHandle)
		Endif
		
		This.LastErrorCode = m.lnApiRetVal
		
		Assert m.lnApiRetVal = ERROR_SUCCESS Message Sys(16)
		
		Return m.lnApiRetVal = ERROR_SUCCESS
		
	ENDPROC

	PROCEDURE setvalues
		*!* SetValues
		Lparameters poObject As Object, pcSubKey As String
		
		Local loControl As Control, lvValue As Variant
		
		m.pcSubKey = Addbs(m.pcSubKey)
		
		For Each m.loControl In m.poObject.Controls
		
			Do Case
		
				Case Vartype(m.loControl.ctlValue) # "U"
		
					If "ENCRYPTED" $ m.loControl.Tag Then
						m.lvValue = This.Encrypt(Transform(m.loControl.ctlValue))
					Else
						m.lvValue = m.loControl.ctlValue
					Endif
		
					If Vartype(m.lvValue) = "C" Then
						m.lvValue = Alltrim(m.lvValue)
					Endif
		
					This.SetValue(m.pcSubKey + m.loControl.Name, m.lvValue)
		
				Case Vartype(m.loControl.Value) # "U"
		
					If "ENCRYPTED" $ m.loControl.Tag Then
						m.lvValue = This.Encrypt(Transform(m.loControl.Value))
					Else
						m.lvValue = m.loControl.Value
					Endif
		
					If Vartype(m.lvValue) = "C" Then
						m.lvValue = Alltrim(m.lvValue)
					Endif
		
					This.SetValue(m.pcSubKey + m.loControl.Name, m.lvValue)
		
			Endcase
		Endfor
		
		m.loControl = .Null.
		
	ENDPROC

	HIDDEN PROCEDURE _addproperties
		*!* _AddProperties()
		
	ENDPROC

	HIDDEN PROCEDURE _extractnamefromname
		*!* _ExtractSubKeyFromName(cValueName)
		Lparameters m.tcValueName
		
		Local ;
			lcValueName As String, ;
			lcName As String
		
		m.lcValueName = Alltrim(Transform(m.tcValueName))
		
		*!* Strip starting BackSlash
		If Left(m.lcValueName, 1) = "\" Then
			m.lcValueName = Right(m.lcValueName, Len(m.lcValueName) - 1)
		Endif
		
		*!* Strip ending BackSlash
		If Right(m.lcValueName, 1) = "\" Then
			m.lcValueName = Left(m.lcValueName, Len(m.lcValueName) - 1)
		Endif
		
		m.lcName = Justfname(m.lcValueName)
		
		Return m.lcName
		
	ENDPROC

	HIDDEN PROCEDURE _extractsubkeyfromname		&& Extracts a subkey preffix appended to a value name.
		*!* _ExtractSubKeyFromName(cValueName)
		Lparameters m.tcValueName
		
		Local ;
			lcValueName As String, ;
			lcSubKey As String
		
		m.lcValueName = Alltrim(Transform(m.tcValueName))
		
		*!* Strip starting BackSlash
		If Left(m.lcValueName, 1) = "\" Then
			m.lcValueName = Right(m.lcValueName, Len(m.lcValueName) - 1)
		Endif
		
		*!* Strip ending BackSlash
		If Right(m.lcValueName, 1) = "\" Then
			m.lcValueName = Left(m.lcValueName, Len(m.lcValueName) - 1)
		Endif
		
		m.lcSubKey = Justpath(m.lcValueName)
		
		If Not Empty(m.lcSubKey) Then
			m.lcSubKey = "\" + m.lcSubKey
		Endif
		
		Return m.lcSubKey
		
	ENDPROC

	PROCEDURE _getvalueini
		*!* _GetValueIni(cValueName, eDefaultValue)
		
		Lparameter m.tcValueName, m.tvDefaultValue
		
		If Pcount() < 2 Then
			Return .Null.
		Endif
		
		Local ;
			m.lcAppName As String, ;
			m.lcKeyName As String, ;
			m.lcDefault As String, ;
			m.lcReturnedString As String, ;
			m.lnSize As Integer, ;
			m.lcFileName As String, ;
			m.lnRetVal As Integer, ;
			m.lvValue As Variant
		
		If Type("Application.ActiveProject") = "O" Then
			m.lcFileName = Forceext(Application.ActiveProject.Name, "ini")
		Else
			m.lcFileName = Forceext(Application.ServerName, "ini")
		Endif
		
		m.lcAppName = This._ExtractSubKeyFromName(m.tcValueName)
		m.lcAppName = Right(m.lcAppName, Len(m.lcAppName) - 1)
		
		m.lcKeyName = This._ExtractNameFromName(m.tcValueName)
		
		m.lcDefault = "BCCE8FDBBE1440EDAFD4F83C1D1F9B52C11CB5233C154DFCA08166F5A297A398"
		
		m.lnSize = 0xfff
		m.lcReturnedString = Replicate(NULCHAR, m.lnSize)
		
		m.lnRetVal = apiGetPrivateProfileString( ;
			m.lcAppName, ;
			m.lcKeyName, ;
			m.lcDefault, ;
			@m.lcReturnedString, ;
			m.lnSize, ;
			m.lcFileName)
		
		m.lcReturnedString = Left(m.lcReturnedString, m.lnRetVal)
		
		If m.lcReturnedString == m.lcDefault Then
			m.lvValue = m.tvDefaultValue
		Else
			m.lvValue = m.lcReturnedString
		Endif
		
		Release m.lcReturnedString
		
		Return m.lvValue
		
	ENDPROC

	PROCEDURE _getvalueregistry
		*!* GetValueRegistry(cValueName, eDefaultValue)
		
		Lparameter m.tcValueName, m.tvDefaultValue
		
		If Pcount() < 2 Then
			Return .Null.
		Endif
		
		Local ;
			lnKey As Integer,;
			lcSubKey As String, ;
			lcValueName As String, ;
			lcData As String, ;
			lnKind As Integer, ;
			lvValue As Variant, ;
			lnDataLen As Integer, ;
			lnApiRetVal As Integer, ;
			lnKeyHandle As Integer
		
		m.lnKey 		= This._Key
		m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
		m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)
		
		Debugout m.lnKey, m.lcSubKey, m.lcValueName, "GetValue"
		
		*!* Do API stuff
		
		m.lnApiRetVal = 0
		m.lnKeyHandle = 0
		
		**********************************************************
		
		*!* Try to open registry key
		m.lnApiRetVal = apiRegOpenKeyEx( ;
			m.lnKey, ;
			m.lcSubKey, ;
			0, ;
			KEY_READ, ;
			@m.lnKeyHandle)
		
		If m.lnApiRetVal = ERROR_SUCCESS Then
			This._KeyHandle = m.lnKeyHandle
		Else
			*!* Could not open registry key
			This.LastErrorCode = m.lnApiRetVal
			Return m.tvDefaultValue
		Endif
		
		m.lnKind	= 0
		m.lcData 	= Space(0xff)
		m.lnDataLen = Len(m.lcData)
		
		*!* Find out required length of data, call with a x len buffer,
		*!* m.lnDataLen will have the needed buffer len if error is ERROR_MORE_DATA
		*!* also m.lnKind will have the data Kind
		m.lnApiRetVal = apiRegQueryValueEx( ;
			m.lnKeyHandle, ;
			m.lcValueName, ;
			0, ;
			@m.lnKind, ;
			@m.lcData , ;
			@m.lnDataLen)
		
		Do Case
		
			Case m.lnApiRetVal = ERROR_SUCCESS
				m.lcData = Left(m.lcData, m.lnDataLen)
		
			Case m.lnApiRetVal = ERROR_MORE_DATA
				*!* Create a buffer big enough:
				m.lcData = Space(m.lnDataLen)
		
				*!* Now Get the data again:
				m.lnApiRetVal = apiRegQueryValueEx( ;
					m.lnKeyHandle, ;
					m.lcValueName, ;
					0, ;
					@m.lnKind, ;
					@m.lcData , ;
					@m.lnDataLen )
		
				If m.lnApiRetVal <> ERROR_SUCCESS Then
					*!* We failed reading the data
					This.LastErrorCode = m.lnApiRetVal
					Return m.tvDefaultValue
				Endif
			Otherwise
				*!* We failed reading the data
				This.LastErrorCode = m.lnApiRetVal
				Return m.tvDefaultValue
		Endcase
		
		*!* 20080404 there is no need to close predefined registry keys
		*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
		*!* If the key is not one of the predefined registry keys, call
		*!* the RegCloseKey function after you have finished using the handle.
		*!* Close registry key
		*!* apiRegCloseKey(m.lnKeyHandle)
		
		Do Case
			Case m.lnKind = REG_SZ
				*!* Remove ending NUL
				m.lvValue = Left(m.lcData, m.lnDataLen - 1)
				*!* Cut to data len
			Case m.lnKind = REG_BINARY
				m.lvValue = Left(m.lcData, m.lnDataLen)
			Case m.lnKind = REG_DWORD
				*!* Convert to numeric
				m.lvValue = CToBin(Left(m.lcData, m.lnDataLen), "4RS")
			Case m.lnKind = REG_MULTI_SZ
				*!* Remove double ending NUL
				m.lvValue = Left(m.lcData, m.lnDataLen - 2)
			Otherwise
				m.lvValue = ""
		Endcase
		
		*!* Convert return value based on tuDefaultValue
		Do Case
		
			Case Vartype(m.tvDefaultValue) = T_CHARACTER
				*!* Value is already of type character
		
			Case Vartype(m.tvDefaultValue) = T_CURRENCY
				m.lvValue= Cast(m.lvValue As Currency)
		
			Case Vartype(m.tvDefaultValue) = T_DATE
				m.lvValue = Date(Val(Left(m.lvValue,4)), Val(Substr(m.lvValue,5,2)), Val(Right(m.lvValue,2)))
		
			Case Vartype(m.tvDefaultValue) = T_DATETIME
				m.lvValue = Ctot(m.lvValue)
		
			Case Vartype(m.tvDefaultValue) = T_LOGICAL
				m.lvValue = Iif(m.lvValue = 1, TRUE, FALSE)
		
			Case Vartype(m.tvDefaultValue) = T_NUMERIC And m.lnKind = REG_DWORD
				*!* Value has already been converted from DWORD to numeric
		
			Case Vartype(m.tvDefaultValue) = T_NUMERIC
				*!* REG_SZ, REG_BINARY
				m.lvValue = Evaluate(m.lvValue)
		
			Case Vartype(m.tvDefaultValue) = T_VARBINARY
				m.lvValue = Cast(m.lvValue As Varbinary (Len(m.lvValue)))
		
			Otherwise
				*!* No formating of value
		Endcase
		
		Return m.lvValue
		
	ENDPROC

	PROCEDURE _setvalueini
		*!* SetValueIni(cValueName, eValue)
		
		Lparameter m.tcValueName, m.tvValue
		
		Local ;
			m.lcAppName As String, ;
			m.lcKeyName As String, ;
			m.lcString As String, ;
			m.lcType As String, ;
			m.lnRetVal As Integer
		
		If Type("Application.ActiveProject") = "O" Then
			m.lcFileName = Forceext(Application.ActiveProject.Name, "ini")
		Else
			m.lcFileName = Forceext(Application.ServerName, "ini")
		Endif
		
		m.lcAppName = This._ExtractSubKeyFromName(m.tcValueName)
		m.lcAppName = Right(m.lcAppName, Len(m.lcAppName) - 1)
		
		m.lcKeyName = This._ExtractNameFromName(m.tcValueName)
		
		m.lcString = ""
		m.lcType = Vartype(m.tvValue)
		
		*!* Determine ValueKind to use and convert Value:
		Do Case
		
			Case Vartype(m.tvValue) = T_CHARACTER
				*!* If there are any nul characters, save as binary
				If NULA $ m.tvValue Then
					m.lcString = Strconv(m.tvValue, 15)
				Else
					m.lcString = m.tvValue
				Endif
		
			Case Vartype(m.tvValue) = T_CURRENCY
				m.lcString = Strtran(Transform(m.tvValue), Set("Point"), '.')
		
			Case Vartype(m.tvValue) = T_DATE
				m.lcString = Dtos(m.tvValue)
		
			Case Vartype(m.tvValue) = T_DATETIME
				m.lcString = Ttoc(m.tvValue, 3)
		
			Case Vartype(m.tvValue) = T_LOGICAL
				m.lcString = Iif(m.tvValue, "1", "0")
		
			Case Vartype(m.tvValue) = T_NUMERIC
				m.lcString = Strtran(Transform(m.tvValue), Set("Point"), '.')
		
			Case Vartype(m.tvValue) = T_VARBINARY
				m.lcString = STRCONV(m.tvValue, 15)
		
			Otherwise
				*!* If there are any nul characters, save as binary
				If NULA $ m.tvValue Then
					m.lcString = Strconv(m.tvValue, 15)
				Else
					m.lcString = m.tvValue
				Endif
		
		Endcase
		
		m.lnRetVal = apiWritePrivateProfileString( ;
			m.lcAppName, ;
			m.lcKeyName, ;
			m.lcString, ;
			m.lcFileName)
		
		apiWritePrivateProfileString( ;
			m.lcAppName + ".VarType", ;
			m.lcKeyName, ;
			m.lcType, ;
			m.lcFileName)
		
		Return m.lnRetVal # 0
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _validatedefaultkey
		*!* ValidateDefaultKey(eKey)
		
		*!* Key must be a numeric value, but user can set it to a String value
		*!* to make programming easier. Here we translate string value to numeric
		*!* value
		
		*!* Change RegistryDefaultKey property to change default key
		
		Lparameters m.tvKey
		
		Local ;
			lnKey As Integer, ;
			lnLastResortDefaultKey As Integer
		
		m.lnLastResortDefaultKey = HKEY_CURRENT_USER
		
		If Vartype(m.tvKey) = T_NUMERIC
			If Not Inlist(m.tvKey, HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CURRENT_CONFIG)
				*!* If no match for integer values, default:
				m.lnKey = m.lnLastResortDefaultKey
			Endif
		Endif
		
		If Vartype(m.tvKey) = T_CHARACTER
		
			m.tvKey = Upper(m.tvKey)
		
			Do Case
				Case m.tvKey == "HKEY_CLASSES_ROOT" ;
						Or m.tvKey == "HKCR" ;
						OR m.tvKey == "CLASSESROOT"
					m.lnKey = HKEY_CLASSES_ROOT
		
				Case m.tvKey == "HKEY_CURRENT_USER" ;
						Or m.tvKey == "HKCU" ;
						OR m.tvKey == "CURRENTUSER"
					m.lnKey = HKEY_CURRENT_USER
		
				Case m.tvKey == "HKEY_LOCAL_MACHINE" ;
						Or m.tvKey == "HKLM" ;
						OR m.tvKey == "LOCALMACHINE"
					m.lnKey = HKEY_LOCAL_MACHINE
		
				Case m.tvKey == "HKEY_USERS" ;
						Or m.tvKey == "HKU" ;
						OR m.tvKey == "USERS"
					m.lnKey = HKEY_USERS
		
				Case m.tvKey == "HKEY_CURRENT_CONFIG" ;
						Or m.tvKey == "HKCC" ;
						OR m.tvKey == "CURRENTCONFIG"
					m.lnKey = HKEY_CURRENT_CONFIG
		
				Otherwise
					*!* If no match for common text values, default:
					m.lnKey = m.lnLastResortDefaultKey
		
			Endcase
		
		Endif
		
		*!* If key is anything but numeric, default
		If Vartype(m.lnKey) <> T_NUMERIC Then
			m.lnKey = m.lnLastResortDefaultKey
		Endif
		
		Return m.lnKey
		
	ENDPROC

	HIDDEN PROCEDURE _validatedefaulttype
		*!* _ValidateDefaultType(eType)
		
		Lparameters m.tvType
		
		Local lnType As Integer
		
		m.lnType = REG_SZ
		
		Do Case
		
			Case Vartype(m.tvType) = T_NUMERIC
				If Not Inlist(m.tvType, REG_SZ, REG_MULTI_SZ, REG_BINARY, REG_DWORD) Then
					m.lnType = REG_SZ
				Endif
		
			Case Vartype(m.tvType) = T_CHARACTER
		
				Do Case
					Case Upper(m.tvType) == "REG_SZ"
						m.lnType = REG_SZ
					Case Upper(m.tvType) == "REG_BINARY"
						m.lnType = REG_BINARY
				Endcase
		
		Endcase
		
		Return m.lnType
		
	ENDPROC

	HIDDEN PROCEDURE _validatekey
		*!* _ValidateKey(eKey)
		
		*!* Key must be a numeric value, but user can set it to a String value
		*!* to make programming easier. Here we translate string value to numeric
		*!* value
		
		*!* Change RegistryDefaultKey property to change default key
		
		Lparameters m.tvKey
		
		Local ;
			lnKey As Integer, ;
			lnLastResortDefaultKey As Integer
		
		m.lnLastResortDefaultKey = HKEY_CURRENT_USER
		
		If Vartype(m.tvKey) = T_NUMERIC
			If Not Inlist(m.tvKey, HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CURRENT_CONFIG)
				*!* If no match for integer values, default:
				m.lnKey = This._DefaultKey
			Endif
		Endif
		
		If Vartype(m.tvKey) = T_CHARACTER
		
			m.tvKey = Upper(m.tvKey)
		
			Do Case
				Case m.tvKey == "HKEY_CLASSES_ROOT" ;
						Or m.tvKey == "HKCR" ;
						OR m.tvKey == "CLASSESROOT"
					m.lnKey = HKEY_CLASSES_ROOT
		
				Case m.tvKey == "HKEY_CURRENT_USER" ;
						Or m.tvKey == "HKCU" ;
						OR m.tvKey == "CURRENTUSER"
					m.lnKey = HKEY_CURRENT_USER
		
				Case m.tvKey == "HKEY_LOCAL_MACHINE" ;
						Or m.tvKey == "HKLM" ;
						OR m.tvKey == "LOCALMACHINE"
					m.lnKey = HKEY_LOCAL_MACHINE
		
				Case m.tvKey == "HKEY_USERS" ;
						Or m.tvKey == "HKU" ;
						OR m.tvKey == "USERS"
					m.lnKey = HKEY_USERS
		
				Case m.tvKey == "HKEY_CURRENT_CONFIG" ;
						Or m.tvKey == "HKCC" ;
						OR m.tvKey == "CURRENTCONFIG"
					m.lnKey = HKEY_CURRENT_CONFIG
		
				Otherwise
					*!* If no match for common text values, default:
					m.lnKey = This._DefaultKey
		
			Endcase
		
		Endif
		
		*!* If key is anything but numeric, default
		If Vartype(m.lnKey) <> T_NUMERIC Then
			m.lnKey = This._DefaultKey
		Endif
		
		Return m.lnKey
		
	ENDPROC

	HIDDEN PROCEDURE _validatesubkey
		*!* _ValidateSubKey()
		
		Lparameters m.tcSubKey
		*!* SubKey is a string value
		
		Local lcSubKey As String
		
		*!* If empty subkey, set default value:
		
		If Empty(m.tcSubKey) OR VARTYPE(m.tcSubKey) <> T_CHARACTER Then
		
			If Empty(This.RegistryDefaultSubKey) Then
				*!* Here we get full path and name of exe, or we create it from project name:
				If Type("Application.ActiveProject") = "O" Then
					m.lcSubKey = "Software\VFP9\" + Proper(Juststem(Application.ActiveProject.Name))
				Else
					m.lcSubKey = "Software\" + Proper(Juststem(Application.ServerName))
				Endif
			Else
				m.lcSubKey = This.RegistryDefaultSubKey
			Endif
		
		Else
			m.lcSubKey = m.tcSubKey
		Endif
		
		*!* Strip starting BackSlash
		If Left(m.lcSubKey, 1) = "\" Then
			m.lcSubKey = Right(m.lcSubKey, Len(m.lcSubKey) - 1)
		Endif
		
		*!* Strip ending BackSlash
		If Right(m.lcSubKey, 1) = "\" Then
			m.lcSubKey = Left(m.lcSubKey, Len(m.lcSubKey) - 1)
		Endif
		
		Return m.lcSubKey
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_savefiledialog AS ctl32_filedialog OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_savefiledialog.bmp" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*p: ctlcreateprompt		&& Gets or sets a value indicating whether the dialog box prompts the user for permission to create a file if the user specifies a file that does not exist.
		*p: ctloverwriteprompt		&& Gets or sets a value indicating whether the Save As dialog box displays a warning if the user specifies a file name that already exists.
	*</DefinedPropArrayMethod>

	ctlcheckfileexists = .F.
	ctloverwriteprompt = .T.		&& Gets or sets a value indicating whether the Save As dialog box displays a warning if the user specifies a file name that already exists.
	Name = "ctl32_savefiledialog"
	_dialogtype = SAVE
	lblname.Caption = "ctl32_savefiledialog"
	lblname.Name = "lblname"

ENDDEFINE

DEFINE CLASS ctl32_scontainer AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_scontainer.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlautocenter_assign
		*m: ctlbackcolor_assign
		*m: ctlbackstyle_assign
		*m: ctlbordercolor_assign
		*m: ctlborderstyle_assign
		*m: ctldoscroll		&& Scrolls the control to simulate a user clicking the scroll bars.
		*m: ctlforcescrollbars_assign
		*m: ctlhhwnd_access
		*m: ctlhhwnd_assign
		*m: ctlhmax_access
		*m: ctlhmax_assign
		*m: ctlhvalue_access
		*m: ctlhvalue_assign
		*m: ctlrestoresize
		*m: ctlscrollbars_assign
		*m: ctlscrolled		&& Occurs when the horizontal or vertical scroll bars are clicked or dragged
		*m: ctlvhwnd_access
		*m: ctlvhwnd_assign
		*m: ctlvmax_access
		*m: ctlvmax_assign
		*m: ctlvvalue_access
		*m: ctlvvalue_assign
		*m: _activateform
		*m: _addobjects
		*m: _addproperties
		*m: _bindevents
		*m: _bindmousewheel
		*m: _create
		*m: _eventformactivate
		*m: _eventformscontainerwm
		*m: _eventformthemes
		*m: _eventformvisible
		*m: _eventmoved
		*m: _eventnewobject
		*m: _eventpageactivate
		*m: _eventpagedeactivate
		*m: _eventpageframeactivepage
		*m: _eventresize
		*m: _eventscreenthemes
		*m: _objtoclient
		*m: _resize
		*m: _scroll
		*m: _scrolltocontrol
		*m: _settheme
		*m: _setzoomratios
		*m: _wm_event
		*p: ctlabout		&& Returns information about the class.
		*p: ctlactivescrollbars		&& Specifies whether scrollbars are needed. It does not indicate if the scrollbars are visible. Can be used to control an optional scroll control. 0: none, 1: horizontal, 2: vertical, 3: both.
		*p: ctlallowdrag
		*p: ctlallowzoom
		*p: ctlautocenter		&& Specifies whether the child control should be centered in the scrollable container when the scrollable container is bigger that the child control.
		*p: ctlautoscroll
		*p: ctlbackcolor
		*p: ctlbackstyle
		*p: ctlbordercolor
		*p: ctlborderstyle
		*p: ctlforcescrollbars		&& Specifies whether scrollbars should be always visible. Visible scrollbars will be disabled when not needed.
		*p: ctlhenabled		&& Specifies if the horizontal scrollbar is enabled or required.
		*p: ctlhhwnd		&& Returns a handle to the horizontal scrollbar control window.
		*p: ctlhlargechange		&& Specifies the increment an horizontal scrollbar scrolls when you click on the scrollbar track.
		*p: ctlhmargin		&& Specifies the horizontal margin to use when autoscrolling to the active control.
		*p: ctlhmax
		*p: ctlhsmallchange		&& Specifies the horizontal scrolling increment for a form's horizontal scroll bar.
		*p: ctlhvalue		&& Sets or returns the actual horizontal scroll value of the client control.
		*p: ctlhvisible		&& Specifies if the horizontal scrollbar is visible.
		*p: ctlhwheelchange		&& Specifies the increment an horizontal scrollbar scrolls when you use the mouse wheel.
		*p: ctlscrollbars		&& Specifies the type of scroll bars a control has.
		*p: ctlthemes
		*p: ctlvenabled		&& Specifies if the vertical scrollbar is enabled or required.
		*p: ctlversion
		*p: ctlvhwnd		&& Returns a handle to the horizontal scrollbar control window.
		*p: ctlvlargechange		&& Specifies the increment a vertical scrollbar scrolls when you click on the scrollbar track.
		*p: ctlvmargin		&& Specifies the vertical margin to use when autoscrolling to the active control.
		*p: ctlvmax
		*p: ctlvsmallchange		&& Specifies the increment a vertical scrollbar scrolls when you click on a scroll arrow.
		*p: ctlvvalue		&& Sets or returns the actual vertical scroll value of the client control.
		*p: ctlvvisible		&& Specifies if the vertical scrollbar is visible.
		*p: ctlvwheelchange		&& Specifies the increment a vertical scrollbar scrolls when you use the mouse wheel.
		*p: ctlzoom
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _windowprocedure
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	BorderWidth = 0
	ctlabout = ctl32_scontainer - Carlos Alloatti & Malcolm Greene.		&& Returns information about the class.
	ctlactivescrollbars = 0		&& Specifies whether scrollbars are needed. It does not indicate if the scrollbars are visible. Can be used to control an optional scroll control. 0: none, 1: horizontal, 2: vertical, 3: both.
	ctlallowdrag = .T.
	ctlallowzoom = .T.
	ctlautocenter = .T.		&& Specifies whether the child control should be centered in the scrollable container when the scrollable container is bigger that the child control.
	ctlautoscroll = .T.
	ctlbackcolor = -1
	ctlbackstyle = 1
	ctlbordercolor = -1
	ctlborderstyle = 1
	ctlforcescrollbars = 0		&& Specifies whether scrollbars should be always visible. Visible scrollbars will be disabled when not needed.
	ctlhenabled = .F.		&& Specifies if the horizontal scrollbar is enabled or required.
	ctlhhwnd = 0		&& Returns a handle to the horizontal scrollbar control window.
	ctlhlargechange = -1		&& Specifies the increment an horizontal scrollbar scrolls when you click on the scrollbar track.
	ctlhmargin = 5		&& Specifies the horizontal margin to use when autoscrolling to the active control.
	ctlhmax = 0
	ctlhsmallchange = 20		&& Specifies the horizontal scrolling increment for a form's horizontal scroll bar.
	ctlhvalue = 0		&& Sets or returns the actual horizontal scroll value of the client control.
	ctlhvisible = .F.		&& Specifies if the horizontal scrollbar is visible.
	ctlhwheelchange = 40		&& Specifies the increment an horizontal scrollbar scrolls when you use the mouse wheel.
	ctlscrollbars = 3		&& Specifies the type of scroll bars a control has.
	ctlthemes = .T.
	ctlvenabled = .F.		&& Specifies if the vertical scrollbar is enabled or required.
	ctlversion = 20061010
	ctlvhwnd = 0		&& Returns a handle to the horizontal scrollbar control window.
	ctlvlargechange = -1		&& Specifies the increment a vertical scrollbar scrolls when you click on the scrollbar track.
	ctlvmargin = 5		&& Specifies the vertical margin to use when autoscrolling to the active control.
	ctlvmax = 0
	ctlvsmallchange = 20		&& Specifies the increment a vertical scrollbar scrolls when you click on a scroll arrow.
	ctlvvalue = 0		&& Sets or returns the actual vertical scroll value of the client control.
	ctlvvisible = .F.		&& Specifies if the vertical scrollbar is visible.
	ctlvwheelchange = 40		&& Specifies the increment a vertical scrollbar scrolls when you use the mouse wheel.
	ctlzoom = 1
	Height = 120
	Name = "ctl32_scontainer"
	Width = 240
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	_windowprocedure = 0

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_scontainer", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 3, ;
		Name = "lblname", ;
		Top = 3, ;
		Width = 81
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE AddObject
		Lparameters cName, cClass
		
		If This.ControlCount > 0 Then
		    This.RemoveObject(This.Controls(1).Name)
		Endif
		
		
		
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlautocenter_assign
		Lparameters vNewVal
		
		This.ctlAutoCenter = m.vNewVal
		
		This._Resize()
		
	ENDPROC

	HIDDEN PROCEDURE ctlbackcolor_assign
		Lparameters vNewVal
		
		This.ctlBackColor = m.vNewVal
		
		If This.ctlBackColor = -1 Then
		    Thisform.AddObject("G8FAA4444E2DF43BEA972D4CF94950A8F", "Textbox")
		
		    *!* Store standard textbox backcolor
		    This.nDefaultBackColor = Thisform.G8FAA4444E2DF43BEA972D4CF94950A8F.BackColor
		
		    Thisform.RemoveObject("G8FAA4444E2DF43BEA972D4CF94950A8F")
		Endif
		
		This.BackColor = Iif(This.ctlBackColor = -1, This.nDefaultBackColor, This.ctlBackColor)
		
		*!* Set backcolor of border container
		This.oCntBorder.BackColor = This.BackColor
		
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlbackstyle_assign
		Lparameters vNewVal
		
		This.ctlBackStyle = m.vNewVal
		
		This.BackStyle = m.vNewVal
		
		*!* Set backstyle of border container
		This.oCntBorder.BackStyle = This.ctlBackStyle
		
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlbordercolor_assign
		Lparameters vNewVal
		
		*!* 20071107 changed hack to using uxtheme api
		
		This.ctlBorderColor = m.vNewVal
		
		*!* #define VSCLASS_EDIT Strconv("EDIT" + 0h00, 5)
		*!*	enum EDITPARTS {
		*!*		EP_EDITTEXT = 1,
		*!*		EP_CARET = 2,
		*!*		EP_BACKGROUND = 3,
		*!*		EP_PASSWORD = 4,
		*!*		EP_BACKGROUNDWITHBORDER = 5,
		*!*		EP_EDITBORDER_NOSCROLL = 6,
		*!*		EP_EDITBORDER_HSCROLL = 7,
		*!*		EP_EDITBORDER_VSCROLL = 8,
		*!*		EP_EDITBORDER_HVSCROLL = 9,
		*!*	};
		*!*	enum BACKGROUNDWITHBORDERSTATES {
		*!*		EBWBS_NORMAL = 1,
		*!*		EBWBS_HOT = 2,
		*!*		EBWBS_DISABLED = 3,
		*!*		EBWBS_FOCUSED = 4,
		*!*	};
		*!*
		
		Local ;
			m.lnTheme, ;
			m.lnColor
		
		m.lnColor = 0
		If ctlIsThemeActive() Then
			m.lnTheme = apiOpenThemeData(0, VSCLASS_EDIT)
			If m.lnTheme <> 0 Then
				apiGetThemeColor(m.lnTheme, EP_BACKGROUNDWITHBORDER, EBWBS_NORMAL, TMT_BORDERCOLOR, @m.lnColor)
				apiCloseThemeData(m.lnTheme)
			Endif
		Endif
		
		This.nDefaultBorderColor = m.lnColor
		
		This.oCntBorder.BorderColor = Iif(This.ctlBorderColor = -1, This.nDefaultBorderColor, This.ctlBorderColor)
		
		
	ENDPROC

	HIDDEN PROCEDURE ctlborderstyle_assign
		Lparameters vNewVal
		
		Local lnAnchor as Integer
		
		This.ctlBorderStyle = m.vNewVal
		
		*!* Resize control, add old border width, substract new border width
		m.lnAnchor = This.Anchor
		This.Anchor = 0
		
		If This.nOldBorderStyle = 1 Then
			This.Top = This.Top       - This.nBorderWidth
			This.Left = This.Left     - This.nBorderWidth
			This.Width = This.Width   + This.nBorderWidth * 2
			This.Height = This.Height + This.nBorderWidth * 2
		Endif
		
		If This.ctlBorderStyle = 1 Then
			This.Top = This.Top       + This.nBorderWidth
			This.Left = This.Left     + This.nBorderWidth
			This.Width = This.Width   - This.nBorderWidth * 2
			This.Height = This.Height - This.nBorderWidth * 2
		Endif
		
		This.Anchor = m.lnAnchor
		
		If This.ctlBorderStyle = 1 Then
			This.oCntBorder.BorderWidth = This.nBorderWidth
		Else
			This.oCntBorder.BorderWidth = 0
		Endif
		
		This.nOldBorderStyle = This.ctlBorderStyle
		
	ENDPROC

	PROCEDURE ctldoscroll		&& Scrolls the control to simulate a user clicking the scroll bars.
		*!*	0 Scroll Line up     SmallChange
		*!*	1 Scroll Line down   SmallChange
		*!*	2 Scroll Page up     LargeChange
		*!*	3 Scroll Page down   LargeChange
		*!*	6 Scroll Top
		*!*	7 Scroll Bottom
		
		*!*	10 Scroll Line left  SmallChange
		*!*	11 Scroll Line right SmallChange
		*!*	12 Scroll Page left  LargeChange
		*!*	13 Scroll Page right LargeChange
		*!*	16 Scroll Left
		*!*	17 Scroll Right
		
		Lparameters nDirection
		
		Local ;
			m.lnHWND, ;
			m.lnMSG, ;
			m.lnWPARAM, ;
			m.lnLPARAM
		
		Do Case
			Case m.nDirection = 0
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_LINELEFT
				m.lnMSG    = WM_VSCROLL
		
			Case m.nDirection = 1
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_LINERIGHT
				m.lnMSG    = WM_VSCROLL
		
			Case m.nDirection = 2
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_PAGELEFT
				m.lnMSG    = WM_VSCROLL
		
			Case m.nDirection = 3
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_PAGERIGHT
				m.lnMSG    = WM_VSCROLL
		
			Case m.nDirection = 6
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_TOP
				m.lnMSG    = WM_VSCROLL
		
			Case m.nDirection = 7
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_BOTTOM
				m.lnMSG    = WM_VSCROLL
		
			Case m.nDirection = 10
				m.lnLPARAM = This.nHCtlHwnd
				m.lnWPARAM = SB_LINELEFT
				m.lnMSG    = WM_HSCROLL
		
			Case m.nDirection = 11
				m.lnLPARAM = This.nHCtlHwnd
				m.lnWPARAM = SB_LINERIGHT
				m.lnMSG    = WM_HSCROLL
		
			Case m.nDirection = 12
				m.lnLPARAM = This.nHCtlHwnd
				m.lnWPARAM = SB_PAGELEFT
				m.lnMSG    = WM_HSCROLL
		
			Case m.nDirection = 13
				m.lnLPARAM = This.nHCtlHwnd
				m.lnWPARAM = SB_PAGERIGHT
				m.lnMSG    = WM_HSCROLL
		
			Case m.nDirection = 16
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_LEFT
				m.lnMSG    = WM_HSCROLL
		
			Case m.nDirection = 17
				m.lnLPARAM = This.nVCtlHwnd
				m.lnWPARAM = SB_RIGHT
				m.lnMSG    = WM_HSCROLL
		Endcase
		
		This._Scroll(0, m.lnMSG, m.lnWPARAM, m.lnLPARAM)
		
	ENDPROC

	HIDDEN PROCEDURE ctlforcescrollbars_assign
		Lparameters vNewVal
		
		This.ctlForceScrollBars = m.vNewVal
		
		This._Resize()
		
	ENDPROC

	HIDDEN PROCEDURE ctlhhwnd_access
		RETURN This.nHCtlHwnd
		
	ENDPROC

	HIDDEN PROCEDURE ctlhhwnd_assign
		LPARAMETERS vNewVal
		Return
	ENDPROC

	HIDDEN PROCEDURE ctlhmax_access
		Local ;
			lnMin As Number, ;
			lnMax As Number
		
		m.lnMin = 0
		m.lnMax = 0
		
		apiGetScrollRange(This.nHCtlHwnd, SB_CTL, @ m.lnMin, @ m.lnMax)
		
		Return m.lnMax - (This.Width - 1)
		
	ENDPROC

	HIDDEN PROCEDURE ctlhmax_assign
		LPARAMETERS vNewVal
		
	ENDPROC

	HIDDEN PROCEDURE ctlhvalue_access
		Return apiGetScrollPos(This.nHCtlHwnd, SB_CTL)
		
	ENDPROC

	HIDDEN PROCEDURE ctlhvalue_assign
		Lparameters vNewVal
		
		Local lnHWND, lnMSG, lnWPARAM, lnLPARAM
		
		m.lnHWND   = 0
		m.lnMSG    = WM_HSCROLL
		m.lnWPARAM = ctlMakewParam(SB_THUMBPOSITION, Max(m.vNewVal, 0))
		m.lnLPARAM = This.nHCtlHwnd
		
		This._Scroll(m.lnHWND, m.lnMSG, m.lnWPARAM, m.lnLPARAM)
		
	ENDPROC

	PROCEDURE ctlrestoresize
		*!* ctlRestoreSize()
		
		Local lnAnchor As Integer
		
		If This.ControlCount > 0 And This.Controls(1).BaseClass = "Image" And This.Controls(1).Stretch > 0 Then
			With This.Controls(1)
				m.lnAnchor = .Anchor
				.Anchor = 0
				.Width = This.nOriginalWidth
				.Height = This.nOriginalHeight
				.Anchor = m.lnAnchor
				This.nZoomIndex = This.nDefaultZoomIndex
				This._Resize()
				*!* This part looks really complex, we need to scroll so what was in the middle
				*!* of the viewport stays in the middle. UNSOLVED YET!
				If This.ctlVEnabled Then
					This.ctlVVAlue = 0
				Endif
				If This.ctlHEnabled Then
					This.ctlHValue = 0
				Endif
			Endwith
			This.ctlZoom = 100
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE ctlscrollbars_assign
		LPARAMETERS vNewVal
		
		THIS.ctlScrollBars = m.vNewVal
		
		This._Resize()
		
		
	ENDPROC

	PROCEDURE ctlscrolled		&& Occurs when the horizontal or vertical scroll bars are clicked or dragged
		Lparameters nDirection
		
	ENDPROC

	HIDDEN PROCEDURE ctlvhwnd_access
		RETURN This.nVCtlHwnd
		
	ENDPROC

	HIDDEN PROCEDURE ctlvhwnd_assign
	ENDPROC

	HIDDEN PROCEDURE ctlvmax_access
		Local ;
			lnMin As Number, ;
			lnMax As Number
		
		m.lnMin = 0
		m.lnMax = 0
		
		apiGetScrollRange(This.nVCtlHwnd, SB_CTL, @ m.lnMin, @ m.lnMax)
		
		Return m.lnMax - (This.Height - 1)
		
	ENDPROC

	HIDDEN PROCEDURE ctlvmax_assign
		LPARAMETERS vNewVal
		
	ENDPROC

	HIDDEN PROCEDURE ctlvvalue_access
		Return apiGetScrollPos(This.nVCtlHwnd, SB_CTL)
		
	ENDPROC

	HIDDEN PROCEDURE ctlvvalue_assign
		Lparameters vNewVal
		
		Local lnHWND, lnMSG, lnWPARAM, lnLPARAM
		
		m.lnHWND   = 0
		m.lnMSG    = WM_VSCROLL
		m.lnWPARAM = ctlMakewParam(SB_THUMBPOSITION, Max(m.vNewVal, 0))
		m.lnLPARAM = This.nVCtlHwnd
		
		This._Scroll(m.lnHWND, m.lnMSG, m.lnWPARAM, m.lnLPARAM)
		
	ENDPROC

	PROCEDURE DblClick
		*!* 20071108 Added This.ctlAllowZoom check ** Cesar Chalom
		
		If This.ctlAllowZoom = TRUE Then
			This.ctlRestoreSize()
		Endif
		
	ENDPROC

	PROCEDURE Init
		*!* Init
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		*!* Add properties used internally
		This._AddObjects()
		This._AddProperties()
		
		*!* Fill 
		This._SetZoomRatios()
		
		*!* Create scrollbars
		This._Create()
		
		This._BindEvents()
		
		
		
	ENDPROC

	PROCEDURE MouseDown
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		*!* 20071108 Added This.ctlAllowDrag check ** Cesar Chalom
		
		If This.ctlAllowDrag = TRUE And m.nButton = BUTTON_LEFT And This.ControlCount > 0  Then
			This.Controls(1).MousePointer = MOUSE_HAND
			This.nXCoord = m.nXCoord
			This.nYCoord = m.nYCoord
			This.lMouseDown = TRUE
		Endif
		
		
	ENDPROC

	PROCEDURE MouseMove
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		*!* lMouseDown will only be true if AllowDrag = .T.
		
		If This.lMouseDown = TRUE Then
			If This.ControlCount > 0 And Not (This.Width > This.Controls(1).Width) Then
				This.ctlHValue = This.ctlHValue - m.nXCoord + This.nXCoord
			Endif
		
			If This.ControlCount > 0 And Not (This.Height > This.Controls(1).Height) Then
				This.ctlVVAlue = This.ctlVVAlue - m.nYCoord + This.nYCoord
			Endif
		
			This.nXCoord = m.nXCoord
			This.nYCoord = m.nYCoord
		Endif
		
	ENDPROC

	PROCEDURE MouseUp
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		If This.ControlCount > 0 And m.nButton = BUTTON_LEFT Then
			This.Controls(1).MousePointer = MOUSE_DEFAULT
		Endif
		
		This.lMouseDown = FALSE
		
	ENDPROC

	PROCEDURE MouseWheel
		Lparameters nDirection, nShift, nXCoord, nYCoord
		
		Local ;
			lcExcluded As Character, ;
			loControl As Control
		
		Local ;
			lnWheelTicks As Number, ;
			lnWheelChange As Number, ;
			lnLargeChange As Number, ;
			lnViewPortSize As Number
		
		Local  lnAnchor
		
		m.lcExcluded = "COMBOBOX, LISTBOX, EDITBOX, GRID, SPINNER"
		m.loControl = Sys(1270)
		
		If This.ControlCount > 0 And Type("This.Controls(1).ActiveControl") == T_OBJECT And Type("m.loControl") == T_OBJECT
			If Upper(This.Controls(1).ActiveControl.BaseClass) $ m.lcExcluded And ;
					Sys(1272, m.loControl) == Sys(1272, This.Controls(1).ActiveControl)	Then
				Return
			Endif
		Endif
		
		m.lnWheelTicks = m.nDirection / 120
		
		*!* If Shift pressed
		If m.nShift = 1 Then
			m.lnWheelChange  = This.ctlHWheelChange  * m.lnWheelTicks
			m.lnLargeChange  = This.ctlHLargeChange
			m.lnViewPortSize = This.Width
		Else
			m.lnWheelChange  = This.ctlVWheelChange  * m.lnWheelTicks
			m.lnLargeChange  = This.ctlVLargeChange
			m.lnViewPortSize = This.Height
		Endif
		
		If m.lnLargeChange < 0 Then
			m.lnLargeChange = m.lnViewPortSize
		Else
			*!* LargeChange is a % of viewport
			If m.lnLargeChange < 1
				m.lnLargeChange = Int(m.lnViewPortSize * m.lnLargeChange)
			Endif
		Endif
		
		m.lnLargeChange = m.lnLargeChange * m.lnWheelTicks
		
		Do Case
			Case m.nShift = 0 And This.ctlVEnabled And Inlist(This.ctlScrollBars, 2, 3)
				This.ctlVVAlue = This.ctlVVAlue - m.lnWheelChange
		
			Case m.nShift = 1 And This.ctlHEnabled And Inlist(This.ctlScrollBars, 1, 3) && Shift
				This.ctlHValue = This.ctlHValue - m.lnWheelChange
		
				*!* 20071108 Added This.ctlAllowZoom check ** Cesar Chalom
				*!* 20071108 Added check for stretch property
		
			Case m.nShift = 2 And This.ctlAllowZoom = TRUE && Ctrl then Resize if image
				If This.ControlCount > 0 And This.Controls(1).BaseClass = "Image" And This.Controls(1).Stretch > 0 Then
		
					This.nZoomIndex = Iif(m.lnWheelTicks > 0, This.nZoomIndex + 1, This.nZoomIndex - 1)
					If This.nZoomIndex <= 0 Then
						This.nZoomIndex = 1
					Endif
					If This.nZoomIndex > This.nMaxZoomIndex Then
						This.nZoomIndex = This.nMaxZoomIndex
					Endif
		
					This.ctlZoom = Round(This.aZoomLevel(This.nZoomIndex) * 100, 0)
		
					With This.Controls(1)
						m.lnAnchor = .Anchor
						.Anchor = 0
						.Height = This.nOriginalHeight * This.aZoomLevel(This.nZoomIndex)
						.Width = This.nOriginalWidth * This.aZoomLevel(This.nZoomIndex)
						.Anchor = m.lnAnchor
						This._Resize()
						*!* This part looks really complex, we need to scroll so what was in the middle
						*!* of the viewport stays in the middle. UNSOLVED YET!
						If This.ctlVEnabled Then
							This.ctlVVAlue = This.ctlVVAlue * .Height / This.nOriginalHeight
						Endif
						If This.ctlHEnabled Then
							This.ctlHValue = This.ctlHValue * .Width / This.nOriginalWidth
						Endif
					Endwith
		
				Endif
		Endcase
		
		
		
	ENDPROC

	PROCEDURE NewObject
		*!* NewObject
		
		Lparameters cName, cClass, cModule, cInApplication
		
		If This.ControlCount > 0 Then
		    This.RemoveObject(This.Controls(1).Name)
		Endif
		
		
	ENDPROC

	HIDDEN PROCEDURE _activateform
		*!* //Dorin Vasilescu// TaskBar Class
		*!* Set the form active if not active when clicking on scrollbar
		
		If Type("_Screen.ActiveForm") == T_OBJECT
			*If the form is the topmost form just exit
			If Thisform = _Screen.ActiveForm
				Return
			Endif
		Endif
		
		Local ;
			loForm As Form, ;
			llModalWindow As Logical
		
		For Each m.loForm In _Screen.Forms
			If Vartype(m.loForm.WindowType) == T_NUMERIC
				If m.loForm.WindowType = 1
					m.llModalWindow = TRUE
					Exit
				Endif
			Endif
		Endfor
		
		If m.llModalWindow = FALSE Then
			For Each m.loForm In _Screen.Forms
				If m.loForm.HWnd = Thisform.HWnd
					If Type("m.loForm.ActiveControl") == T_OBJECT
						If Pemstatus(m.loForm.ActiveControl, "SetFocus", CON_PEMSTAT_DEFINED)
							m.loForm.ActiveControl.SetFocus()
						Endif
					Else
						m.loForm.Show()
					Endif
					Exit
				Endif
			Endfor
		Endif
		
	ENDPROC

	PROCEDURE _addobjects
		*!* _AddObjects()
		
		*!* Define ScrollInfo Object to be used by various methods
		This.AddProperty("_ScrollInfo", Createobject("_SCROLLINFO"))
		
		
	ENDPROC

	HIDDEN PROCEDURE _addproperties
		
		*!* Stores border Container 
		This.AddProperty("cCntBorderName", Sys(2015))
		
		*!* Stores an object reference to the cntBorder container control
		This.AddProperty("oCntBorder", null)
		
		*!* Stores full name of previous active control
		This.AddProperty("cPrevControlFullName", "")
		
		*!* Stores starting width and height of the client control
		This.AddProperty("nOriginalHeight", 0)
		This.AddProperty("nOriginalWidth", 0)
		
		*!* Stores Max Zoom Index
		This.AddProperty("nMaxZoomIndex", 35)
		
		*!* Stores default zoom index
		This.AddProperty("nDefaultZoomIndex", 19)
		
		*!* Stores actual zoom index
		This.AddProperty("nZoomIndex", This.nDefaultZoomIndex)
		
		*!* Array to hold zoom level values, as a percent of actual size
		This.AddProperty("aZoomLevel(This.nMaxZoomIndex)", 0)
		
		*!* Stores width of border to use (1 with themes on, 2 with themes 2)
		This.AddProperty("nBorderWidth", 0)
		
		*!* Stores back color
		This.AddProperty("nDefaultBackColor", 0)
		
		*!* Stores border color
		This.AddProperty("nDefaultBorderColor", 0)
		
		*!* Stores the hWnd of the host window
		This.AddProperty("nHosthWnd", ctlGetHostHWnd(This))
		
		*!* Stores HWND of horizontal scrollbar control
		This.AddProperty("nHCtlHwnd", 0)
		
		*!* Stores value of previous BorderStyle setting
		This.AddProperty("nOldBorderStyle", 0)
		
		*!* Stores height of standard horizontal scrollbar
		This.AddProperty("nScrollHeight", Sysmetric(SYSMETRIC_HSCROLLBARHEIGHT))
		
		*!* Stores width of standard vertical scrollbar
		This.AddProperty("nScrollWidth", Sysmetric(SYSMETRIC_VSCROLLBARWIDTH))
		
		*!* Stores HWND of vertical scrollbar control
		This.AddProperty("nVCtlHwnd", 0)
		
		*!* Stores old mouse coordinates
		This.AddProperty("nXCoord", 0)
		This.AddProperty("nYCoord", 0)
		
		*!* Reports that horizontal scrollbar is enabled and visible
		This.AddProperty("lHScrollBar", FALSE)
		
		*!* Stores if control is inside a pageframe
		This.AddProperty("lInPage", FALSE)
		
		*!* Stores state of mousebutton
		This.AddProperty("lMouseDown", FALSE)
		
		*!* Indicates if the page that contains the control is the active page
		*!* (if control is inside a pageframe)
		This.AddProperty("lPageActive", FALSE)
		
		*!* Indicates if resizing is already taking place
		This.AddProperty("lResizing", FALSE)
		
		*!* Reports that vertical scrollbar is enabled and visible
		This.AddProperty("lVScrollBar", FALSE)
		
		********************************************************************************
		*!* Form properties
		********************************************************************************
		
		*!* This properties are used to proxy window messages
		Thisform.AddProperty("_scontainerHwnd", 0)
		Thisform.AddProperty("_scontainerWM", 0)
		Thisform.AddProperty("_scontainerWparam", 0)
		Thisform.AddProperty("_scontainerLparam", 0)
		
		
	ENDPROC

	HIDDEN PROCEDURE _bindevents
		*!* _BindEvents()
		
		*!* Since we can only have one Hwnd/message pair with Bindevent, we add properties
		*!* to the form in Init and Bind to ThisForm._scroll_Msg. This way we can have more than one
		*!* scrollable container in a form
		
		Local loControl As Control
		
		This._WindowProcedure = ctlGetWindowProcedure(Thisform.HWnd)
		
		*Bindevent(This, "AddObject", This, "_EventNewObject",	1)
		Bindevent(This, "NewObject", This, "_EventNewObject", 1)
		
		Bindevent(This, "Resize", This, "_EventResize", 1)
		Bindevent(This, "Moved",  This, "_EventMoved", 1)
		
		*!* Bind window messages to window message proxy handler
		Bindevent(This.nHosthWnd, WM_HSCROLL, This,	"_wm_event", 5)
		Bindevent(This.nHosthWnd, WM_VSCROLL, This,	"_wm_event", 5)
		
		Bindevent(Thisform, "Visible", This, "_EventFormVisible", 1)
		
		*!* We will scan the object hierarchy to see if we have a page from a pageframe somewhere
		*!* and we will bind to the page activate and deactivate events
		m.loControl = This.Parent
		Do While Not Upper(loControl.BaseClass) == "FORM"
			If Upper(m.loControl.BaseClass) == "PAGE" Then
				This.lInPage = TRUE
				Bindevent(m.loControl, "Activate", This, "_EventPageActivate", 1)
				Bindevent(m.loControl, "Deactivate", This, "_EventPageDeactivate", 1)
			Endif
			m.loControl = m.loControl.Parent
		Enddo
		
		*!* Bind window messages to window message proxy handler
		*!* This are used by the AutoScrolling method
		Bindevent(Thisform.HWnd, WM_KEYUP, This, "_wm_event", 5)
		Bindevent(Thisform.HWnd, WM_CAPTURECHANGED, This, "_wm_event", 5)
		Bindevent(Thisform.HWnd, WM_LBUTTONUP, This, "_wm_event", 5)
		
		*!* If we are in a top level form, lets make shure this works
		Bindevent(This.nHosthWnd, WM_KEYUP, This, "_wm_event", 5)
		Bindevent(This.nHosthWnd, WM_CAPTURECHANGED, This, "_wm_event", 5)
		Bindevent(This.nHosthWnd, WM_LBUTTONUP, This, "_wm_event", 5)
		
		*!* MouseWheel management
		If This.ControlCount > 0 Then
			This._BindMouseWheel(This.Controls(1))
		Endif
		
		*!* Click-Drag-Move Management
		If This.ControlCount > 0 Then
			Bindevent(This.Controls(1), "DblClick", This, "DblClick", 1)
			Bindevent(This.Controls(1), "MouseDown", This, "MouseDown", 1)
			Bindevent(This.Controls(1), "MouseUp", This, "MouseUp",	1)
			Bindevent(This.Controls(1), "MouseMove", This, "MouseMove",	1)
		Endif
		
		*!* Theme management
		Bindevent(_Screen, 	"Themes", This, "_EventScreenThemes", 1)
		Bindevent(Thisform, "Themes", This, "_EventFormThemes", 1)
		
		*!* Here we bind to thisform._scontainerWM, value that is set by _wm_event
		Bindevent(Thisform, "_scontainerWM", This, "_EventFormscontainerWM", 1)
		
		Bindevent(Thisform, "Activate", This, "_EventFormActivate", 1)
		
	ENDPROC

	HIDDEN PROCEDURE _bindmousewheel
		*!* _BindMouseWheel()
		*!* This method binds the MouseWheel event of all contained controls
		*!* to the MouseWheel event of the scrollable container.
		*!* It goes thru the whole control hierarchy.
		
		Lparameters toObject
		
		Local loChildObject As Control
		Local lcThisMethod
		
		*!* 20080613
		*!* Get the name of this method, so we don´t have to know it:
		*!* - m.lcThisMethod = "This." + Getwordnum(Program(), Getwordcount(Program(), "."), ".")
		
		If Pemstatus(m.toObject, "MouseWheel", CON_PEMSTAT_DEFINED)
			Bindevent(m.toObject, "MouseWheel", This, "MouseWheel", 1)
		Endif
		
		*!* 20080613
		*!*_http://ctl32.freeforums.org/ctl32-scontainer-bindmousewheel-falla-con-objetos-control-t17.html
		If Pemstatus(m.toObject, "Objects", CON_PEMSTAT_DEFINED) And m.toObject.BaseClass # "Control"
			For Each m.loChildObject In m.toObject.Objects
				*!* - Evaluate(m.lcThisMethod + "(m.loChildObject)")
				This._BindMouseWheel(m.loChildObject)
			Endfor
		Endif
		
	ENDPROC

	HIDDEN PROCEDURE _create
		Local ;
			m.lnAnchor, ;
			m.llLock
		
		*!* Save client control dimensions:
		If This.ControlCount > 0 Then
			This.nOriginalHeight = This.Controls(1).Height
			This.nOriginalWidth  = This.Controls(1).Width
		Endif
		
		*!* Resize control to make room for a border if a border is set
		*!* border gets done in _AddBorder()
		
		m.llLock = Thisform.LockScreen
		Thisform.LockScreen = TRUE
		
		This.BorderWidth = 0
		
		*!* Add border Container
		This.Parent.AddObject(This.cCntBorderName, "Container")
		This.oCntBorder = Evaluate("This.Parent." + This.cCntBorderName)
		
		This.oCntBorder.BackStyle = This.BackStyle
		This.oCntBorder.BorderWidth = 0
		This.oCntBorder.Top =    This.Top
		This.oCntBorder.Left =   This.Left
		This.oCntBorder.Width =  This.Width  + Iif(This.ctlVvisible, This.nScrollWidth,  0)
		This.oCntBorder.Height = This.Height + Iif(This.ctlHvisible, This.nScrollHeight, 0)
		This.oCntBorder.ZOrder(1)
		This.oCntBorder.Anchor = This.Anchor
		This.oCntBorder.Visible = TRUE
		
		*!* This creates the scrollbars, it does not position or make them visible.
		*!* _Resize positions, shows/hides scrollbars as needed
		
		Local ;
			dwExStyle As Integer, ;
			lpClassName As Character, ;
			lpWindowName As Character, ;
			dwStyle As Integer, ;
			hWndParent As Integer, ;
			hMenu As Integer, ;
			hInstance As Integer, ;
			lpParam As Integer, ;
			lnTop As Integer, ;
			lnLeft As Integer, ;
			lnWidth As Integer, ;
			lnHeight As Integer
		
		*!* Create Horizontal ScrollBar
		m.dwExStyle    =  0
		m.lpClassName  = WC_SCROLLBARA
		m.lpWindowName = Sys(2015)
		m.dwStyle      = Bitor(WS_CHILD, SBS_HORZ)
		m.hWndParent   = This.nHosthWnd
		m.hMenu        = 0
		
		*!* What is the HINSTANCE passed to CreateWindow and RegisterClass used for?
		*!* http://blogs.msdn.com/oldnewthing/archive/2005/04/18/409205.aspx
		
		m.hInstance    = 0
		m.lpParam      = 0
		m.lnTop        = This._ObjToClient(This, "B")
		m.lnLeft       = This._ObjToClient(This, "L")
		m.lnWidth      = This.Width
		m.lnHeight     = This.nScrollHeight
		
		This.nHCtlHwnd = apiCreateWindowEx( ;
			m.dwExStyle, ;
			m.lpClassName, ;
			m.lpWindowName, ;
			m.dwStyle, ;
			m.lnLeft, ;
			m.lnTop, ;
			m.lnWidth, ;
			m.lnHeight, ;
			m.hWndParent, ;
			m.hMenu, ;
			m.hInstance, ;
			m.lpParam)
		
		*!* Create Vertical Scrollbar
		m.dwExStyle    =  0
		m.lpClassName  = WC_SCROLLBARA
		m.lpWindowName = Sys(2015)
		m.dwStyle      = Bitor(WS_CHILD, SBS_VERT)
		m.hWndParent   = This.nHosthWnd
		m.hMenu        = 0
		m.hInstance    = 0
		m.lpParam      = 0
		m.lnTop        = This._ObjToClient(This, "T")
		m.lnLeft       = This._ObjToClient(This, "R")
		m.lnWidth      = This.nScrollWidth
		m.lnHeight     = This.Width
		
		This.nVCtlHwnd = apiCreateWindowEx( ;
			m.dwExStyle, ;
			m.lpClassName, ;
			m.lpWindowName, ;
			m.dwStyle, ;
			m.lnLeft, ;
			m.lnTop, ;
			m.lnWidth, ;
			m.lnHeight, ;
			m.hWndParent, ;
			m.hMenu, ;
			m.hInstance, ;
			m.lpParam)
		
		This._SetTheme()
		This.ctlBackColor 		= This.ctlBackColor
		This.ctlBackStyle 		= This.ctlBackStyle
		This.ctlBorderStyle 	= This.ctlBorderStyle
		*!* ctlBorderColor is set in evthanlder_form_activate,
		*!* we need form visible, this way we do not disrupt chain of events
		
		Thisform.LockScreen = m.llLock
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _eventformactivate
		*!* _EventFormActivate
		
		Unbindevents( Thisform, "Activate", This, "_EventFormActivate")
		
		This.ctlBorderColor = This.ctlBorderColor
		
	ENDPROC

	HIDDEN PROCEDURE _eventformscontainerwm
		*!* _EventFormscontainerWM
		
		Do Case
			Case Thisform._scontainerWM = WM_HSCROLL And Thisform._scontainerLparam = This.nHCtlHwnd
					This._Scroll(Thisform._scontainerHwnd, Thisform._scontainerWM, Thisform._scontainerWparam, Thisform._scontainerLparam)
		
			Case Thisform._scontainerWM = WM_VSCROLL And Thisform._scontainerLparam = This.nVCtlHwnd
					This._Scroll(Thisform._scontainerHwnd, Thisform._scontainerWM, Thisform._scontainerWparam, Thisform._scontainerLparam)
		
			Case Thisform._scontainerWM = WM_CAPTURECHANGED
				This._ScrollToControl()
		
			Case Thisform._scontainerWM = WM_KEYUP
				This._ScrollToControl()
		
			Case Thisform._scontainerWM = WM_LBUTTONUP
				This._ScrollToControl()
		
		Endcase
		
	ENDPROC

	HIDDEN PROCEDURE _eventformthemes
		This._SetTheme()
	ENDPROC

	HIDDEN PROCEDURE _eventformvisible
		This._Resize()
	ENDPROC

	HIDDEN PROCEDURE _eventmoved
		Local ;
		    lnTop As Number, ;
		    lnLeft As Number, ;
		    lnWidth As Number, ;
		    lnHeight As Number
		
		m.lnTop    = This._ObjToClient(This, "B")
		m.lnLeft   = This._ObjToClient(This, "L")
		m.lnWidth  = This.Width
		m.lnHeight = This.nScrollHeight
		
		apiSetWindowPos(This.nHCtlHwnd, ;
		    0, ;
		    m.lnLeft, ;
		    m.lnTop, ;
		    m.lnWidth, ;
		    m.lnHeight, ;
		    SWP_NOZORDER)
		
		m.lnTop    = This._ObjToClient(This, "T")
		m.lnLeft   = This._ObjToClient(This, "R")
		m.lnWidth  = This.nScrollWidth
		m.lnHeight = This.Height
		
		apiSetWindowPos(This.nVCtlHwnd, ;
		    0, ;
		    m.lnLeft, ;
		    m.lnTop, ;
		    m.lnWidth, ;
		    m.lnHeight, ;
		    SWP_NOZORDER)
		
		
	ENDPROC

	HIDDEN PROCEDURE _eventnewobject
		Lparameters cName, cClass, cModule, cInApplication
		
		Local loControl
		
		m.loControl = Evaluate("This." + m.cName)
		m.loControl.Visible = TRUE
		
		*!* Save client control dimensions:
		If This.ControlCount > 0 Then
		    This.nOriginalHeight = This.Controls(1).Height
		    This.nOriginalWidth  = This.Controls(1).Width
		Endif
		
		*!* MouseWheel management
		If This.ControlCount > 0 Then
		    This._BindMouseWheel(This.Controls(1))
		Endif
		
		*!* Click-Drag-Move Management
		If This.ControlCount > 0 Then
		    Bindevent(This.Controls(1), "DblClick", This, "DblClick", 1)
		    Bindevent(This.Controls(1), "MouseDown", This, "MouseDown", 1)
		    Bindevent(This.Controls(1), "MouseUp", This, "MouseUp",	1)
		    Bindevent(This.Controls(1), "MouseMove", This, "MouseMove",	1)
		Endif
		
		*!* Here we hide both scrollbars, so the thumb size updates in the
		*!* _Resize that follows.
		
		apiShowScrollBar(This.nHCtlHwnd, SB_CTL, 0)
		apiShowScrollBar(This.nVCtlHwnd, SB_CTL, 0)
		
		This._Resize()
		
	ENDPROC

	HIDDEN PROCEDURE _eventpageactivate
		*!* This manages scrollbars show/hide when changing active page in pageframes
		This.lPageActive = TRUE
		This._Resize()
		
	ENDPROC

	HIDDEN PROCEDURE _eventpagedeactivate
		*!* This manages scrollbars show/hide when changing active page in pageframes
		This.lPageActive = FALSE
		This._Resize()
		
	ENDPROC

	HIDDEN PROCEDURE _eventpageframeactivepage
		WAIT "activepage" window
	ENDPROC

	HIDDEN PROCEDURE _eventresize
		This._Resize()
		
	ENDPROC

	HIDDEN PROCEDURE _eventscreenthemes
		This._SetTheme()
	ENDPROC

	HIDDEN PROCEDURE _objtoclient
		*!* This replaces OBJTOCLIENT that has bugs with pageframes
		Parameters toControl, tcPosition
		
		Local lnPosition As Integer
		
		m.tcPosition = Upper(m.tcPosition)
		m.lnPosition = 0
		
		Do Case
		
			Case m.tcPosition $ "TB"
				Do While Not Upper(m.toControl.BaseClass) == "FORM"
					If Pemstatus(m.toControl, "Top", CON_PEMSTAT_DEFINED) Then
						m.lnPosition = m.lnPosition + m.toControl.Top
					Endif
					If Upper(m.toControl.BaseClass) == "PAGE" Then
						If m.toControl.Parent.TabOrientation = CON_TABOR_TOP Then	&& Top
							m.lnPosition = m.lnPosition + ;
								m.toControl.Parent.Height - ;
								m.toControl.Parent.PageHeight - ;
								m.toControl.Parent.BorderWidth * 2
						Else
							m.lnPosition = m.lnPosition + 1
						Endif
					Endif
					m.toControl = m.toControl.Parent
				Enddo
		
				If m.tcPosition == "B" Then
					m.lnPosition = m.lnPosition + This.Height
				Endif
		
			Case m.tcPosition $ "LR"
				Do While Not Upper(m.toControl.BaseClass) == "FORM"
					If Pemstatus(m.toControl, "Left", CON_PEMSTAT_DEFINED) Then
						m.lnPosition = m.lnPosition + m.toControl.Left
					Endif
					If Upper(m.toControl.BaseClass) == "PAGE"
						If m.toControl.Parent.TabOrientation = CON_TABOR_LEFT Then	&& Left
							m.lnPosition = m.lnPosition + ;
								m.toControl.Parent.Width - ;
								m.toControl.Parent.PageWidth - ;
								m.toControl.Parent.BorderWidth * 2
						Else
							m.lnPosition = m.lnPosition + 1
						Endif
					Endif
					m.toControl = m.toControl.Parent
				Enddo
		
				If m.tcPosition == "R" Then
					m.lnPosition = m.lnPosition + This.Width
				Endif
		
		Endcase
		
		Return m.lnPosition
		
	ENDPROC

	HIDDEN PROCEDURE _resize
		If This.lResizing = TRUE Then
		    Return
		Endif
		
		This.lResizing = TRUE
		
		Local llOldLockScreen As Logical
		
		Local ;
		    lnClientWidth As Number, ;
		    lnClientHeight As Number, ;
		    lnOldAnchor As Number, ;
		    lnViewPortWidth As Number, ;
		    lnViewPortHeight As Number, ;
		    lnTop As Number, ;
		    lnLeft As Number, ;
		    lnHeight As Number, ;
		    lnWidth As Number, ;
		    lnPosition As Number, ;
		    lnShow As Integer
		
		m.llOldLockScreen = Thisform.LockScreen
		
		Thisform.LockScreen = TRUE
		
		*!* If client container should autosize with SC
		If This.ControlCount > 0
		    If This.Controls(1).Anchor = 10 Then
		        m.lnOldAnchor = This.Controls(1).Anchor
		        This.Controls(1).Anchor = 0
		        This.Controls(1).Left = 0
		        This.Controls(1).Width = This.Width - This.nScrollWidth
		        This.Controls(1).Anchor = m.lnOldAnchor
		    Endif
		    If This.Controls(1).Anchor = 5 Then
		        m.lnOldAnchor = This.Controls(1).Anchor
		        This.Controls(1).Anchor = 0
		        This.Controls(1).Top = 0
		        This.Controls(1).Height = This.Height - This.nScrollHeight
		        This.Controls(1).Anchor = m.lnOldAnchor
		    Endif
		Endif
		
		*!* Store Width and Height of the Client Area:
		If This.ControlCount > 0 Then
		    m.lnClientWidth = This.Controls(1).Width
		    m.lnClientHeight = This.Controls(1).Height
		Else
		    m.lnClientWidth = This.Width / 2
		    m.lnClientHeight = This.Height / 2
		Endif
		
		*!* Restore Width and Height of Scrollable Container
		*!* Only change Anchor if Width > 0 to prevent Anchor bug.
		If Not (This.Width = 0 Or This.Height = 0) Then
		    m.lnOldAnchor = This.Anchor
		    This.Anchor = 0
		    If This.lHScrollBar = TRUE  Then
		        This.Height = This.Height + This.nScrollHeight
		    Endif
		    If This.lVScrollBar = TRUE Then
		        This.Width = This.Width + This.nScrollWidth
		    Endif
		    This.Anchor = m.lnOldAnchor
		Endif
		
		*!* Set ViewPort
		m.lnViewPortWidth = This.Width
		m.lnViewPortHeight = This.Height
		
		
		*!* If ScrollBar wanted
		If Inlist(This.ctlScrollBars, 1, 3) Then
		    *!* If needed or forced
		    If This.Width < m.lnClientWidth Or Inlist(This.ctlForceScrollBars, 1, 3) Then
		        m.lnViewPortHeight = m.lnViewPortHeight - This.nScrollHeight
		        This.lHScrollBar = TRUE
		    Else
		        This.lHScrollBar = FALSE
		    Endif
		Else
		    This.lHScrollBar = FALSE
		Endif
		
		*!* If ScrollBar wanted
		If Inlist(This.ctlScrollBars, 2, 3) Then
		    *!* If Needed or forced
		    If This.Height < m.lnClientHeight Or Inlist(This.ctlForceScrollBars, 2, 3) Then
		        m.lnViewPortWidth = m.lnViewPortWidth - This.nScrollWidth
		        This.lVScrollBar = TRUE
		    Else
		        This.lVScrollBar = FALSE
		    Endif
		Else
		    This.lVScrollBar = FALSE
		Endif
		
		*!* Now check again since added ScrollBars make ViewPort even smaller
		*!* No need to check for ctlForceScrollBars now
		If Inlist(This.ctlScrollBars, 1, 3) Then
		    If (This.lHScrollBar = FALSE And This.lVScrollBar = TRUE) Then
		        If m.lnViewPortWidth < m.lnClientWidth Then
		            m.lnViewPortHeight = m.lnViewPortHeight - This.nScrollHeight
		            This.lHScrollBar = TRUE
		        Endif
		    Endif
		Endif
		
		If Inlist(This.ctlScrollBars, 2, 3) Then
		    If (This.lVScrollBar = FALSE And This.lHScrollBar = TRUE) Then
		        If m.lnViewPortHeight < m.lnClientHeight Then
		            m.lnViewPortWidth = m.lnViewPortWidth - This.nScrollWidth
		            This.lVScrollBar = TRUE
		        Endif
		    Endif
		Endif
		
		*!* Resize scrollable container to acomodate scrollbars
		If This.lHScrollBar = TRUE Or This.lVScrollBar = TRUE
		    If Not (This.Width = 0 Or This.Height = 0) Then
		        m.lnOldAnchor = This.Anchor
		        This.Anchor = 0
		        This.Height = m.lnViewPortHeight
		        This.Width = m.lnViewPortWidth
		        This.Anchor = m.lnOldAnchor
		    Endif
		Endif
		
		*!*	 Horizontal ScrollBar: update data, move, show if needed
		This._ScrollInfo.fMask     = Bitor(SIF_PAGE, SIF_RANGE)
		This._ScrollInfo.nMin      = 0
		This._ScrollInfo.nMax      = m.lnClientWidth - 1
		This._ScrollInfo.nPage     = m.lnViewPortWidth
		This._ScrollInfo.nPos      = 0
		This._ScrollInfo.nTrackPos = 0
		
		apiSetScrollInfo(This.nHCtlHwnd, SB_CTL, This._ScrollInfo.Address, 0)
		
		*!* Get ScrollBar Position and move child control
		m.lnPosition = apiGetScrollPos(This.nHCtlHwnd, SB_CTL)
		If This.ControlCount > 0 Then
		    m.lnOldAnchor = This.Controls(1).Anchor
		    This.Controls(1).Anchor = 0
		    This.Controls(1).Left = - m.lnPosition
		    This.Controls(1).Anchor = m.lnOldAnchor
		Endif
		
		m.lnTop    = This._ObjToClient(This, "B")
		m.lnLeft   = This._ObjToClient(This, "L")
		m.lnWidth  = This.Width
		m.lnHeight = This.nScrollHeight
		
		apiSetWindowPos(This.nHCtlHwnd, ;
		    0, ;
		    m.lnLeft, ;
		    m.lnTop, ;
		    m.lnWidth, ;
		    m.lnHeight, ;
		    SWP_NOZORDER)
		
		m.lnShow = 0
		
		If This.lHScrollBar = TRUE And This.Height > 0 Then
		    This.ctlHVisible = TRUE
		    m.lnShow = 1
		Else
		    This.ctlHVisible = FALSE
		    m.lnShow = 0
		Endif
		
		If This.lInPage = TRUE And This.lPageActive = FALSE Then
		    m.lnShow = 0
		Endif
		
		apiShowScrollBar(This.nHCtlHwnd, SB_CTL, m.lnShow)
		
		If m.lnViewPortWidth > m.lnClientWidth Then
		    apiEnableWindow(This.nHCtlHwnd, 0)
		    This.ctlHEnabled = FALSE
		Else
		    apiEnableWindow(This.nHCtlHwnd, 1)
		    This.ctlHEnabled = TRUE
		Endif
		
		*!* Vertical ScrollBar: update data, move, show if needed
		This._ScrollInfo.fMask     = Bitor(SIF_PAGE, SIF_RANGE)
		This._ScrollInfo.nMin      = 0
		This._ScrollInfo.nMax      = m.lnClientHeight - 1
		This._ScrollInfo.nPage     = m.lnViewPortHeight
		This._ScrollInfo.nPos      = 0
		This._ScrollInfo.nTrackPos = 0
		
		apiSetScrollInfo(This.nVCtlHwnd, SB_CTL, This._ScrollInfo.Address, 0)
		
		*!* Get ScrollBar Position and move Child control
		m.lnPosition = apiGetScrollPos(This.nVCtlHwnd, SB_CTL)
		
		If This.ControlCount > 0 Then
		    m.lnOldAnchor = This.Controls(1).Anchor
		    This.Controls(1).Anchor = 0
		    This.Controls(1).Top = - m.lnPosition
		    This.Controls(1).Anchor = m.lnOldAnchor
		Endif
		
		m.lnTop    = This._ObjToClient(This, "T")
		m.lnLeft   = This._ObjToClient(This, "R")
		m.lnWidth  = This.nScrollWidth
		m.lnHeight = This.Height
		
		apiSetWindowPos(This.nVCtlHwnd, ;
		    0, ;
		    m.lnLeft, ;
		    m.lnTop, ;
		    m.lnWidth, ;
		    m.lnHeight, ;
		    SWP_NOZORDER)
		
		m.lnShow = 0
		
		If This.lVScrollBar = TRUE And This.Width > 0 Then
		    This.ctlVVisible = TRUE
		    m.lnShow = 1
		Else
		    This.ctlVVisible = FALSE
		    m.lnShow = 0
		Endif
		
		If This.lInPage = TRUE And This.lPageActive = FALSE Then
		    m.lnShow = 0
		Endif
		
		apiShowScrollBar(This.nVCtlHwnd, SB_CTL, m.lnShow)
		
		If m.lnViewPortHeight > m.lnClientHeight Then
		    apiEnableWindow(This.nVCtlHwnd, 0)
		    This.ctlVEnabled = FALSE
		Else
		    apiEnableWindow(This.nVCtlHwnd, 1)
		    This.ctlVEnabled = TRUE
		Endif
		
		If This.ctlAutoCenter = TRUE And This.ControlCount > 0 Then
		    m.lnOldAnchor = This.Controls(1).Anchor
		    This.Controls(1).Anchor = 0
		    If This.Width > m.lnClientWidth
		        This.Controls(1).Left = (This.Width - This.Controls(1).Width) / 2
		    Endif
		
		    If This.Height > m.lnClientHeight Then
		        This.Controls(1).Top = (This.Height - This.Controls(1).Height) / 2
		    Endif
		    This.Controls(1).Anchor = m.lnOldAnchor
		Endif
		
		*!* Set value of ctlActiveScrollBars Property
		Do Case
		    Case This.lHScrollBar = TRUE And This.lVScrollBar = TRUE
		        This.ctlActiveScrollBars = 3
		    Case This.lHScrollBar = FALSE And This.lVScrollBar = TRUE
		        This.ctlActiveScrollBars = 2
		    Case This.lHScrollBar = TRUE And This.lVScrollBar = FALSE
		        This.ctlActiveScrollBars = 1
		    Otherwise
		        This.ctlActiveScrollBars = 0
		Endcase
		
		*!* If client container should autosize with SC
		If This.ControlCount > 0
		    If This.Controls(1).Anchor = 10 Then
		        m.lnOldAnchor = This.Controls(1).Anchor
		        This.Controls(1).Anchor = 0
		        This.Controls(1).Left = 0
		        This.Controls(1).Width = This.Width
		        This.Controls(1).Anchor = m.lnOldAnchor
		    Endif
		    If This.Controls(1).Anchor = 5 Then
		        m.lnOldAnchor = This.Controls(1).Anchor
		        This.Controls(1).Anchor = 0
		        This.Controls(1).Top = 0
		        This.Controls(1).Height = This.Height
		        This.Controls(1).Anchor = m.lnOldAnchor
		    Endif
		Endif
		
		Thisform.LockScreen = m.llOldLockScreen
		This.lResizing = FALSE
		
	ENDPROC

	HIDDEN PROCEDURE _scroll
		*!* http://windowssdk.msdn.microsoft.com/en-us/library/ms651283.aspx
		*!* The low-order word specifies a scroll bar value that indicates the user's scrolling request.
		*!* The high-order word specifies the current position of the scroll box if the low-order word
		*!* is SB_THUMBPOSITION or SB_THUMBTRACK; otherwise, this word is not used.
		
		Lparameters nHWND As Integer, nMSG As Integer, nWPARAM As Integer, nLPARAM As Integer
		
		This._ActivateForm()
		
		Local ;
		    lnMsg As Number, ;
		    lnRequest As Number, ;
		    lnPosition As Number, ;
		    lnHwnd As Number, ;
		    lnSmallChange As Number, ;
		    lnLargeChange As Number, ;
		    lnViewPortSize As Number, ;
		    lnOldAnchor As Number
		
		m.lnMsg      = m.nMSG
		m.lnRequest  = ctlLoWord(m.nWPARAM)
		m.lnHwnd     = m.nLPARAM
		m.lnPosition = apiGetScrollPos(m.lnHwnd, SB_CTL)
		
		If m.lnMsg = WM_HSCROLL Then
		    m.lnSmallChange  = This.ctlHSmallChange
		    m.lnLargeChange  = This.ctlHLargeChange
		    m.lnViewPortSize = This.Width
		Else
		    m.lnSmallChange  = This.ctlVSmallChange
		    m.lnLargeChange  = This.ctlVLargeChange
		    m.lnViewPortSize = This.Height
		Endif
		
		If m.lnLargeChange < 0 Then
		    m.lnLargeChange = m.lnViewPortSize
		Else
		    *!* LargeChange is a % of viewport
		    If m.lnLargeChange < 1
		        m.lnLargeChange = Int(m.lnViewPortSize * m.lnLargeChange)
		    Endif
		Endif
		
		Do Case
		
		    Case m.lnRequest = SB_ENDSCROLL		&& 8
		        Return && We dont need to do anything else
		
		    Case m.lnRequest = SB_THUMBPOSITION	&& 4
		        m.lnPosition = ctlHiWord(m.nWPARAM)
		
		    Case m.lnRequest = SB_THUMBTRACK	&& 5
		        m.lnPosition = ctlHiWord(m.nWPARAM)
		
		    Case m.lnRequest = SB_LINELEFT		&& 0 SB_LINEUP
		        m.lnPosition = m.lnPosition - m.lnSmallChange
		
		    Case m.lnRequest = SB_LINERIGHT		&& 1 SB_LINEDOWN
		        m.lnPosition = m.lnPosition + m.lnSmallChange
		
		    Case m.lnRequest = SB_PAGELEFT		&& 2 SB_PAGEUP
		        m.lnPosition = m.lnPosition - m.lnLargeChange
		
		    Case m.lnRequest = SB_PAGERIGHT		&& 3 SB_PAGEDOWN
		        m.lnPosition = m.lnPosition + m.lnLargeChange
		
		    Case m.lnRequest = SB_LEFT			&& 6 SB_TOP
		        m.lnPosition = 0
		
		    Case m.lnRequest = SB_RIGHT			&& 7 SB_BOTTOM
		        m.lnPosition = 65535
		Endcase
		
		This._ScrollInfo.fMask     = SIF_POS
		This._ScrollInfo.nMin      = 0
		This._ScrollInfo.nMax      = 0
		This._ScrollInfo.nPage     = 0
		This._ScrollInfo.nPos      = m.lnPosition
		This._ScrollInfo.nTrackPos = 0
		
		apiSetScrollInfo(m.lnHwnd, SB_CTL, This._ScrollInfo.Address, 1)
		
		m.lnPosition = apiGetScrollPos(m.lnHwnd, SB_CTL)
		
		If This.ControlCount > 0 Then
		    m.lnOldAnchor = This.Controls(1).Anchor
		    This.Controls(1).Anchor = 0
		    If m.lnMsg = WM_HSCROLL Then
		        This.Controls(1).Left = - m.lnPosition
		    Else
		        This.Controls(1).Top = - m.lnPosition
		    Endif
		    This.Controls(1).Anchor = m.lnOldAnchor
		Endif
		
		Raiseevent(This, "ctlScrolled", m.lnRequest + Iif(m.lnMsg = WM_HSCROLL, 10, 0))
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _scrolltocontrol
		If This.ctlAutoScroll = FALSE Then
		    Return
		Endif
		
		Local ;
		    loControl As Control, ;
		    lnMargin As Number, ;
		    loActiveControl As Control, ;
		    loOriginalActiveControl As Control, ;
		    lnHSValue As Number, ;
		    lnVSValue As Number, ;
		    llMoveX As Number, ;
		    llMoveY As Number
		
		*!* These two will tell us later if we need to scroll:
		m.llMoveX = FALSE
		m.llMoveY = FALSE
		
		If This.ControlCount > 0 And Type("This.Controls(1).ActiveControl") == T_OBJECT Then
		
		    m.loActiveControl = This.Controls(1).ActiveControl
		    m.loControl = This.Controls(1)
		
		    *!* Dont do anything if we are still in the same control we last autoscrolled to.
		    If This.cPrevControlFullName == Sys(1272, m.loActiveControl) Then
		        Return
		    Endif
		
		    m.lnHSValue = This.ctlHValue
		    m.lnVSValue = This.ctlVVAlue
		
		    This.cPrevControlFullName = Sys(1272, m.loActiveControl)
		    m.loOriginalActiveControl = m.loActiveControl
		    *!* This will navigate upwards the containership levels until we find
		    *!* the topmost control that is a child of the main client container control
		    Do While (Sys(1272, m.loActiveControl.Parent) == Sys(1272, This.Controls(1))) = FALSE
		        m.loActiveControl = m.loActiveControl.Parent
		    Enddo
		
		    m.lnMargin = This.ctlHMargin
		
		    *!* Is control left border beyond left border
		    If m.loControl.Left + m.loActiveControl.Left < 0 Then
		        m.lnHSValue  = 0
		        m.llMoveX = TRUE
		    Endif
		
		    *!* Is control left border beyond right border
		    If m.loControl.Left + m.loActiveControl.Left > This.Width Then
		        m.lnHSValue  = m.loActiveControl.Left + m.loActiveControl.Width - This.Width + m.lnMargin
		        m.llMoveX = TRUE
		    Endif
		
		    *!* Is control right border beyond right border
		    If m.loControl.Left + m.loActiveControl.Left + m.loActiveControl.Width > This.Width Then
		        m.lnHSValue  = m.loActiveControl.Left + m.loActiveControl.Width - This.Width + m.lnMargin
		        m.llMoveX = TRUE
		    Endif
		
		    *!* Is control left border beyond left border
		    If m.loControl.Left + m.loActiveControl.Left < 0 Then
		        m.lnHSValue  = m.loActiveControl.Left - m.lnMargin
		        m.llMoveX = TRUE
		    Endif
		
		    m.lnMargin = This.ctlVMargin
		
		    *!* Is control top border beyond top border
		    If  m.loControl.Top + m.loActiveControl.Top > This.Height Then
		        m.lnVSValue  = m.loActiveControl.Top + m.loActiveControl.Height - This.Height + m.lnMargin
		        m.llMoveY = TRUE
		    Endif
		
		    *!* Is control bottom border beyond bottom border
		    If  m.loControl.Top + m.loActiveControl.Top + m.loActiveControl.Height > This.Height Then
		        m.lnVSValue  = m.loActiveControl.Top + m.loActiveControl.Height - This.Height + m.lnMargin
		        m.llMoveY = TRUE
		    Endif
		
		    *!* Is control top border beyond top border
		    If  m.loControl.Top + m.loActiveControl.Top < 0 Then
		        m.lnVSValue  = m.loActiveControl.Top - m.lnMargin
		        m.llMoveY = TRUE
		    Endif
		
		    If This.ctlAutoCenter = FALSE Then
		        If m.loActiveControl.TabIndex = 1 And This.Controls(1).Name == m.loActiveControl.Parent.Name Then
		            m.lnHSValue  = 0
		            m.lnVSValue  = 0
		        Endif
		    Endif
		
		    *!* Only scroll horizontally if needed
		    If m.llMoveX = TRUE
		        This.ctlHValue = m.lnHSValue
		    Endif
		
		    *!* Only scroll vertically if needed
		    If m.llMoveY = TRUE Then
		        This.ctlVVAlue = m.lnVSValue
		    Endif
		
		    If m.llMoveX = TRUE Or m.llMoveY = TRUE Then
		
		        *!* From now on, experimental mode on
		        If Pemstatus(m.loOriginalActiveControl , "SelectOnEntry", CON_PEMSTAT_DEFINED) Then
		            If m.loOriginalActiveControl .SelectOnEntry = TRUE Then
		                m.loOriginalActiveControl.SelStart = 0
		                m.loOriginalActiveControl.SelLength = Len(Rtrim(Transform(m.loOriginalActiveControl.Value)))
		                *!* This refresh is here to refresh container when the scrolltocontrol was
		                *!* triggered by a mouse click, not by a TAB
		                m.loControl.Refresh()
		            Endif
		        Endif
		    Endif
		Endif
		
		
		
	ENDPROC

	HIDDEN PROCEDURE _settheme
		*!* Changed in version 3.1
		*!* Sunken border was not showing in WIN2K, WIN98.
		
		Local lnBorderStyle
		
		*!* Update Width and Height of standard ScrollBars
		This.nScrollHeight = Sysmetric(SYSMETRIC_HSCROLLBARHEIGHT)
		This.nScrollWidth = Sysmetric(SYSMETRIC_VSCROLLBARWIDTH)
		
		*!* Set Theme of scrollbars controls:
		If ctlIsThemeActive(This) Then
			apiSetWindowTheme(This.nHCtlHwnd, Null, Null)
			apiSetWindowTheme(This.nVCtlHwnd, Null, Null)
		Else
			apiSetWindowTheme(This.nHCtlHwnd, Null, "")
			apiSetWindowTheme(This.nVCtlHwnd, Null, "")
		Endif
		
		*!* Send a color change message just in case:
		apiSendMessageInteger(This.nHCtlHwnd, WM_SYSCOLORCHANGE , 0, 0)
		apiSendMessageInteger(This.nVCtlHwnd, WM_SYSCOLORCHANGE , 0, 0)
		
		*!* Save current borderstyle
		m.lnBorderStyle = This.ctlBorderStyle
		
		*!* We first set BorderStyle to 0 so control resizes to its full size
		This.ctlBorderStyle = 0
		
		*!* Now we set the container that acts as border to flat or sunken, depending on themes:
		If ctlIsThemeActive(This) Then
			This.oCntBorder.SpecialEffect = CON_EFFECT_FLAT
			This.nBorderWidth = 1
		Else
			This.oCntBorder.SpecialEffect = CON_EFFECT_SUNKEN
			This.nBorderWidth = 2
		Endif
		
		*!* Now we set it to it previous BorderStyle, so the control shrinks if needed to
		*!* leave space for border
		This.ctlBorderStyle = m.lnBorderStyle
		
		
		
	ENDPROC

	PROCEDURE _setzoomratios
		This.aZoomLevel(1)  =  0.01
		This.aZoomLevel(2)  =  0.02
		This.aZoomLevel(3)  =  0.03
		This.aZoomLevel(4)  =  0.04
		This.aZoomLevel(5)  =  0.05
		This.aZoomLevel(6)  =  0.06
		This.aZoomLevel(7)  =  0.08
		This.aZoomLevel(8)  =  0.10
		This.aZoomLevel(9)  =  0.12
		This.aZoomLevel(10) =  0.15
		This.aZoomLevel(11) =  0.20
		This.aZoomLevel(12) =  0.25
		This.aZoomLevel(13) =  0.30
		This.aZoomLevel(14) =  0.40
		This.aZoomLevel(15) =  0.50
		This.aZoomLevel(16) =  0.60
		This.aZoomLevel(17) =  0.70
		This.aZoomLevel(18) =  0.80
		This.aZoomLevel(19) =  1.00
		This.aZoomLevel(20) =  1.20
		This.aZoomLevel(21) =  1.50
		This.aZoomLevel(22) =  2.00
		This.aZoomLevel(23) =  2.50
		This.aZoomLevel(24) =  3.00
		This.aZoomLevel(25) =  4.00
		This.aZoomLevel(26) =  5.00
		This.aZoomLevel(27) =  6.00
		This.aZoomLevel(28) =  8.00
		This.aZoomLevel(29) = 10.00
		This.aZoomLevel(30) = 12.00
		This.aZoomLevel(31) = 15.00
		This.aZoomLevel(32) = 20.00
		This.aZoomLevel(33) = 25.00
		This.aZoomLevel(34) = 30.00
		This.aZoomLevel(35) = 31.99999999999
		
	ENDPROC

	HIDDEN PROCEDURE _wm_event
		*!* _wm_event
		
		Lparameters nHWND As Integer, nMSG As Integer, nWPARAM As Integer, nLPARAM As Integer
		
		Local lnResult As Number
		
		Thisform._scontainerHwnd = m.nHWND
		Thisform._scontainerWparam = m.nWPARAM
		Thisform._scontainerLparam = m.nLPARAM
		*!* Trigger method binded to this property:
		Thisform._scontainerWM  = m.nMSG
		
		m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.nHWND, m.nMSG, m.nWPARAM, m.nLPARAM)
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE lblname.Init
		return FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_scrollbar AS ctl32_controlbase OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_scrollbar.bmp" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlfixedthumbsize_assign
		*m: ctllargechange_assign
		*m: ctlmaximum_assign
		*m: ctlminimum_assign
		*m: _setlargechange
		*m: _setrange
		*m: _setthumbsize
		*p: ctlfixedthumbsize		&& Specifies if the thumb size is proportional or fixed.
		*p: ctllargechange		&& Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
		*p: ctlmaximum		&& Gets or sets the upper limit of values of the scrollable range.
		*p: ctlminimum		&& Gets or sets the lower limit of values of the scrollable range.
		*p: ctlsmallchange		&& Gets or sets the value to be added to or subtracted from the Value property when the scroll box is moved a small distance.
		*p: _thumbsize
	*</DefinedPropArrayMethod>

	ctlfixedthumbsize = .F.		&& Specifies if the thumb size is proportional or fixed.
	ctllargechange = 10		&& Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
	ctlmaximum = 100		&& Gets or sets the upper limit of values of the scrollable range.
	ctlminimum = 0		&& Gets or sets the lower limit of values of the scrollable range.
	ctlsmallchange = 1		&& Gets or sets the value to be added to or subtracted from the Value property when the scroll box is moved a small distance.
	Height = 18
	Name = "ctl32_scrollbar"
	Width = 240
	_thumbsize = 1
	ctlTextBox.Name = "ctlTextBox"
	lblname.Caption = "ctl32_scrollbar"
	lblname.Name = "lblname"
	
	PROCEDURE ctldefaultheight_access
		*!* ctlDefaultHeight_Access()
		
		Local ;
			lnHeight As Integer
		
		If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
			m.lnHeight = SYSMETRIC(8)
		Else
			m.lnHeight = This.Height
		Endif
		
		Return m.lnHeight
		
	ENDPROC

	PROCEDURE ctldefaultwidth_access
		*!* ctlDefaultWidth_Access()
		
		Local ;
			lnWidth As Integer
		
		If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
			m.lnWidth = This.Width
		Else
			m.lnWidth = Sysmetric(5)
		Endif
		
		Return m.lnWidth
		
	ENDPROC

	PROCEDURE ctlfixedthumbsize_assign
		lparameters tuNewValue
		
		If This.ctlFixedThumbSize # m.tuNewValue Then
			This.ctlFixedThumbSize = m.tuNewValue
			This._SetThumbSize()
		Endif
		
	ENDPROC

	PROCEDURE ctllargechange_assign
		lparameters tuNewValue
		
		If This.ctlLargeChange # m.tuNewValue Then
			This.ctlLargeChange = m.tuNewValue
			This._SetLargeChange()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlmaximum_assign
		*!* ctlMaximum_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlMaximum # m.tuNewValue Then
			This.ctlMaximum = m.tuNewValue
			This._SetRange()
		Endif
		
	ENDPROC

	PROCEDURE ctlminimum_assign
		*!* ctlMinimum_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlMinimum # m.tuNewValue Then
			This.ctlMinimum = m.tuNewValue
			This._SetRange()
		Endif
		
	ENDPROC

	PROCEDURE _addobjects
		*!* _AddObjects()
		
		DODEFAULT()
		
		*!* Define ScrollInfo Object to be used by various methods
		This.AddProperty("_ScrollInfo", Createobject("_SCROLLINFO"))
		
	ENDPROC

	PROCEDURE _bindevents
		*!* _BindEvents()
		
		DoDefault()
		
		Bindevent(This.ctlHostFormhWnd, WM_HSCROLL, Thisform.BindWindowsEventsProxy, "_MsgHandler", 4)
		Bindevent(This.ctlHostFormhWnd, WM_VSCROLL, Thisform.BindWindowsEventsProxy, "_MsgHandler", 4)
		
	ENDPROC

	PROCEDURE _formmessagehandler
		*!* _FormMessageHandler()
		
		DoDefault()
		
		Local ;
			m.lnValue As Integer, ;
			m.lnRequest As Integer
		
		Do Case
		
			Case Thisform.BindWindowsEventsProxy._Msg = WM_HSCROLL Or Thisform.BindWindowsEventsProxy._Msg = WM_VSCROLL
		
				If Thisform.BindWindowsEventsProxy._lParam = This._ControlHwnd Then
		
					m.lnValue = apiGetScrollPos(This._ControlHwnd, SB_CTL)
					m.lnRequest  = ctlLoWord(Thisform.BindWindowsEventsProxy._wParam)
		
					Do Case
		
						Case m.lnRequest = SB_ENDSCROLL		&& 8
							Return && We dont need to do anything else
		
						Case m.lnRequest = SB_THUMBPOSITION	&& 4
							m.lnValue = ctlHiWord(Thisform.BindWindowsEventsProxy._wParam)
		
						Case m.lnRequest = SB_THUMBTRACK	&& 5
							m.lnValue = ctlHiWord(Thisform.BindWindowsEventsProxy._wParam)
		
						Case m.lnRequest = SB_LINELEFT		&& 0 SB_LINEUP
							m.lnValue = m.lnValue - This.ctlSmallChange
		
						Case m.lnRequest = SB_LINERIGHT		&& 1 SB_LINEDOWN
							m.lnValue = m.lnValue + This.ctlSmallChange
		
						Case m.lnRequest = SB_PAGELEFT		&& 2 SB_PAGEUP
							m.lnValue = m.lnValue - This.ctlLargeChange
		
						Case m.lnRequest = SB_PAGERIGHT		&& 3 SB_PAGEDOWN
							m.lnValue = m.lnValue + This.ctlLargeChange
		
						Case m.lnRequest = SB_LEFT			&& 6 SB_TOP
							m.lnValue = This.ctlMinimum
		
						Case m.lnRequest = SB_RIGHT			&& 7 SB_BOTTOM
							m.lnValue = This.ctlMaximum
					Endcase
		
					*!* We set new value here:
		
					This._ScrollInfo.fMask     = SIF_POS
					This._ScrollInfo.nMin      = 0
					This._ScrollInfo.nMax      = 0
					This._ScrollInfo.nPage     = 0
					This._ScrollInfo.nPos      = m.lnValue
					This._ScrollInfo.nTrackPos = 0
		
					apiSetScrollInfo(This._ControlHwnd, SB_CTL, This._ScrollInfo.Address, 1)
		
					*!* Now get resulting value from control:
					m.lnValue = apiGetScrollPos(This._ControlHwnd, SB_CTL)
		
					*!* Update ctlValue value
					This._EnableUpdates = FALSE
					This.ctlValue = m.lnValue
					This._EnableUpdates = TRUE
				Endif
		
		Endcase
		
	ENDPROC

	PROCEDURE _getdwstyle
		*!* _GetdwStyle()
		
		Local dwStyle As Integer
		
		m.dwStyle = Bitor(WS_CHILD, WS_CLIPSIBLINGS)
		
		*!* Orientation
		If This.ctlOrientation = 0  Then
			m.dwStyle = Bitor(m.dwStyle, SBS_HORZ)
		Else
			m.dwStyle = Bitor(m.dwStyle, SBS_VERT)
		Endif
		
		Return m.dwStyle
		
	ENDPROC

	PROCEDURE _getlpclassname
		*!* _GetlpClassName()
		
		Return WC_SCROLLBARA
		
	ENDPROC

	PROCEDURE _postcreate
		This._SetRange()
		This._SetLargeChange()
		This._SetAutoSize()
		This._OnResize()
		
	ENDPROC

	PROCEDURE _setautosize
		*!* _SetAutosize()
		
		Local lnAnchor As Integer
		
		m.lnAnchor = This.Anchor
		
		This.Anchor = 0
		
		If This.ctlAutoSize = TRUE Then
		
			*!* Save previous dimensions
			This._DefaultHeight = This.Height
			This._DefaultWidth = This.Width
		
			If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
				This.Width = This.ctlDefaultWidth
			Else
				This.Height = This.ctlDefaultHeight
			Endif
		
		Else
		
			If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
				This.Width = This._DefaultWidth
			Else
				This.Height = This._DefaultHeight
			Endif
		
		Endif
		
		This.Anchor = m.lnAnchor
		
	ENDPROC

	PROCEDURE _setbackcolor
		*!* _SetBackColor()
		
		This._CreateBackGroundBrush()
		This.ctlRefresh()
		
	ENDPROC

	PROCEDURE _setlargechange
		*!* _SetLargeChange()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		Local lnPage As Integer
		
		If This.ctlFixedThumbSize = TRUE Then
			m.lnPage = This._ThumbSize
		Else
			m.lnPage = This.ctlLargeChange
		Endif
		
		
		This._ScrollInfo.fMask     = SIF_PAGE
		This._ScrollInfo.nMin      = 0
		This._ScrollInfo.nMax      = 0
		This._ScrollInfo.nPage     = m.lnPage
		This._ScrollInfo.nPos      = 0
		This._ScrollInfo.nTrackPos = 0
		
		
		apiSetScrollInfo(This._ControlHwnd, SB_CTL, This._ScrollInfo.Address, 1)
		
	ENDPROC

	PROCEDURE _setorientation
		*!* _SetOrientation()
		
		Local ;
			lnAnchor As Integer, ;
			lnWidth As Integer, ;
			llVisible As Boolean
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		m.lnAnchor = This.Anchor
		m.lnWidth = This.Width
		m.llVisible = This.ctlVisible
		
		This.ctlVisible = FALSE
		This.Anchor = 0
		
		This.Width = This.Height
		This.Height = m.lnWidth
		
		*!* ctlVertical change needs to recreate Control
		This._Create()
		
		This.Anchor = m.lnAnchor
		This.ctlVisible = m.llVisible
		
	ENDPROC

	PROCEDURE _setrange
		*!* _SetRange()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		This._ScrollInfo.fMask     = SIF_RANGE
		This._ScrollInfo.nMin      = This.ctlMinimum
		This._ScrollInfo.nMax      = This.ctlMaximum
		This._ScrollInfo.nPage     = 0
		This._ScrollInfo.nPos      = 0
		This._ScrollInfo.nTrackPos = 0
		
		apiSetScrollInfo(This._ControlHwnd, SB_CTL, This._ScrollInfo.Address, 1)
		
	ENDPROC

	PROCEDURE _setthumbsize
		*!* _SetThumbSize()
		
		This._SetLargeChange()
	ENDPROC

	PROCEDURE _setvalue
		*!* _SetValue()
		
		DoDefault()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		If This._EnableUpdates = FALSE
			Return
		Endif
		
		This._ScrollInfo.fMask     = SIF_POS
		This._ScrollInfo.nMin      = 0
		This._ScrollInfo.nMax      = 0
		This._ScrollInfo.nPage     = 0
		This._ScrollInfo.nPos      = This.ctlValue
		This._ScrollInfo.nTrackPos = 0
		
		apiSetScrollInfo(This._ControlHwnd, SB_CTL, This._ScrollInfo.Address, 1)
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_settings AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlgetvalue
		*m: ctlsetvalue
		*m: _createfile
		*m: _formatxml
		*p: _computername
		*p: _filename
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _username
	*</DefinedPropArrayMethod>

	Height = 86
	Name = "ctl32_settings"
	Width = 200
	_computername = 
	_filename = 
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	_username = 
	
	PROCEDURE ctlgetvalue
		Lparameters tcSettingName As String, tvDefaultValue As Variant
		
		If Pcount() < 2 Then
			Return .Null.
		Endif
		
		If Empty(Sys(2000, This._FileName)) Then
			*!* If there is no settings file, create it
			This._CreateFile()
		Endif
		
		Local ;
			lcSettingName As String, ;
			lvValue As Variant, ;
			loXml As MSXML2.DOMDocument, ;
			loElement As MSXML2.IXMLDOMElement
		
		m.lcSettingName = Lower(Chrtran(m.tcSettingName, "\", "/"))
		m.lcSettingName = Strtran(m.lcSettingName, "%computername%", This._ComputerName)
		m.lcSettingName = Strtran(m.lcSettingName, "%username%", This._UserName)
		
		m.loXml = Createobject("MsXml2.DomDocument")
		m.loXml.Async = .F.
		
		m.loXml.Load(This._FileName)
		
		m.loElement = m.loXml.documentElement.SelectSingleNode(m.lcSettingName)
		
		If Vartype(m.loElement) = T_OBJECT Then
			m.lvValue = m.loElement.Text
		
			*!* Convert return value based on tvDefaultValue
			Do Case
		
				Case Vartype(m.tvDefaultValue) = T_CHARACTER
					*!* Value is already of type character
		
				Case Vartype(m.tvDefaultValue) = T_CURRENCY
					m.lvValue= Cast(m.lvValue As Currency)
		
				Case Vartype(m.tvDefaultValue) = T_DATE
					m.lvValue = Date(Val(Left(m.lvValue,4)), Val(Substr(m.lvValue,5,2)), Val(Right(m.lvValue,2)))
		
				Case Vartype(m.tvDefaultValue) = T_DATETIME
					m.lvValue = Ctot(m.lvValue)
		
				Case Vartype(m.tvDefaultValue) = T_LOGICAL
					m.lvValue = Iif(m.lvValue = "1", TRUE, FALSE)
		
				Case Vartype(m.tvDefaultValue) = T_NUMERIC
					m.lvValue = Evaluate(m.lvValue)
		
				Case Vartype(m.tvDefaultValue) = T_VARBINARY
					m.lvValue = Cast(Strconv(m.lvValue,16) As Varbinary (Len(m.lvValue)))
		
				Otherwise
					*!* No formating of value
			Endcase
		
		Else
			This.ctlSetValue(m.tcSettingName, m.tvDefaultValue)
			m.lvValue = m.tvDefaultValue
		Endif
		
		m.loElement = .Null.
		m.loXml = .Null.
		
		Return m.lvValue
		
		
		
		
	ENDPROC

	PROCEDURE ctlsetvalue
		Lparameter tcSettingName, tvValue
		
		If Empty(Sys(2000, This._FileName)) Then
			*!* If there is no settings file, create it
			This._CreateFile()
		Endif
		
		Local ;
			lcSettingName As String, ;
			loXml As MsXml2.DomDocument, ;
			loRoot As MsXml2.IXMLDOMElement, ;
			loElement As MsXml2.IXMLDOMElement
		
		Do Case
		
			Case Vartype(m.tvValue) = T_CHARACTER
				m.lcValue = m.tvValue
		
			Case Vartype(m.tvValue) = T_DATE
				m.lcValue = Dtos(m.tvValue)
		
			Case Vartype(m.tvValue) = T_LOGICAL
				m.lcValue = Iif(m.tvValue, "1", "0")
		
			Case Vartype(m.tvValue) = T_NUMERIC
				m.lcValue = Strtran(Transform(m.tvValue), Set("Point"), '.')
		
			Case Vartype(m.tvValue) = T_VARBINARY
				m.lcValue = Transform(m.tvValue)
		
			Case Vartype(m.tvValue) = T_DATETIME
				m.lcValue = Ttoc(m.tvValue, 3)
		
			Case Vartype(m.tvValue) = T_CURRENCY
				m.lcValue = Strtran(Transform(m.tvValue), Set("Point"), '.')
		
			Otherwise
				m.lcValue = Transform(m.tvValue)
		
		Endcase
		
		m.lcSettingName = Lower(Chrtran(m.tcSettingName, "\", "/"))
		m.lcSettingName = Strtran(m.lcSettingName, "%computername%", This._ComputerName)
		m.lcSettingName = Strtran(m.lcSettingName, "%username%", This._UserName)
		
		m.loXml = Createobject("MsXml2.DomDocument")
		m.loXml.Async = .F.
		m.loXml.Load(This._FileName)
		
		*!* Search for element:
		m.loElement = m.loXml.DocumentElement.SelectSingleNode(m.lcSettingName)
		
		If Vartype(m.loElement) = T_OBJECT Then
			*!* Element was found, set text property:
			m.loElement.Text = m.lcValue
		Else
			If "/" $ m.lcSettingName Then
				*!* We have a path
				m.lcPath = "/"
				For m.lnx = 1 To Getwordcount(m.lcSettingName, "/")
					m.loNode = m.loXml.DocumentElement.SelectSingleNode(m.lcPath + "/" + Getwordnum(m.lcSettingName, m.lnx, "/"))
					If Vartype(m.loNode) # T_OBJECT Then
						If m.lcPath == "/" Then
							*!* First node, get root node
							m.loNode = m.loXml.DocumentElement
						Else
							*!* Get parent node
							m.loNode = m.loXml.DocumentElement.SelectSingleNode(m.lcPath)
						Endif
						*!* Append node
						m.loNode.appendChild(m.loXml.createNode(NODE_ELEMENT, Getwordnum(m.lcSettingName, m.lnx, "/"),""))
					Endif
					*!* Add next node to path
					m.lcPath = m.lcPath + "/" + Getwordnum(m.lcSettingName, m.lnx, "/")
				Endfor
				*!* By now we are at the element level, set value
				m.loElement = m.loXml.DocumentElement.SelectSingleNode(m.lcSettingName)
				m.loElement.Text = m.lcValue
			Else
				*!* No path, add element to root
				m.loRoot = m.loXml.DocumentElement
				m.loRoot.appendChild(m.loXml.CreateElement(m.lcSettingName))
				m.loRoot.LastChild.Text = m.lcValue
			Endif
		Endif
		
		m.loXml.LoadXML(This._FormatXml(m.loXml.XML))
		m.loXml.Save(This._FileName)
		
		m.loElement = .Null.
		m.loRoot = .Null.
		m.loXml = .Null.
		Return
		
		
		
	ENDPROC

	PROCEDURE Init
		If Version(2) # 0 And Type("Application.ActiveProject") = "O" Then
			This._FileName = Forceext(Application.ActiveProject.Name, "exe") + ".settings"
		Else
			This._FileName = Application.ServerName + ".settings"
		Endif
		
		This._ComputerName = Lower(Alltrim(Getwordnum(Sys(0), 1, "#")))
		This._Username = Lower(Alltrim(Getwordnum(Sys(0), 2, "#")))
		
		If Empty(Sys(2000, This._FileName)) Then
			*!* If there is no settings file, create it
			This._CreateFile()
		Endif
		
	ENDPROC

	PROCEDURE _createfile
		*!* _CreateFile()
		
		Local ;
			loXml As MSXML2.DOMDocument, ;
			loRoot, ;
			loChild
		
		m.loXml = Createobject("MsXml2.DomDocument")
		m.loXml.Async = .F.
		
		*m.loXml.LoadXml('<?xml version="1.0" encoding="UTF-8"?><settings></settings>')
		
		*!* Add XML Header
		m.loXml.appendChild(m.loXml.createNode(NODE_PROCESSING_INSTRUCTION,"xml",""))
		
		*!* add root
		m.loRoot = m.loXml.appendChild(m.loXML.createNode(NODE_ELEMENT,"settings",""))
		
		*!*	*!* Add subkey
		*!*	m.loChild = m.loRoot.appendChild(m.loXML.createNode(NODE_ELEMENT,"node1",""))
		
		*!*	*!* Add value
		*!*	m.loChild.appendChild(m.loXML.createElement("field1"))
		*!*	m.loChild.lastChild.Text = "data1"
		*!*	m.loChild.appendChild(m.loXML.createElement("field2"))
		*!*	m.loChild.lastChild.Text = "data2"
		*!*	m.loChild.appendChild(m.loXML.createElement("field3"))
		*!*	m.loChild.lastChild.Text = "data3"
		
		*!*	m.loChild = m.loChild.appendChild(m.loXML.createNode(NODE_ELEMENT,"subnode1",""))
		
		*!*	m.loChild.appendChild(m.loXML.createElement("field1"))
		*!*	m.loChild.lastChild.Text = "data1"
		*!*	m.loChild.appendChild(m.loXML.createElement("field2"))
		*!*	m.loChild.lastChild.Text = "data2"
		*!*	m.loChild.appendChild(m.loXML.createElement("field3"))
		*!*	m.loChild.lastChild.Text = "data3"
		
		*!*	*!* Add subkey
		*!*	m.loChild = m.loRoot.appendChild(m.loXML.createNode(NODE_ELEMENT,"node2",""))
		
		*!*	*!* Add value
		*!*	m.loChild.appendChild(m.loXML.createElement("field1"))
		*!*	m.loChild.lastChild.Text = "data1"
		*!*	m.loChild.appendChild(m.loXML.createElement("field2"))
		*!*	m.loChild.lastChild.Text = "data2"
		*!*	m.loChild.appendChild(m.loXML.createElement("field3"))
		*!*	m.loChild.lastChild.Text = "data3"
		
		*!*	m.loChild = m.loChild.appendChild(m.loXML.createNode(NODE_ELEMENT,"subnode2",""))
		
		*!*	m.loChild.appendChild(m.loXML.createElement("field1"))
		*!*	m.loChild.lastChild.Text = "data1"
		*!*	m.loChild.appendChild(m.loXML.createElement("field2"))
		*!*	m.loChild.lastChild.Text = "data2"
		*!*	m.loChild.appendChild(m.loXML.createElement("field3"))
		*!*	m.loChild.lastChild.Text = "data3"
		
		m.loXml.LoadXml(This._FormatXml(m.loXml.xml))
		m.loXml.Save(This._FileName)
		
		m.loXml = .Null.
		m.loRoot = .Null.
		m.loChild = .Null.
		
	ENDPROC

	PROCEDURE _formatxml
		*!* _FormatXml(cXml)
		*!* Adds linefeeds/carriage returns to an xml string
		Lparameters tcXml As String
		
		Local ;
			lcXsl As String, ;
			loXml As MsXml2.DomDocument, ;
			loXsl As MsXml2.DomDocument
		
		TEXT To m.lcXsl NoShow
			<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
				<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
				<xsl:template match="@* | node()">
					<xsl:copy>
						<xsl:copy-of select="@*"/>
						<xsl:apply-templates select="node()">
							<xsl:sort select="name()"/>
						</xsl:apply-templates>
					</xsl:copy>
				</xsl:template>
		</xsl:stylesheet>
		ENDTEXT
		
		*!*	TEXT To m.lcXsl NoShow
		*!*		<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
		*!*			<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
		*!*			<xsl:template match="node() | @*">
		*!*				<xsl:copy>
		*!*					<xsl:apply-templates select="node() | @*"/>
		*!*				</xsl:copy>
		*!*			</xsl:template>
		*!*		</xsl:stylesheet>
		*!*	ENDTEXT
		
		m.loXml = Createobject("MsXml2.DomDocument")
		m.loXml.LoadXML(m.tcXml)
		
		m.loXsl = Createobject("MsXml2.DomDocument")
		m.loXsl.LoadXML(m.lcXsl)
		
		m.lcXml = m.loXml.TransformNode(m.loXsl)
		
		m.loXml = .Null.
		m.loXsl = .Null.
		
		*!* Replace encoding added by TransformNode
		m.lcXml = Strtran(m.lcXml, 'UTF-16', 'UTF-8')
		
		Return m.lcXml
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_sizebox AS ctl32_controlbase OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "ctl32.h"
	Height = 24
	Name = "ctl32_sizebox"
	Width = 78
	_visible = .F.
	ctlTextBox.Name = "ctlTextBox"
	lblname.Caption = "ctl32_sizebox"
	lblname.Name = "lblname"
	
	PROCEDURE _bindevents
		DoDefault()
		
		Bindevent(Thisform, "BorderStyle", This, "_OnFormBorderStyle", 1)
		Bindevent(Thisform, "Resize", This, "_OnFormResize", 1)
		
	ENDPROC

	PROCEDURE _getdwstyle
		Return Bitor(WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS, SBS_SIZEGRIP, SBS_SIZEBOXBOTTOMRIGHTALIGN)
	ENDPROC

	PROCEDURE _getlpclassname
		Return WC_SCROLLBARA
		
	ENDPROC

	PROCEDURE _onformborderstyle
		Local llVisible As Boolean
		
		m.llVisible = TRUE
		
		If Thisform.BorderStyle # BORDER_SYSTEM
			m.llVisible = FALSE
		Endif
		
		If Thisform.WindowState = WINDOWSTATE_MAXIMIZED
			m.llVisible = FALSE
		Endif
		
		This.ctlVisible = m.llVisible
		
		
	ENDPROC

	PROCEDURE _onformresize
		Local llVisible As Boolean
		
		m.llVisible = TRUE
		
		If Thisform.BorderStyle # BORDER_SYSTEM
			m.llVisible = FALSE
		Endif
		
		If Thisform.WindowState = WINDOWSTATE_MAXIMIZED
			m.llVisible = FALSE
		Endif
		
		This.ctlVisible = m.llVisible
	ENDPROC

	PROCEDURE _precreate
		*!* _PreCreate()
		
		This._SetAutoSize()
		
		
	ENDPROC

	PROCEDURE _setautosize
		*!* _SetAutosize()
		
		This.Anchor = 0
		
		This.Width = Sysmetric(SYSMETRIC_VSCROLLBARWIDTH)
		This.Height = Sysmetric(SYSMETRIC_HSCROLLBARHEIGHT)
		
		If ctlIsThemeActive(This) = FALSE AND ctlIsThemeActive(ThisForm) = TRUE Then
			This.Top = This.Parent.Height - This.Height - 1
			This.Left = This.Parent.Width - This.Width - 1
		Else
			This.Top = This.Parent.Height - This.Height
			This.Left = This.Parent.Width - This.Width
		Endif
		
		This.Anchor = 12
		
	ENDPROC

	PROCEDURE _setthemes
		DoDefault()
		
		This._SetAutoSize()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_statusbar AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="backup\ctl32_statusbar.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrHideVFPStatusBar" UniqueID="" Timestamp="" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlcaption_access
		*m: ctlcaption_assign
		*m: ctlclick
		*m: ctldblclick
		*m: ctlgetstringsize
		*m: ctlhwnd_access
		*m: ctlicon_assign
		*m: ctlinit
		*m: ctllangid_assign
		*m: ctlmessage_access
		*m: ctlmessage_assign
		*m: ctlresizepanels
		*m: ctlrightclick
		*m: ctlthemes_assign
		*m: ctlupdatepanels
		*m: ctlupdatestyle_assign
		*m: hwnd_access
		*m: showprogressbarcaption_assign
		*m: _addobjects
		*m: _addpanels		&& Adds Panels objects to StatusBar container
		*m: _addprogressbar
		*m: _addproperties
		*m: _adjustprogressbar
		*m: _bindevents		&& Binds events.
		*m: _create
		*m: _declaredlls		&& DLL declarations.
		*m: _destroy
		*m: _eventhandlerformactivate		&& Binded to Form.Activate, for top level forms, it creates statusbar after form is visible
		*m: _eventhandlerformdestroybefore
		*m: _eventhandlerformresize
		*m: _getborder		&& Returns the width of the especified border:  1 = Horizontal,  2 = Vertical, 3 = Separator
		*m: _messagehandlerproxywindowwm_notify		&& Handles mouse clicks in statusbar window
		*m: _messagehandlerscreenwm_size
		*m: _messagehandlervfpwm_enteridle
		*m: _messagehandlervfpwm_themechanged
		*m: _messagehandlervfpwm_uninitmenupopup
		*m: _propertyhandlerformthemes
		*m: _propertyhandlerformvisible
		*m: _propertyhandlerprogressbarctlvisible
		*m: _propertyhandlerprogressbarwidth
		*m: _propertyhandlerscreenthemes
		*m: _resize		&& Bound to Form.Resize
		*m: _resizepanels		&& Recalculates panel widths based on content
		*m: _setlocalestrings		&& Sets Locale strings for PanelCaps, PanelOvr, PanelNum
		*m: _setthemes
		*m: _vfpmessagehandler
		*m: _width_access
		*p: builderx
		*p: ctlabout
		*p: ctlcaption
		*p: ctlhwnd		&& Specifies the Window handle of the Control.
		*p: ctlicon		&& Use PanelMessage.Icon instead
		*p: ctllangid
		*p: ctlmessage		&& Use PanelMessage.Caption instead
		*p: ctlpanelcount		&& Indicates how many custom panels are available.
		*p: ctlsizegrip
		*p: ctlthemes
		*p: ctlupdatestyle
		*p: ctlversion
		*p: hwnd		&& Specifies the Window handle of the Window.
		*p: nbutton
		*p: npanel
		*p: nxcoord
		*p: nycoord
		*p: showprogressbarcaption
		*a: ctlpanels[1,0]
		*a: _panels[1,0]
		*p: _borderseparatorwidth
		*p: _height
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _width
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	BorderWidth = 1
	builderx = (home() + "wizards\ctl32_statusbar_builder.app")
	ctlabout = ctl32_statusbar - Carlos Alloatti.
	ctlcaption = 
	ctlhwnd = 0		&& Specifies the Window handle of the Control.
	ctlicon = 		&& Use PanelMessage.Icon instead
	ctllangid = 0
	ctlmessage = 		&& Use PanelMessage.Caption instead
	ctlpanelcount = 5		&& Indicates how many custom panels are available.
	ctlsizegrip = .T.
	ctlthemes = .T.
	ctlupdatestyle = 1
	ctlversion = 20070711
	ForeColor = 0,0,0
	Height = 24
	hwnd = 		&& Specifies the Window handle of the Window.
	Name = "ctl32_statusbar"
	nbutton = 0
	npanel = 0
	nxcoord = 0
	nycoord = 0
	showprogressbarcaption = .F.
	Width = 360
	_borderseparatorwidth = 0
	_height = 24
	_width = 0

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "ctl32_StatusBar", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 4
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'tmrHideVFPStatusBar' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 1000, ;
		Left = -30, ;
		Name = "tmrHideVFPStatusBar", ;
		Top = 12, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE ctlcaption_access
		Return This.PanelMessage.ctlCaption
		
	ENDPROC

	PROCEDURE ctlcaption_assign
		Lparameters vNewVal
		If Type("This.PanelMessage") # T_UNDEFINED
			This.PanelMessage.ctlCaption = m.vNewVal
		Endif
		
		
	ENDPROC

	PROCEDURE ctlclick
	ENDPROC

	PROCEDURE ctldblclick
	ENDPROC

	PROCEDURE ctlgetstringsize
		*!* ctlGetStringSize
		
		*!* This method has been left here for backward compatiblity,
		*!* use ctlGetStringSizeFromHwnd in ctl32.prg instead
		
		*!* 2006-06-27 Now it uses StrToInt of _rect class
		*!* ctlGetStringSize
		*!* msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/fontext_8smq.asp
		*!* www.news2news.com/vfp/?function=687
		*!* vbnet.mvps.org/index.html?code/listapi/listrightalign.htm
		
		*!*	typedef struct tagSIZE {
		*!*	  LONG cx;
		*!*	  LONG cy;
		*!*	} SIZE, *PSIZE;
		
		*!* Returns Width or Height of a string with font = font of the StatusBar
		*!* tcReturnWidthOrHeight can be 'W' or 'H' or no parameter, defaults to 'W'
		Lparameters tcString As String, tcReturnWidthOrHeight As String
		
		If Pcount() = 1 Then
			m.tcReturnWidthOrHeight = "W"
		Endif
		
		Local ;
			lnSize As Number, ;
			lcSize As String, ;
			lnhFont As Number, ;
			lnhFontOld As Number, ;
			lnHdc
		
		m.lcSize = Space(8)
		
		
		m.lnHdc = apiGetDC(This.ctlHWnd)
		
		m.lnhFont = apiSendMessageInteger(This.ctlHWnd, WM_GETFONT, 0, 0)
		m.lnhFontOld = apiSelectObject(m.lnHdc, m.lnhFont)
		
		apiGetTextExtentPoint32(m.lnHdc, m.tcString, Len(m.tcString), @ m.lcSize)
		
		If m.tcReturnWidthOrHeight <> "W" Then
			m.lnSize = CToBin(Substr(m.lcSize, 5, 4), "4RS")
		Else
			m.lnSize = CToBin(Substr(m.lcSize, 1, 4), "4RS")
		Endif
		
		apiSelectObject(m.lnHdc, m.lnhFontOld)
		
		apiReleaseDC(This.ctlHWnd, m.lnHdc)
		
		Return m.lnSize
		
		
		
	ENDPROC

	PROCEDURE ctlhwnd_access
		Return This._ControlHwnd
		
	ENDPROC

	PROCEDURE ctlicon_assign
		*!* 2006-06-27 Added check for parameter type
		Lparameters vNewVal
		
		If Type("m.vNewVal") <> T_CHARACTER Then
		    m.vNewVal = ""
		Endif
		
		This.ctlIcon = m.vNewVal
		This.PanelMessage.ctlIcon = m.vNewVal
		
		
	ENDPROC

	PROCEDURE ctlinit
	ENDPROC

	PROCEDURE ctllangid_assign
		Lparameters vNewVal
		This.ctlLangid = m.vNewVal
		This._SetLocaleStrings()
		
	ENDPROC

	PROCEDURE ctlmessage_access
		Return This.PanelMessage.ctlCaption
		
	ENDPROC

	PROCEDURE ctlmessage_assign
		Lparameters vNewVal
		If Type("This.PanelMessage") # T_UNDEFINED
			This.PanelMessage.ctlCaption = m.vNewVal
		Endif
		
	ENDPROC

	PROCEDURE ctlresizepanels
		This._ResizePanels()
	ENDPROC

	PROCEDURE ctlrightclick
	ENDPROC

	PROCEDURE ctlthemes_assign
		Lparameters vNewVal
		
		If Type("m.vNewVal") = T_NUMERIC Then
			If m.vNewVal = 0 Then
				m.vNewVal = FALSE
			Else
				m.vNewVal = TRUE
			Endif
		Endif
		
		If Type("m.vNewVal") <> T_LOGICAL
			Return
		Endif
		
		This.ctlThemes = m.vNewVal
		
		This._SetThemes()
		
		
	ENDPROC

	PROCEDURE ctlupdatepanels
		Local lcMessage, lcPadLeft, lcPadRight
		
		*!* If mouse button is down, just return. 
		*!* This does not work, opening a menu returns .T. for Mdown
		*!*	If Mdown() Then
		*!*	    Return
		*!*	Endif
		
		Do Case
		    Case This.PanelMessage.ctlAlignment = 1	&& Right
		        m.lcPadLeft  = TABCHAR + TABCHAR + Space(1)
		        m.lcPadRight = Space(1)
		
		    Case This.PanelMessage.ctlAlignment = 2	&& Center
		        m.lcPadLeft  = TABCHAR 
		        m.lcPadRight = Space(0)
		
		    Otherwise							&& Left
		        m.lcPadLeft  = Space(1)
		        m.lcPadRight = Space(0)
		Endcase
		
		If This.ShowProgressBarCaption = TRUE And This.ProgressBar.ctlVisible = TRUE Then
		    m.lcMessage = m.lcPadLeft + This.ProgressBar.ctlCaption + m.lcPadRight
		    apiSendMessageString(This.ctlHWnd,SB_SETTEXTA, This.PanelMessage.ctlIndex, m.lcMessage)
		Else
		    *!* 2006-06-27 //Anton
		    If Not(This._oldMessage == _vfp.StatusBar) And Empty(This.PanelMessage.ctlCaption) Then
		
		        This._oldMessage = _vfp.StatusBar
		        m.lcMessage = m.lcPadLeft + _vfp.StatusBar + m.lcPadRight
		
		        apiSendMessageString(This.ctlHWnd,SB_SETTEXTA, This.PanelMessage.ctlIndex, m.lcMessage)
		    Endif
		Endif
		
		If  Insmode() <> This._OldOVR Then
		    If Insmode() Then
		        apiSendMessageString(This.ctlHWnd, SB_SETTEXTA, This.PanelOvr.ctlIndex, Space(20))
		    Else
		        apiSendMessageString(This.ctlHWnd, SB_SETTEXTA, This.PanelOvr.ctlIndex, This.PanelOvr.ctlCaption + Space(5))
		    Endif
		    This._OldOVR =  Insmode()
		Endif
		
		If Numlock() <> This._OldNUM Then
		    If Numlock() Then
		        apiSendMessageString(This.ctlHWnd,SB_SETTEXTA, This.PanelNum.ctlIndex, This.PanelNum.ctlCaption + Space(5))
		    Else
		        apiSendMessageString(This.ctlHWnd,SB_SETTEXTA, This.PanelNum.ctlIndex, Space(20))
		    Endif
		    This._OldNUM = Numlock()
		Endif
		
		If Capslock() <> This._OldCAPS Then
		    If Capslock() Then
		        apiSendMessageString(This.ctlHWnd,SB_SETTEXTA, This.PanelCaps.ctlIndex, This.PanelCaps.ctlCaption + Space(5))
		        *apiSendMessageString(This.ctlHWnd,SB_SETTEXTA, Bitor(This.PanelCaps.ctlIndex, SBT_OWNERDRAW), Space(4))
		    Else
		        apiSendMessageString(This.ctlHWnd,SB_SETTEXTA, This.PanelCaps.ctlIndex, Space(20))
		    Endif
		    This._OldCAPS = Capslock()
		Endif
		
		If This._OldDate <> Dtos(Date()) And This.PanelDate.ctlFormat <> 0 Then
		    This._OldDate = Dtos(Date())
		    This.PanelDate.ctlCaption = ctlGetDateFormat(This.PanelDate.ctlFormat)
		    This.PanelDate.ctlToolTipText = ctlGetDateFormat(2)
		Endif
		
		
	ENDPROC

	PROCEDURE ctlupdatestyle_assign
		*!* ctlUpdateStyle_Assign
		
		*!* 20070902 added Bindevent to Thisform.hWnd WM_ENTERIDLE
		*!* So it will work for menus in top level forms
		*!* Added WM_UNINITMENUPOPUP Bindevent so message will clear
		*!* after menu is closed
		
		Lparameters m.lnNewUpdateStyle as Integer
		
		Do Case
		    Case m.lnNewUpdateStyle = 0			&& no updates
		        Unbindevent(_vfp.HWnd, WM_ENTERIDLE)
		        Unbindevent(Thisform.HWnd, WM_ENTERIDLE)
		        Unbindevent(_vfp.HWnd, WM_UNINITMENUPOPUP)
		        Unbindevent(Thisform.HWnd, WM_UNINITMENUPOPUP)
		        This.tmrUpdater.Enabled = FALSE
		
		    Case m.lnNewUpdateStyle = 1			&& use timer
		        Unbindevent(_vfp.HWnd, WM_ENTERIDLE)
		        Unbindevent(Thisform.HWnd, WM_ENTERIDLE)
		        Unbindevent(_vfp.HWnd, WM_UNINITMENUPOPUP)
		        Unbindevent(Thisform.HWnd, WM_UNINITMENUPOPUP)
		        This.tmrUpdater.Enabled = TRUE
		
		    Case m.lnNewUpdateStyle = 2			&& windows events
		        This.tmrUpdater.Enabled = FALSE
		        Bindevent(_vfp.HWnd, WM_ENTERIDLE, This, "_MessageHandlerVfpWM_ENTERIDLE", 5)
				Bindevent(Thisform.HWnd, WM_ENTERIDLE, This, "_MessageHandlerVfpWM_ENTERIDLE", 5)
		        Bindevent(_vfp.HWnd, WM_UNINITMENUPOPUP, This, "_MessageHandlerVfpWM_UNINITMENUPOPUP", 5)
				Bindevent(Thisform.HWnd, WM_UNINITMENUPOPUP, This, "_MessageHandlerVfpWM_UNINITMENUPOPUP", 5)
		
		Endcase
		
		This.ctlUpdateStyle = m.lnNewUpdateStyle
		
	ENDPROC

	PROCEDURE Destroy
		*!* 2006-06-27 Swaped order of this method calls
		This._destroy()
		
		
	ENDPROC

	PROCEDURE hwnd_access
		Return This._ControlHwnd
		
	ENDPROC

	PROCEDURE Init
		*!* http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/commctls/status/status.asp
		
		*!*	ctl32_StatusBar
		*!*	Created by Carlos Alloatti - calloatti@gmail.com
		
		Lparameters tnPanelCount
		
		External Procedure ctl32.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")
		
		*!* Check if a numeric parameter was received, that should be PanelCount
		If Pcount() > 0 And Vartype(m.tnPanelCount) = "N" Then
		    This.ctlPanelCount = m.tnPanelCount
		Endif
		
		*!* 2006-06-27 Added Version(2) checking
		If Type("ThisForm") <> T_OBJECT And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME Then
		    Messagebox("Container has to be a Form Object", 16, This.Class)
		    Return
		Endif
		
		If This.Parent.BaseClass <> "Form"  And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME Then
		    Messagebox("Container has to be a Form Object", 16, This.Class)
		    Return
		Endif
		
		This._AddObjects()
		This._AddProperties()
		
		*!*	Set up some properties
		This.Visible = FALSE
		*!* Comented on 2006-05-07 // Giancarlo Piccinato // *!* .Anchor = 0
		This.Top = 0 &&-100
		This.Left = 0
		
		*!* 20070711 next two lines commented
		*!* This.Width = Thisform.Width
		*!* This.Height = This._Height
		
		This._AddProgressBar()
		
		*!* Add Panel objects:
		This._AddPanels()
		
		*!* To create the StatusBar in a TLF, we should wait until the Form is visible or make it visible,
		*!* so we can add the bottom toolbar that will create a window placeholder for
		*!* the StatusBar. To do that, the TLF Activate event is binded to _EventHandlerFormActivate
		*!* In the first Form.Activate event, this delegate code will be called, it will call _Create
		*!* and then Unbind itself.This way, we do not disturb the order of form events when form loads
		
		If This._FormType  = CON_FORMTYPE_TOPLEVEL
		    Bindevent(Thisform, "Activate", This, "_EventHandlerFormActivate", 1)
		Else
		    This._Create()
		    This.ctlInit()
		Endif
		
		
		
	ENDPROC

	HIDDEN PROCEDURE showprogressbarcaption_assign
		Lparameters vNewVal
		
		This.ShowProgressBarCaption = m.vNewVal
		
		._oldMessage = Sys(2015)
		This.ctlMessage = This.ctlMessage
		
		
		
	ENDPROC

	PROCEDURE _addobjects
		*!* _AddObjects()
		
		*!* Define Rect Object to be used by various methods
		This.AddProperty("oRect", Createobject("_RECT"))
		
		This.addobject("tmrUpdater", "ctl32_statusbar_timer")
		
		
	ENDPROC

	PROCEDURE _addpanels		&& Adds Panels objects to StatusBar container
		*!* _AddPanels()
		
		*!*	StatusBar Panel  0 is the Message Panel
		*!*	StatusBar Panel  1 is the ProgressBar Panel
		*!*	StatusBar Panel  2 is Custom Panel 1
		*!*	StatusBar Panel  3 is Custom Panel 2
		*!* ...
		*!*	StatusBar Panel  n is Custom Panel n -1
		*!*	StatusBar Panel  .ctlPanelCount + 5 is PanelOvr
		*!*	StatusBar Panel  6 is PanelNum
		*!*	StatusBar Panel  7 is PanelCaps
		*!*	StatusBar Panel  8 is PanelDate
		*!*	StatusBar Panel  9 is Last Panel for sizing
		
		*!* This.ctlPanels(1) = Panel1 -> StatusBar Panel 2 (index 0 based in windows statusbar control)
		*!* This.ctlPanels(2) = Panel2 -> StatusBar Panel 3 (index 0 based)
		*!* This.ctlPanels(3) = Panel3 -> StatusBar Panel 4 (index 0 based)
		
		Local ;
			lnx As Number, ;
			lnTotPanelCount As Number
		
		m.lnTotPanelCount = This.ctlPanelCount + This.nStdPanelCount
		
		*!* Resize array properties to hold references to all Panel objects
		Dimension This._Panels(m.lnTotPanelCount)
		Dimension This.ctlPanels(This.ctlPanelCount)
		
		*!* Store defined names of Panels in this array
		Local Array laPanelNames(m.lnTotPanelCount)
		
		m.laPanelNames(1)  = "PanelMessage"
		m.laPanelNames(2)  = "PanelProgressBar"
		
		*!* create custom panel names: "Panelx"
		*!* 2006-06-27 Changed to ALLTRIM(STR //Doru Constantin//
		For m.lnx = This.nStdPanelCountLeft + 1 To This.nStdPanelCountLeft + This.ctlPanelCount
			m.laPanelNames(m.lnx) = "Panel" + Alltrim(Str(m.lnx - This.nStdPanelCountLeft))
		Endfor
		
		m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 1) = "PanelOvr"
		m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 2) = "PanelNum"
		m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 3) = "PanelCaps"
		m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 4) = "PanelDate"
		m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 5) = "PanelLast"
		
		*!* Create left Panels
		For m.lnx = 1 To This.nStdPanelCountLeft
			This.Addobject(m.laPanelNames(m.lnx), "ctl32_StatusBar_Panel")
			This._Panels(m.lnx) = Evaluate("This." + m.laPanelNames(m.lnx))
			This._Panels(m.lnx).ctlIndex = m.lnx - 1		&& Compensate for 0 based index
		Endfor
		
		*!* set this so alignment works in this Panel
		This.PanelMessage.ctlAutosize = FALSE
		
		*!* Create custom Panels
		For m.lnx = This.nStdPanelCountLeft + 1 To This.nStdPanelCountLeft + This.ctlPanelCount
			This.Addobject(m.laPanelNames(m.lnx), "ctl32_StatusBar_Panel")
			This._Panels(m.lnx) = Evaluate("This." + m.laPanelNames(m.lnx))
			This._Panels(m.lnx).ctlIndex = m.lnx - 1
			This.ctlPanels(m.lnx - 2) = This._Panels(m.lnx)
		Endfor
		
		*!* Create right Panels
		For m.lnx =   This.nStdPanelCountLeft + This.ctlPanelCount + 1 To m.lnTotPanelCount
			This.Addobject(m.laPanelNames(m.lnx), "ctl32_StatusBar_Panel")
			This._Panels(m.lnx) = Evaluate("This." + m.laPanelNames(m.lnx))
			This._Panels(m.lnx).ctlIndex = m.lnx - 1
		Endfor
		
		
		
		
	ENDPROC

	PROCEDURE _addprogressbar
		*!* _AddProgressBar()
		
		*!* Add progressbar object, pass -1 as parameter to prevent init code from progressbar to run
		This.Newobject("ProgressBar","ctl32_progressbar", This.ClassLibrary, "", TRUE)
		
		This.ProgressBar.Width = 93
		This.ProgressBar.ctlMaximum = 100
		This.ProgressBar.Height = 17
		This.ProgressBar.ctlSizeAdjust = TRUE
		This.ProgressBar.ctlStyle = 2
		This.ProgressBar.ctlSmooth = TRUE
		This.ProgressBar.ctlBarcolor = -1
		*This.ProgressBar.ctlFormat = "<<ValueP>>"
		This.ProgressBar.ctlVisible = FALSE
		This.ProgressBar.ctlStep = 5
	ENDPROC

	PROCEDURE _addproperties
		This.AddProperty("nStdPanelCountLeft", 2)
		This.AddProperty("nStdPanelCountRight", 5)
		This.AddProperty("nStdPanelCount", This.nStdPanelCountLeft + This.nStdPanelCountRight)
		
		This.AddProperty("_OldWidth", 0)
		
		*!* Stores the HWnd of the host window
		This.AddProperty("_HostHWnd", 0)
		
		*!* Stores the value of VFP window procedure
		This.AddProperty("_WindowProcedure", ctlGetWindowProcedure(ThisForm.Hwnd))
		
		*!* Stores HWnd of Windows common control created by the class
		This.AddProperty("_ControlHwnd", 0)
		
		*!* Stores old date value to update PanelDate
		This.AddProperty("_OldDate", Dtos(Date(1900, 1, 1)))
		
		*!* Stores HWnd of Windows common control created by the class
		This.AddProperty("_ProxyHWnd", 0)
		
		*!* Indicates if the control is in the creation stage
		This.AddProperty("_Creating", FALSE)
		
		*!* Stores form type: standard, top level form, _screen
		This.AddProperty("_FormType", ctlGetFormType(This))
		
		*!* Stores status of keys:
		This.AddProperty("_OldCAPS", Not Capslock())
		This.AddProperty("_OldNUM", Not Numlock())
		This.AddProperty("_OldOVR", Not Insmode())
		This.AddProperty("_oldMessage", "")
		
		*!* Indicates if last mouse event was a double click:
		This.AddProperty("_DoubleClick", 0)
		
		*!* _Height property added to class
		*!* Indicates Height of status bar
		*!* This.AddProperty("_Height", 24)
		
		*!* Stores HWnd of native VFP status bar
		This.AddProperty("_VFPStatusBarHWnd", 0)
		
		*!* Stores old Window state
		This.AddProperty("_OldWindowState", -1)
		
		
	ENDPROC

	PROCEDURE _adjustprogressbar
		*!* _AdjustProgressBar()
		
		Local ;
			lcRect as String, ;
		    lnTop As Number, ;
		    lnBottom As Number, ;
		    lnBorderVertical as Integer, ;
		    lnTopMargin As Number, ;
		    lnBottomMargin As Number, ;
			lnColorBtnFace As Number
		
		*!* Set ProgressBar Top and Height, get Height of StatusBar window
		*!* 2006-06-27 Changed to use structs class
		m.lcRect = This.oRect.Value
		apiGetClientRect(This._ControlHwnd, @m.lcRect)
		This.oRect.Value = m.lcRect
		
		m.lnTop    = This.oRect.Top
		m.lnBottom = This.oRect.Bottom
		
		m.lnBorderVertical = This._GetBorder(CON_SBBORDER_VERTICAL)
		
		*!* Just in case we need to make adjustments to this values later
		If ctlIsThemeActive(This) = TRUE Then
		    m.lnTopMargin    = m.lnBorderVertical + 3
		    m.lnBottomMargin = m.lnBorderVertical + 1
		Else
		    m.lnTopMargin    = m.lnBorderVertical + 2
		    m.lnBottomMargin = m.lnBorderVertical
		Endif
		
		This.ProgressBar.Top = m.lnTop + m.lnTopMargin
		This.ProgressBar.Height =  m.lnBottom - m.lnTop - m.lnTopMargin - m.lnBottomMargin
		
		*!* Send color update message to correct bugs with theme changes
		If This.ProgressBar.ctlHWnd > 0 Then
		    apiSendMessageInteger(This.ProgressBar.ctlHWnd, WM_SYSCOLORCHANGE , 0, 0)
		    m.lnColorBtnFace = apiGetSysColor(COLOR_BTNFACE)
		    apiSendMessageInteger(This.ProgressBar.ctlHWnd, PBM_SETBKCOLOR, 0, m.lnColorBtnFace)
		Endif
		
		
	ENDPROC

	PROCEDURE _bindevents		&& Binds events.
		*!* _BindEvents()
		
		*!* http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_foxhelp9/html/f988d7c6-f382-40dd-a51a-b5ab73eb08c7.asp
		
		*!* Windows Theme change WM_THEMECHANGED
		*!* statusbar in screen, no bottom toolbar docked: handled by Resize event in _Resize
		*!* statusbar in screen, bottom toolbar docked: Bind WM_THEMECHANGED
		*!* statusbar in form or tlf: Bind WM_THEMECHANGED, to fix colors
		
		*!* _Screen.Themes Change
		*!* statusbar in screen, no bottom toolbar docked: handled by Resize event in _Resize
		*!* statusbar in screen, bottom toolbar docked: Bind _Screen.Themes to _SetThemes
		*!* statusbar in form or tlf, Bind _Screen.Themes to _SetThemes
		
		*!* Form.Themes Change
		*!* statusbar in screen, nothing to do
		*!* statusbar in form or tlf: Bind Form.Themes to _SetThemes
		
		
		*!*	If ctlGetOsVersion() >= NTDDI_WINXP And Version(CON_VER_NUM) >= 900 Then
		*!*		Bindevent(_vfp.HWnd, WM_THEMECHANGED, This, "_MessageHandlerVfpWM_THEMECHANGED", 5)
		*!*	Endif
		
		*!* Add BindWindowsEventsProxy property to _VFP :
		If Not Pemstatus(_vfp,"BindWindowsEventsProxy", 5)
			AddProperty(_vfp,"BindWindowsEventsProxy",Null)
		Endif
		
		*!* Create BindWindowsEventsProxy object:
		If Not Vartype(_vfp.BindWindowsEventsProxy)=="O"
			_vfp.BindWindowsEventsProxy = Newobject("BindWindowsEventsProxy", Addbs(Justpath(This.ClassLibrary))+"vfpx.vcx")
		Endif
		
		*!* Bind to BindWindowsEventsProxy _Msg property changes:
		Bindevent(_vfp.BindWindowsEventsProxy,"_Msg", This,"_VFPMessageHandler")
		
		Bindevent(_Screen, "Themes", This, "_PropertyHandlerScreenThemes", 1)
		
		If This._FormType <> CON_FORMTYPE_SCREEN
			Bindevent(Thisform, "Themes", This, "_PropertyHandlerFormThemes", 1)
		Endif
		
		*!* Check for undocking of bottom toolbars, _Screen.Resize event does not fire
		*!* when toolbar docked at bottom of screen is undocked.
		If This._FormType  = CON_FORMTYPE_SCREEN Then
			Bindevent(This._HostHWnd, WM_SIZE, This, "_MessageHandlerScreenWM_SIZE", 5)
		Endif
		
		*!* Monitor _Screen or Form resizes
		Bindevent(Thisform, "Resize", This, "_EventHandlerFormResize", 1)
		
		Bindevent(This._ProxyHWnd, WM_NOTIFY, This, "_MessageHandlerProxyWindowWM_NOTIFY", 5)
		
		*!* When ProgressBar Visible or Width changes, we should resize panels
		Bindevent(This.ProgressBar, "ctlVisible", This, "_PropertyHandlerProgressBarctlVisible", 1)
		Bindevent(This.ProgressBar, "Width",   This, "_PropertyHandlerProgressBarWidth", 1)
		
		*!* If we are in a TLF, we are responsible for releasing the toolbar we added (are we?)
		If This._FormType = CON_FORMTYPE_DEFAULT Then
			Bindevent(Thisform, "Destroy", This, "_EventHandlerFormDestroyBefore", 0)
		Endif
		
		*!* When host is a Standard Form and the form is resized in its Init event,
		*!* the Resize event of the form does not fire, so we bind to Visible
		*!* property of the form to cover all the bases like:
		*!* Do Form xxx Noshow
		*!* 2006-06-27 //Andrew Nickless//
		*!* Also when resizing screen while it is not visible
		*!* 2006-12-14 //danelliott//
		
		Bindevent(Thisform, "Visible", This, "_PropertyHandlerFormVisible", 1)
		
		
	ENDPROC

	PROCEDURE _create
		*!* Prevent recursive calling?
		If This._Creating = TRUE Then
		    Return
		Endif
		
		Local ;
			lnx As Number, ;
		    lnSize As Number, ;
		    lcClass As String
		
		*!* 2006-06-27 Removed window creation parameters as class properties and set them as local vars
		Local ;
		    dwExStyle As Integer, ;
		    lpClassName As String, ;
		    lpWindowName As String, ;
		    dwStyle As Integer, ;
		    hMenu As Integer, ;
		    hInstance As Integer, ;
		    lpParam As Integer
		
		*!* We enter Initialization Stage
		This._Creating = TRUE
		
		*m.llOldLockScreen = Thisform.LockScreen
		
		*!*	Lock Form/Screen updates until we are done:
		*!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
		*apiSendMessageInteger(_vfp.HWnd, WM_SETREDRAW, 0, 0)
		
		*!*	If This._FormType  = CON_FORMTYPE_SCREEN Then
		*!*	    LockWindowUpdate(_vfp.HWnd)
		*!*	Else
		*!*	    Thisform.LockScreen = TRUE
		*!*	Endif
		
		*!* We need the native Status Bar visible, otherwise _vfp.StatusBar gives us nothing!
		If Set("Status Bar") = "OFF" Then
		    Set Status Bar On
		Endif
		
		*!* When StatusBar is contained in a TLF or _Screen, we need a proxy window
		If This._FormType  <> CON_FORMTYPE_DEFAULT && TLF or Screen
		
		    *!* prepare to add aux toolbar, that creates the required bottom window to hold proxy window
		    *!* in a TLF, and gives us a way to get the HWnd of the host window
		    If Not Pemstatus(Thisform, "StatusBar_ToolBar", CON_PEMSTAT_DEFINED) Then
		        Thisform.AddProperty("StatusBar_ToolBar")
		    Else
		        Thisform.StatusBar_ToolBar = Null
		    Endif
		
		    *!*	add auxiliary toolbar, this toolbar docks itself to bottom of Form/Screen
		    *!* If in _Screen we just use it to get HWnd of Host window
		    Thisform.StatusBar_ToolBar = Createobject("ctl32_StatusBar_ToolBar")
		
		    *!* 2006-06-27 Removed window creation parameters as class properties and set them as local vars
		    *!*	Setup parameters for proxy window:
		    m.dwExStyle = Bitor(WS_EX_NOPARENTNOTIFY, WS_EX_TOPMOST)
		    m.lpWindowName = "StatusBar_proxy_window" + Sys(2015)
		    m.dwStyle = Bitor(WS_CHILD, WS_VISIBLE, WS_CLIPSIBLINGS, WS_CLIPCHILDREN)
		    This._HostHWnd = apiGetParent(Thisform.StatusBar_ToolBar.HWnd)	&& Neat Trick!
		
		    m.hMenu = 0
		    m.hInstance = 0
		    m.lpParam = 0
		
		    *!* Find class name to use for proxy window from host VFP window (www.news2news.com)
		    m.lcClass = Space(254)
		    m.lnSize = apiRealGetWindowClass (This._HostHWnd, @m.lcClass , Len(m.lcClass))
		    m.lcClass = Left(m.lcClass, m.lnSize)
		    m.lpClassName = m.lcClass
		
		    *!*	If statusbar is on screen, remove auxiliary ToolBar, VFP native StatusBar keeps host window alive
		    *!* Also, if left, it makes the bottom window taller. We dont want that.
		    *!* In a TLF, we need this ToolBar to keep host window alive. Added bonus: maximized child Forms
		    *!* dont overlap StatusBar
		    If This._FormType  = CON_FORMTYPE_SCREEN Then
		        *!* 20080425 commented .http://www.foxite.com/archives/0000169202.htm
		        *!* Thisform.StatusBar_ToolBar.Dock(TOOL_NOTDOCKED)
		        Thisform.StatusBar_ToolBar = Null
		    Endif
		
		    *!* Now that aux toolbar is out of the way, get HWnd of native statusbar to hide it
		    *!* if we are on _Screen
		
		    *!* 20070711 Modified to prevent bug where native VFP status bar pops up when
		    *!* clicking on ctl32_statusbar after poping up a context menu on a form
		    *!* reported by Bentam
		
		    If This._FormType  = CON_FORMTYPE_SCREEN
		        This._VFPStatusBarHWnd = apiGetWindow(This._HostHWnd, GW_CHILD)
		        *!* By using a timer, we give VFP some time to "stabilize" after a theme change
		        *!* The timer procedure hides the native vfp status bar
		        This.tmrHideVFPStatusBar.Reset()
		        This.tmrHideVFPStatusBar.Enabled = TRUE
		
		    Endif
		
		    *!*	CREATE proxy window now:
		    This._ProxyHWnd = apiCreateWindowEx( ;
		        m.dwExStyle, ;
		        m.lpClassName, ;
		        m.lpWindowName, ;
		        m.dwStyle, ;
		        0, ;
		        0, ;
		        This._Width, ;
		        This._Height,;
		        This._HostHWnd,;
		        m.hMenu, ;
		        m.hInstance, ;
		        m.lpParam)
		
		    *!* Only for debugging purposes
		    If This._ProxyHWnd = 0 And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME
		
		        *!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
		        *apiSendMessageInteger(_vfp.HWnd, WM_SETREDRAW, 1, 0)
		        *!* LockWindowUpdate(0)
		
		        *Thisform.LockScreen = m.llOldLockScreen
		        Messagebox("Error Creating window " + m.lpClassName, 0 + 16)
		    Endif
		
		    *!* When StatusBar is contained in a standard Form, there is no need for a proxy window
		Else
		    This._HostHWnd =  Thisform.HWnd
		    This._ProxyHWnd = Thisform.HWnd
		Endif
		
		*!* setup parameters for StatusBar control window:
		m.dwExStyle =  0
		m.lpClassName = STATUSCLASSNAMEA
		m.lpWindowName = m.lpClassName + Sys(2015)
		m.dwStyle = Bitor(WS_CHILD, WS_VISIBLE, WS_CLIPSIBLINGS, SBARS_TOOLTIPS, CCS_BOTTOM)
		
		*!* 20070711 changed code, always set sizegrip for screen, show or hide in resize
		
		If This.ctlSizeGrip = TRUE  Then
		    m.dwStyle = Bitor(m.dwStyle, SBARS_SIZEGRIP)
		Endif
		
		If This._FormType  = CON_FORMTYPE_SCREEN Then
		    m.dwStyle = Bitor(m.dwStyle, SBARS_SIZEGRIP)
		Endif
		
		m.hMenu = 0
		m.hInstance = 0
		m.lpParam = 0
		
		*!* 2006-06-27 Removed window creation parameters as class properties and set them as local vars
		*!*	Create StatusBar control window:
		This._ControlHwnd = apiCreateWindowEx( ;
		    m.dwExStyle, ;
		    m.lpClassName, ;
		    m.lpWindowName, ;
		    m.dwStyle, ;
		    0, ;
		    0, ;
		    0, ;
		    0, ;
		    This._ProxyHWnd, ;
		    m.hMenu, ;
		    m.hInstance, ;
		    m.lpParam)
		
		*!* Only for debugging purposes
		If This._ControlHwnd = 0 And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME
		
		    *!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
		    *apiSendMessageInteger(_vfp.HWnd, WM_SETREDRAW, 0, 0)
		    *!* LockWindowUpdate(0)
		
		    *Thisform.LockScreen = FALSE
		    Messagebox("Error Creating window " + m.lpClassName, 0 + 16)
		Endif
		
		*!* Send various messages to StatusBar:
		
		*!* Set simple to FALSE:
		apiSendMessageInteger(This._ControlHwnd, SB_SIMPLE , 0, 0)
		
		*!* Set minimum Height:
		apiSendMessageInteger(This._ControlHwnd, SB_SETMINHEIGHT, 22, 0)
		
		*!* Set locale strings for OVR, NUM, CAPS
		This._SetLocaleStrings()
		
		*!* Todo, refresh Panels captions and icons just in case we are recreating StatusBar
		*!* after an OS Theme change
		For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
		    This._Panels(m.lnx)._UpdateAll()
		Endfor
		
		*!* We finish Initialization State
		This._Creating = FALSE
		
		This.ProgressBar.ctlHostHwnd = This._ControlHwnd
		This.ProgressBar.ctlCreateControl()
		*!* Set Height and Vertical position of ProgressBar
		This._AdjustProgressBar()
		
		*!* This has to be done here to update panels:
		This._Resize()
		
		*!* Set colors of statusbar, it fails to set right by itself,
		*!* sometimes,  when XP theme changed to classic
		If ctlGetOsVersion() >= NTDDI_WINXP && And isThemeActive() = 0 Then
		    apiSendMessageInteger(This._ControlHwnd, WM_SYSCOLORCHANGE , 0, 0)
		Endif
		
		*!* Send Theme message to control:
		This._SetThemes()
		
		*!* 2006-06-27 Moved this before ctl32_BindEvents
		
		*!* Unlock Form/Screen updates:
		*!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
		*apiSendMessageInteger(_vfp.HWnd, WM_SETREDRAW, 1, 0)
		*!* LockWindowUpdate(0)
		
		*Thisform.LockScreen = m.llOldLockScreen
		
		*!* Now we bind to various events:
		This._BindEvents()
		
		*!* Enable updates of panels:
		This.ctlUpdateStyle = This.ctlUpdateStyle
		
		
		
		
	ENDPROC

	PROCEDURE _declaredlls		&& DLL declarations.
		
		
		
		
	ENDPROC

	PROCEDURE _destroy
		
		*!* Destroy StatusBar window
		If This._ControlHwnd > 0 Then
		    apiDestroyWindow(This._ControlHwnd)
		Endif
		
		*!* Destroy StatusBar proxy window
		If This._ProxyHWnd > 0 Then
		    apiDestroyWindow(This._ProxyHWnd)
		Endif
		
		This._ProxyHWnd = 0
		This._ControlHwnd = 0
		
		Local lnx As Integer
		
		*!* Aux toolbar in _Screen, clear object reference, remove property
		If Pemstatus(_Screen, "StatusBar_ToolBar", CON_PEMSTAT_DEFINED) Then
		    _Screen.StatusBar_ToolBar = Null
		    Removeproperty(_Screen, "StatusBar_ToolBar")
		Endif
		
		*!* Clear objects references - see _AddPanels
		
		For m.lnx = 1 To This.ctlPanelCount
		    This.ctlPanels(m.lnx) = Null
		Endfor
		
		For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
		    This._Panels(m.lnx) = Null
		Endfor
		
		*!* Display native vfp statusbar
		If This._FormType  = CON_FORMTYPE_SCREEN
		    apiShowWindow(This._VFPStatusBarHWnd, SW_SHOWNA)
		Endif
		
		
		
	ENDPROC

	PROCEDURE _eventhandlerformactivate		&& Binded to Form.Activate, for top level forms, it creates statusbar after form is visible
		*!* _EventHandlerFormActivate
		
		*!* This only gets called via a BindeEvent to parent TLF activate event
		*!* so the StatusBar is created after the form is visible
		
		Local lnX
		
		Unbindevent(Thisform, "Activate", This, "_EventHandlerFormActivate")
		This._Create()
		This.ctlInit()
		
		*!* This added so icons and captions assigned in control init will show, if
		*!* control is used in a top level form
		For m.lnX = 1 To This.ctlPanelCount + This.nStdPanelCount
			This._Panels(m.lnX)._UpdateAll()
		Endfor
		
	ENDPROC

	PROCEDURE _eventhandlerformdestroybefore
		*!* _EventHandlerFormDestroyBefore
		
		If Pemstatus(Thisform, "StatusBar_ToolBar", CON_PEMSTAT_DEFINED) Then
		    Thisform.StatusBar_ToolBar = Null
		    Removeproperty(Thisform, "StatusBar_ToolBar")
		Endif
		
	ENDPROC

	PROCEDURE _eventhandlerformresize
		*!* _EventHandlerFormResize
		
		This._Resize()
		
	ENDPROC

	PROCEDURE _getborder		&& Returns the width of the especified border:  1 = Horizontal,  2 = Vertical, 3 = Separator
		*!* _GetBorder()
		
		*!* Returns width in pixels of borders of a statusbar control
		
		*!* 1 = Horizontal
		*!* 2 = Vertical
		*!* 3 = Separator
		
		Lparameters tnWhichBorder
		
		Local ;
			lnBorders As Integer, ;
			lnBorder As Integer
		
		m.lnBorders = apiHeapAlloc(apiGetProcessHeap(), HEAP_ZERO_MEMORY, 12)
		
		apiSendMessageInteger(This._ControlHwnd, SB_GETBORDERS, 0, m.lnBorders)
		
		Do Case
		Case tnWhichBorder = 1
			m.lnBorder = CToBin(Sys(2600, m.lnBorders, 4), "4RS") && horizontal
		
		Case tnWhichBorder = 2
			m.lnBorder = CToBin(Sys(2600, m.lnBorders + 4, 4), "4RS") && vertical
		
		Otherwise
			m.lnBorder = CToBin(Sys(2600, m.lnBorders + 8, 4), "4RS") && separator
		Endcase
		
		apiHeapFree(apiGetProcessHeap(), 0, m.lnBorders)
		
		Return m.lnBorder
		
		
		
		
	ENDPROC

	PROCEDURE _messagehandlerproxywindowwm_notify		&& Handles mouse clicks in statusbar window
		*!* _MessageHandlerProxyWindowWM_NOTIFY
		
		*!* 2006-06-27 Now it uses _nmmouse class to handle structure
		*!* Bindevent(This._ProxyHWnd, WM_NOTIFY, This, "ctl32_WM_Notify", 1)
		*!* Handles mouse clicks in statubar window
		
		*!* msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/commctls/status/status.asp
		*!* The WM_NOTIFY  lParam parameter is a pointer to a nmmouse Structure
		
		Lparameters tnHWnd As Integer, tnMsg As Integer, tnwParam As Integer, tnLparam As Integer
		
		Local ;
			lnResult As Number, ;
			lnCode As Number, ;
			lndwItemSpec As Number
		
		If m.tnMsg = WM_NOTIFY And m.tnwParam = 0 Then
		
			*!* Read string of data
		
			Local loNmMouse As _NMMOUSE Of ctl32_structures.prg
		
			m.loNmMouse = Createobject("_NMMOUSE", m.tnLparam)
		
			*!* This determines button pressed and click/double click
			m.lnCode = m.loNmMouse.hdr.Code
		
			*!* This determines panel clicked
			m.lndwItemSpec = m.loNmMouse.dwItemSpec
		
			*!* This are mouse click coordinates
			This.nXCoord = m.loNmMouse.pt.x
			This.nYCoord = m.loNmMouse.pt.Y
		
			*!* Determine Panel clicked
			*!* PanelMessage will be -1, progressbar panel 0, first custom panel 1....
			*!* right panels will be 101, 102, 103, 104
			*!* no panel clicked is -2
			*!* m.lndwItemSpec = m.lndwItemSpec
		
			Do Case
				Case Between(m.lndwItemSpec, 0 , This.ctlPanelCount + 1)
					This.nPanel = m.lndwItemSpec - 1			&& Panel Clicked
				Case m.lndwItemSpec > This.ctlPanelCount
					This.nPanel = m.lndwItemSpec + 99 - This.ctlPanelCount
				Otherwise
					This.nPanel = m.lndwItemSpec
			Endcase
		
			*!* Determine mouse button pressed and check for double clicks
			*!* suppress second click event after double click
			Do Case
				Case m.lnCode = NM_CLICK	And This._DoubleClick = 1  && Left Click
					This._DoubleClick = 0
		
				Case m.lnCode = NM_RCLICK	And This._DoubleClick = 1  && Right Click
					This._DoubleClick = 0
		
				Case m.lnCode = NM_CLICK	And This._DoubleClick =  0  && Left Click
					This.nButton = 1
					Raiseevent(This, "ctlClick")
		
				Case m.lnCode = NM_RCLICK	And This._DoubleClick =  0 	&& Right Click
					This.nButton = 2
					Raiseevent(This, "ctlRightClick")
		
				Case m.lnCode = NM_DBLCLICK	&& Double Left Click
					This.nButton = 1
					This._DoubleClick = 1
					Raiseevent(This, "ctlDblClick")
		
				Case m.lnCode = NM_RDBLCLK	&& Double Right Click
					This.nButton = 2
					This._DoubleClick = 1
					Raiseevent(This, "ctlDblClick")
			Endcase
		Endif
		
		*!* 2006-06-27 Now the old window procedure is saved in the Init of the class
		m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)
		
		Return m.lnResult
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE _messagehandlerscreenwm_size
		*!* _MessageHandlerScreenWM_SIZE
		
		Lparameters tnHWnd As Integer, tnMsg As Integer, tnwParam As Integer, tnLparam As Integer
		
		Local lnResult As Integer
		
		If m.tnMsg = WM_SIZE Then
		    If This._FormType  = CON_FORMTYPE_SCREEN Then
		        This._Resize()
		    Endif
		Endif
		*!* 2006-06-27 Now the old window procedure is saved in the Init of the class
		*!* Just do what Calvin does, whatever it means
		m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE _messagehandlervfpwm_enteridle
		Lparameters m.tnHWnd As Integer, m.tnMsg As Integer, m.tnwParam As Integer, m.tnLparam As Integer
		
		Local lnResult As Integer
		
		m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)
		
		If m.tnwParam = MSGF_MENU Then
		    This.ctlUpdatePanels()
		Endif
		
		Return m.lnResult
	ENDPROC

	PROCEDURE _messagehandlervfpwm_themechanged
		*!*	*!* _MessageHandlerVFPWM_THEMECHANGED
		
		*!*	Lparameters tnHWnd As Integer, tnMsg As Integer, tnwParam As Integer, tnLparam As Integer
		
		*!*	Local lnResult As Number
		
		*!*	If m.tnMsg = WM_THEMECHANGED Then
		*!*	    This._SetThemes()
		*!*	Endif
		
		*!*	*!* Just do what Calvin does, whatever it means
		*!*	m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)
		
		*!*	Return m.lnResult
		
	ENDPROC

	PROCEDURE _messagehandlervfpwm_uninitmenupopup
		Lparameters m.tnHWnd As Integer, m.tnMsg As Integer, m.tnwParam As Integer, m.tnLparam As Integer
		
		Local lnResult As Integer
		
		m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)
		
		_vfp.StatusBar = ""
		
		This.ctlUpdatePanels()
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE _propertyhandlerformthemes
		*!* _PropertyHandlerFormThemes
		
		This._SetThemes()
		
	ENDPROC

	PROCEDURE _propertyhandlerformvisible
		*!* _PropertyHandlerFormVisible
		
		This._Resize()
		
		
	ENDPROC

	PROCEDURE _propertyhandlerprogressbarctlvisible
		*!* _PropertyHandlerProgressBarctlVisible
		
		This._ResizePanels()
	ENDPROC

	PROCEDURE _propertyhandlerprogressbarwidth
		*!* _PropertyHandlerProgressBarWidth
		
		This._ResizePanels()
	ENDPROC

	PROCEDURE _propertyhandlerscreenthemes
		*!* _PropertyHandlerScreenThemes
		
		This._OldWindowState = -1
		This._SetThemes()
		
	ENDPROC

	PROCEDURE _resize		&& Bound to Form.Resize
		*!*	If _FormType <> CON_FORMTYPE_DEFAULT, we have a proxy window that contains the statusbar window
		*!*	This is done so the statusbar width equals the Host Width, and
		*!* to show/hide the sizing grip of the statusbar, otherwise it does not display correctly
		*!*	What we do is set this proxy Window to Maximized or Normal state so statusbar hides/shows sizing grip
		*!*	by itself, depending on its parent proxy window WindowState
		
		If This._ControlHwnd = 0 Or This._Creating = TRUE Then
		    Return
		Endif
		
		*!* Check if a Theme change event destroyed our statusbar, if so, recreate
		If apiIsWindow(This._ControlHwnd) = 0 And This._FormType = CON_FORMTYPE_SCREEN Then
		    This._OldWindowState = -1
		    This._Create()
		    Return
		Endif
		
		*!* Check if window is still valid (it gets destroyed by OS Theme change, which triggers resize it seems)
		If apiIsWindow(This._ControlHwnd) = 0
		    Return
		Endif
		
		Local ;
		    lcRect As String, ;
		    lnyCoord As Number
		
		*!*	If container form is _Screen or TLF, deal with proxy window
		If This._FormType <> CON_FORMTYPE_DEFAULT
		    *!*	IF WindowState has changed, set proxy window:
		    If This._OldWindowState <> Thisform.WindowState
		
		        apiShowWindow(This._ProxyHWnd, SW_HIDE)
		
		        *!* 20070711 By setting the proxy window to maximized we hide size grip
		        Do Case
		            Case This.ctlSizeGrip = FALSE
		                apiShowWindow(This._ProxyHWnd, SW_MAXIMIZE)
		
		            Case Thisform.BorderStyle <> CON_BS_SIZABLE
		                apiShowWindow(This._ProxyHWnd, SW_MAXIMIZE)
		
		            Case Thisform.WindowState = WINDOWSTATE_MAXIMIZED
		                apiShowWindow(This._ProxyHWnd, SW_MAXIMIZE)
		
		            Otherwise
		                apiShowWindow(This._ProxyHWnd, SW_RESTORE)
		        Endcase
		
		        This._OldWindowState = Thisform.WindowState
		        apiShowWindow(This._ProxyHWnd, SW_SHOWNA)
		
		    Endif
		
		    *!*	Now we have to find Height of bottom window holding Statusbar proxy and maybe other
		    *!*	toolbars, so we can position the proxy window at the bottom
		    *!*	Also we resize proxy window to width of container form
		    *!* Find Height of client rectangle of Host window:
		
		    *!* 2006-06-27 Using oRect now
		    m.lcRect = This.oRect.Value
		    apiGetClientRect(This._HostHWnd, @m.lcRect)
		    This.oRect.Value = m.lcRect
		
		    m.lnyCoord = This.oRect.Height - This._Height
		
		    *!* Resize/move statusbar proxy window
		    apiSetWindowPos(This._ProxyHWnd, ;
		        0, ;
		        0, ;
		        m.lnyCoord, ;
		        This._Width, ;
		        This._Height, ;
		        0)
		Endif
		
		*!* Send resize message to ctl32_StatusBar
		apiSendMessageInteger(This._ControlHwnd, WM_SIZE, 0, 0)
		
		*!* Now resize panels, only resize if width has changed:
		If This._OldWidth <> This._Width Then
		    This._ResizePanels()
		    This._OldWidth = This._Width
		Endif
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE _resizepanels		&& Recalculates panel widths based on content
		*!* _ResizePanels()
		
		*!*	Panel  0 is the Message Panel
		*!*	Panel  1 is the ProgressBar Panel
		*!*	Panel  n to This.ctlPanelCount is Custom Panel n to This.ctlPanelCount
		*!*	Panel  This.ctlPanelCount + 3 is PanelOvr
		*!*	Panel  This.ctlPanelCount + 4 is PanelNum
		*!*	Panel  This.ctlPanelCount + 5 is PanelCaps
		*!*	Panel  This.ctlPanelCount + 6 is PanelDate
		*!*	Panel  This.ctlPanelCount + 7 is Last Panel for sizing grip
		
		*!* Panels array of StatusBar is 0 based
		*!* we have 1 based arrays in VFP
		
		If This._ControlHwnd = 0 Then
			Return
		Endif
		
		Local ;
			lnx As Number, ;
			lnMargin As Number, ;
			lnPBMargin As Number, ;
			lnLastMargin As Number, ;
			lcRights As String, ;
			lnTotalWidths As Number, ;
			lnLeft As Number, ;
			oPanel
		
		If This._BorderSeparatorWidth = 0 Then
			This._BorderSeparatorWidth = This._GetBorder(CON_SBBORDER_SEPARATOR)
		Endif
		
		*!* Calculate margin for caption and icons in panels:
		If ctlIsThemeActive(This) = TRUE Then
			m.lnMargin   = Int(This._BorderSeparatorWidth * 3)
			m.lnPBMargin = Int(This._BorderSeparatorWidth * 4)
		Else
			m.lnMargin   = Int(This._BorderSeparatorWidth * 2.2)
			m.lnPBMargin = Int(This._BorderSeparatorWidth * 2) - 1
		Endif
		
		If This.PanelDate.ctlVisible = FALSE Or This.PanelDate.ctlFormat = 0
			m.lnLastMargin = Sysmetric(SYSMETRIC_VSCROLLBARWIDTH) + This._BorderSeparatorWidth * 2 + 1
		Else
			m.lnLastMargin = Sysmetric(SYSMETRIC_VSCROLLBARWIDTH)
		Endif
		
		If Thisform.WindowState = WINDOWSTATE_MAXIMIZED Or Thisform.BorderStyle <> CON_BS_SIZABLE Then
			m.lnLastMargin = 0
		Endif
		
		*!* If no gripper at all:
		If This.ctlSizeGrip = FALSE Then
			m.lnLastMargin = 0
		Endif
		
		*!* Calculate Widths of panels from right to left, first panel gets what's left of total width
		*!* This.ctlPanelCount is the number of custom Panels, nStdPanelCount is the number of stock Panels (7)
		
		This._Panels(This.ctlPanelCount + This.nStdPanelCount)._Width = m.lnLastMargin
		
		For m.lnx = This.ctlPanelCount + This.nStdPanelCount - 1 To 3 Step -1
			m.oPanel = This._Panels(m.lnx)
			If m.oPanel.ctlVisible Then
				If m.oPanel.ctlAutosize Then
					Do Case
					Case (Empty(m.oPanel.ctlIcon) And Empty(m.oPanel.ctlCaption))
						m.oPanel._Width = 0
		
					Case Not Empty(m.oPanel.ctlIcon) And Empty(m.oPanel.ctlCaption)
						m.oPanel._Width = 16 + Int(m.lnMargin * 1.5)
		
					Case Empty(m.oPanel.ctlIcon) And Not Empty(m.oPanel.ctlCaption)
						m.oPanel._Width = ctlGetStringHeightFromHwnd(m.oPanel.ctlCaption, This._ControlHwnd) + Int(m.lnMargin * 1.5)
		
					Case Not Empty(m.oPanel.ctlIcon) And Not Empty(m.oPanel.ctlCaption)
						m.oPanel._Width = 18 + m.lnMargin + ctlGetStringHeightFromHwnd(m.oPanel.ctlCaption, This._ControlHwnd) + m.lnMargin
					Endcase
				Else
					m.oPanel._Width = m.oPanel.ctlWidth
				Endif
			Else
				m.oPanel._Width = 0
			Endif
		Endfor
		m.oPanel = Null
		
		*!* Calculate Width of ProgressBar Panel:
		m.oPanel = This._Panels(2)
		If m.oPanel.ctlAutosize = FALSE Or This.ProgressBar.ctlVisible = TRUE Then
			If ctlIsThemeActive(This) = TRUE Then
				m.oPanel._Width = This.ProgressBar.Width + m.lnPBMargin
			Else
				m.oPanel._Width = This.ProgressBar.Width + m.lnPBMargin + 1
			Endif
		Else
			m.oPanel._Width = 0
		Endif
		
		*!* Now we are going to calculate the x axis value of the right border of each Panel:
		*!* For now we assign StatusBar Width to Right property of last panel
		This._Panels(This.ctlPanelCount + This.nStdPanelCount)._Right = This._Width
		
		For m.lnx = This.ctlPanelCount + This.nStdPanelCount - 1 To 1 Step -1
			This._Panels(m.lnx)._Right = Max(This._Panels(m.lnx + 1)._Right - This._Panels(m.lnx + 1)._Width, 0)
		Endfor
		
		*!* Now assign -1 to Right property of last panel so it stretches
		*!* Send 0xFFFFFF instead of -1 or PanelDate is blank
		This._Panels(This.ctlPanelCount + This.nStdPanelCount)._Right = 0xFFFFFF
		
		*!* Do Same Thing to PanelDate so right border does not show
		If This._Panels(This.ctlPanelCount + This.nStdPanelCount - 1).ctlVisible = TRUE Then
			This._Panels(This.ctlPanelCount + This.nStdPanelCount - 1)._Right = 0xFFFFFF
		Endif
		
		*!* Now we check if all Panels have a zero Width, then we hide all separators:
		m.lnTotalWidths = 0
		For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
			m.lnTotalWidths = m.lnTotalWidths + This._Panels(m.lnx)._Width
		Endfor
		
		If m.lnTotalWidths <= m.lnLastMargin Then
			This.SetAll("_Right", 0xFFFFFF, "ctl32_StatusBar_Panel")
		Endif
		
		*!* Now we build a string of the calculated x axis right borders:
		m.lcRights = ""
		
		For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
			m.lcRights = m.lcRights + BinToC(This._Panels(m.lnx)._Right, "4RS")
		Endfor
		
		*!* We finally send the info to the StatusBar:
		apiSendMessageString(This._ControlHwnd, SB_SETPARTS, This.ctlPanelCount + This.nStdPanelCount, m.lcRights)
		
		If This.ProgressBar.ctlVisible Then
		*!* Set ProgressBar Left, retrieve rectangle of second panel (index 1) (0 based array in StatusBar)
			apiSendMessageInteger(This._ControlHwnd, SB_GETRECT, 1, This.oRect.Address)
			This.ProgressBar.Left = Int(This.oRect.Left + This._BorderSeparatorWidth / 2)
		Endif
		
		m.oPanel = Null
		
	ENDPROC

	PROCEDURE _setlocalestrings		&& Sets Locale strings for PanelCaps, PanelOvr, PanelNum
		Local  lnPrimaryLangID, lcIndicators
		
		If This.ctlLangID = 0x0 Then
		    m.lnPrimaryLangID = ctlGetPrimaryLangID()
		    * m.lnSubLangID     = ctlGetSubLangID()
		Else
		    *!* If ctlLangID is <> 0 then it overrides the system locale language
		    m.lnPrimaryLangID = ctlGetPrimaryLangID(This.ctlLangID)
		    * m.lnSubLangID = 	ctlGetSubLangID(This.ctlLangID)
		Endif
		
		Do Case
		    Case m.lnPrimaryLangID = LANG_CZECH 			&& // Vratislav Belský //
		        m.lcIndicators = "PRE|NUM|CAPS"
		
		    Case m.lnPrimaryLangID = LANG_ENGLISH
		        m.lcIndicators = "OVR|NUM|CAPS"
		
		    Case m.lnPrimaryLangID = LANG_FRENCH
		        m.lcIndicators = "OVR|NUM|CAPS"
		
		    Case m.lnPrimaryLangID = LANG_GERMAN
		        m.lcIndicators = "OVR|NUM|CAPS"
		
		    Case m.lnPrimaryLangID = LANG_ITALIAN             && // Emanuele Cerlini //
		        m.lcIndicators = "SSC|NUM|MAI"
		
		    Case m.lnPrimaryLangID = LANG_SPANISH
		        m.lcIndicators = "SOB|NUM|MAY"
		
		    Case m.lnPrimaryLangID = LANG_RUSSIAN
		        m.lcIndicators = "OVR|NUM|CAPS"
		
		    Otherwise
		        m.lcIndicators = "OVR|NUM|CAPS"	&& OTHER
		Endcase
		
		This.PanelOvr.ctlCaption  = Getwordnum(m.lcIndicators, 1, "|")
		This.PanelNum.ctlCaption  = Getwordnum(m.lcIndicators, 2, "|")
		This.PanelCaps.ctlCaption = Getwordnum(m.lcIndicators, 3, "|")
		
		
		
	ENDPROC

	PROCEDURE _setthemes
		*!* _SetThemes()
		
		This._BorderSeparatorWidth = 0
		
		*!* If statusbar was not preserved by a docked toolbar during a _Screen.Themes change, just return
		If apiIsWindow(This._ControlHwnd) = 0 And This._FormType = CON_FORMTYPE_SCREEN Then
			Return
		Endif
		
		If ctlIsThemeActive(This) = TRUE Then
			apiSetWindowTheme(This._ControlHwnd, Null, Null)
		Else
			apiSetWindowTheme(This._ControlHwnd, Null, "")
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, WM_SYSCOLORCHANGE , 0, 0)
		
		This.ProgressBar.ctlThemes = This.ctlThemes
		
		This._AdjustProgressBar()
		This._ResizePanels()
		
		
		
		
	ENDPROC

	PROCEDURE _vfpmessagehandler
		*!* _VFPMessageHandler
		*!* This binds to the _Msg property of the BindWindowsEventsProxy object of _VFP
		
		Do Case
		
			Case _vfp.BindWindowsEventsProxy._Msg = WM_THEMECHANGED
				This._SetThemes()
		Endcase
		
	ENDPROC

	PROCEDURE _width_access
		*!*	RETURN desired Width for StatusBar proxy Window
		*!*	Width from _Screen is no good, space taken by toolbars on both
		*!*	sides is subtracted from total Width, so we use _vfp HWnd
		
		*!* Modified 20061010
		
		Local ;
			lnHWnd As Integer, ;
			lcRect As String
		
		If This._FormType  = CON_FORMTYPE_SCREEN
			m.lnHWnd = _vfp.HWnd
		Else
			m.lnHWnd = Thisform.HWnd
		Endif
		
		m.lcRect = This.oRect.Value
		apiGetClientRect(m.lnHWnd, @m.lcRect)
		This.oRect.Value = m.lcRect
		
		*!* Width is off by one pixel
		Return This.oRect.Width + 1
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

	PROCEDURE tmrHideVFPStatusBar.Timer
		*!* By Using this timer, we give time to VFP to "stabilize" after a Theme change
		
		apiShowWindow(This.Parent._VFPStatusBarHWnd, SW_HIDE)
		This.Enabled = FALSE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_trackbar AS ctl32_controlbase OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_trackbar.bmp" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctllargechange_assign
		*m: ctlmaximum_assign
		*m: ctlminimum_assign
		*m: ctlscroll		&& Occurs when either a mouse or keyboard action moves the scroll box.
		*m: ctlsetrange		&& Sets the minimum and maximum values for a TrackBar.
		*m: ctlshowticks_assign
		*m: ctlshowtips_assign
		*m: ctlsmallchange_assign
		*m: ctlthumbsize_assign
		*m: ctltickfrequency_assign
		*m: ctltickstyle_assign
		*m: ctltooltipposition_assign
		*m: _assign
		*m: _setlargechange
		*m: _setmaximum
		*m: _setminimum
		*m: _setshowtips
		*m: _setsmallchange
		*m: _setthumbsize
		*m: _settickfrequency
		*m: _settickstyle
		*m: _settooltipposition
		*p: ctllargechange		&& Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
		*p: ctlmaximum		&& Gets or sets the upper limit of the range this TrackBar is working with.
		*p: ctlminimum		&& Gets or sets the lower limit of the range this TrackBar is working with.
		*p: ctlshowticks		&& Specifies if the tick marks should be visible.
		*p: ctlshowtips		&& Determines whether ToolTips are shown for the control.
		*p: ctlsmallchange		&& Gets or sets the value added to or subtracted from the Value property when the scroll box is moved a small distance.
		*p: ctlthumbsize		&& Gets or sets the size of the slider in a trackbar.
		*p: ctltickfrequency		&& Gets or sets a value that specifies the delta between ticks drawn on the control.
		*p: ctltickstyle		&& Gets or sets a value indicating how to display the tick marks on the track bar. 0,1,2,3.
		*p: ctltooltipposition		&& Specifies the position of the ToolTip control used by a trackbar control.
		*p: _defaultthumbsize		&& Saves the default thumbsize for trackbars.
		*p: _marginsize
		*p: _thumbsize		&& Specifies the Windows DEFAULT ThumbSize
		*p: _thumbtrack		&& Indicates if the last message request was a TB_THUMBTRACK
		*p: _tickssize
	*</DefinedPropArrayMethod>

	ctlautosize = .T.
	ctlbottom = 0
	ctlcanfocus = .T.
	ctlfocused = .F.
	ctllargechange = 5		&& Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
	ctlmaximum = 10		&& Gets or sets the upper limit of the range this TrackBar is working with.
	ctlminimum = 0		&& Gets or sets the lower limit of the range this TrackBar is working with.
	ctlorientation = 0
	ctlshowticks = .T.		&& Specifies if the tick marks should be visible.
	ctlshowtips = .F.		&& Determines whether ToolTips are shown for the control.
	ctlsmallchange = 1		&& Gets or sets the value added to or subtracted from the Value property when the scroll box is moved a small distance.
	ctlthumbsize = 0		&& Gets or sets the size of the slider in a trackbar.
	ctltickfrequency = 1		&& Gets or sets a value that specifies the delta between ticks drawn on the control.
	ctltickstyle = 2		&& Gets or sets a value indicating how to display the tick marks on the track bar. 0,1,2,3.
	ctltooltipposition = 0		&& Specifies the position of the ToolTip control used by a trackbar control.
	Height = 34
	Name = "ctl32_trackbar"
	Width = 240
	_backgroundbrush = 0
	_defaultheight = 0
	_defaultthumbsize = 0		&& Saves the default thumbsize for trackbars.
	_defaultwidth = 0
	_marginsize = 0
	_thumbsize = 0		&& Specifies the Windows DEFAULT ThumbSize
	_thumbtrack = .F.		&& Indicates if the last message request was a TB_THUMBTRACK
	_tickssize = 0
	ctlTextBox.Name = "ctlTextBox"
	lblname.Caption = "ctl32_trackbar"
	lblname.Name = "lblname"
	
	PROCEDURE ctldefaultheight_access
		*!* ctlDefaultHeight_Access()
		
		*!* ctlTickStyle = 0
		*!* =========== Margin
		*!*      #      Thumb
		*!* =========== Margin
		
		*!* ctlTickStyle = 1
		*!* =========== Margin
		*!*      #      Thumb
		*!* | | | | | | Tickmarks
		*!* =========== Margin
		
		*!* ctlTickStyle = 2
		*!* =========== Margin
		*!* | | | | | | Tickmarks
		*!*      #      Thumb
		*!* =========== Margin
		
		*!* ctlTickStyle = 3
		*!* =========== Margin
		*!* | | | | | | Tickmarks
		*!*      #      Thumb
		*!* | | | | | | Tickmarks
		*!* =========== Margin
		
		Local ;
			lnHeight As Integer, ;
			lnThumbSize As Integer
		
		*!* "The default width is 104 pixels" says Microsoft
		If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
		
			m.lnThumbSize = apiSendMessageInteger(This._ControlHwnd, TBM_GETTHUMBLENGTH, 0, 0)
		
			Do Case
				Case This.ctlShowTicks = FALSE
					m.lnHeight = This._MarginSize * 2 + m.lnThumbSize
		
				Case This.ctlTickStyle < 1
					m.lnHeight = This._MarginSize * 2 + m.lnThumbSize
		
				Case This.ctlTickStyle = 1
					m.lnHeight = This._MarginSize * 2 + This._TicksSize + m.lnThumbSize
		
				Case This.ctlTickStyle = 2
					m.lnHeight = This._MarginSize * 2 + m.lnThumbSize + This._TicksSize
		
				Case This.ctlTickStyle > 2
					m.lnHeight = This._MarginSize * 2 + This._TicksSize * 2 + m.lnThumbSize
			Endcase
		
		Else
		
			*!* "The default height for a vertical trackbar is 104 pixels" says Microsoft
			m.lnHeight = 104
		
		Endif
		
		Return m.lnHeight
		
	ENDPROC

	PROCEDURE ctldefaultwidth_access
		*!* ctlDefaultWidth_Access()
		
		*!* ctlTickStyle = 0
		*!* =========== Margin
		*!*      #      Thumb
		*!* =========== Margin
		
		*!* ctlTickStyle = 1
		*!* =========== Margin
		*!*      #      Thumb
		*!* | | | | | | Tickmarks
		*!* =========== Margin
		
		*!* ctlTickStyle = 2
		*!* =========== Margin
		*!* | | | | | | Tickmarks
		*!*      #      Thumb
		*!* =========== Margin
		
		*!* ctlTickStyle = 3
		*!* =========== Margin
		*!* | | | | | | Tickmarks
		*!*      #      Thumb
		*!* | | | | | | Tickmarks
		*!* =========== Margin
		
		Local ;
			lnWidth As Integer, ;
			lnThumbSize As Integer
		
		If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
		
			m.lnThumbSize = apiSendMessageInteger(This._ControlHwnd, TBM_GETTHUMBLENGTH, 0, 0)
		
			Do Case
				Case This.ctlShowTicks = FALSE
					m.lnWidth = This._MarginSize * 2 + m.lnThumbSize
		
				Case This.ctlTickStyle < 1
					m.lnWidth = This._MarginSize * 2 + m.lnThumbSize
		
				Case This.ctlTickStyle = 1
					m.lnWidth = This._MarginSize * 2 + This._TicksSize + m.lnThumbSize
		
				Case This.ctlTickStyle = 2
					m.lnWidth = This._MarginSize * 2 + m.lnThumbSize + This._TicksSize
		
				Case This.ctlTickStyle > 2
					m.lnWidth = This._MarginSize * 2 + This._TicksSize * 2 + m.lnThumbSize
			Endcase
		
		Else
		
			*!* "The default width for an horizontal trackbar is 104 pixels" says Microsoft
			m.lnWidth = 104
		
		Endif
		
		Return m.lnWidth
		
	ENDPROC

	PROCEDURE ctllargechange_assign
		*!* ctlLargeChange_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlLargeChange # m.tuNewValue Then
			This.ctlLargeChange = m.tuNewValue
			This._SetLargeChange()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlmaximum_assign
		*!* ctlMaximum_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlMaximum # m.tuNewValue Then
			This.ctlMaximum = m.tuNewValue
			This._SetMaximum()
		Endif
		
	ENDPROC

	PROCEDURE ctlminimum_assign
		*!* ctlMinimum_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlMinimum # m.tuNewValue Then
			This.ctlMinimum = m.tuNewValue
			This._SetMinimum()
		Endif
		
	ENDPROC

	PROCEDURE ctlscroll		&& Occurs when either a mouse or keyboard action moves the scroll box.
	ENDPROC

	PROCEDURE ctlsetrange		&& Sets the minimum and maximum values for a TrackBar.
		*!* ctlSetRange(nMin, nMax)
		
		Lparameters m.tnMinimum As Integer, m.tnMaximum As Integer
		
		This.ctlMinimum = m.tnMinimum
		This.ctlMaximum = m.tnMaximum
	ENDPROC

	PROCEDURE ctlshowticks_assign
		*!* ctlShowTicks_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue= m.tuNewValue # 0
		Endif
		
		If This.ctlShowTicks # m.tuNewValue Then
			This.ctlShowTicks = m.tuNewValue
			This._SetTickStyle()
		Endif
		
	ENDPROC

	PROCEDURE ctlshowtips_assign
		*!* ctlShowTips_Assign()
		
		Lparameters m.tuNewValue
		
		If Vartype(m.tuNewValue) = T_NUMERIC Then
			m.tuNewValue= m.tuNewValue # 0
		Endif
		
		If This.ctlShowTips # m.tuNewValue Then
			This.ctlShowTips = m.tuNewValue
			This._SetShowTips()
		Endif
		
	ENDPROC

	PROCEDURE ctlsmallchange_assign
		*!* ctlSmallChange_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlSmallChange # m.tuNewValue Then
			This.ctlSmallChange = m.tuNewValue
			This._SetSmallChange()
		Endif
		
		
	ENDPROC

	PROCEDURE ctlthumbsize_assign
		*!* ctlThumbSize_Assign()
		
		Lparameters m.tuNewValue
		
		If m.tuNewValue <= 0 Then
			m.tuNewValue = This._DefaultThumbSize
		Endif
		
		This.ctlThumbSize = m.tuNewValue
		This._SetThumbSize()
		
	ENDPROC

	PROCEDURE ctltickfrequency_assign
		*!* ctlTickFrequency_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlTickFrequency # m.tuNewValue Then
			This.ctlTickFrequency = m.tuNewValue
			This._SetTickFrequency()
		Endif
		
		
	ENDPROC

	PROCEDURE ctltickstyle_assign
		*!* ctlTickStyle_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlTickStyle # m.tuNewValue Then
			This.ctlTickStyle = m.tuNewValue
			This._SetTickStyle()
		Endif
		
	ENDPROC

	PROCEDURE ctltooltipposition_assign
		*!* ctlToolTipPosition_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlToolTipPosition # m.tuNewValue Then
			This.ctlToolTipPosition = m.tuNewValue
			This._SetToolTipPosition()
		Endif
		
	ENDPROC

	PROCEDURE _assign
	ENDPROC

	PROCEDURE _bindevents
		*!* _BindEvents()
		
		DoDefault()
		
		Bindevent(This.ctlHostFormhWnd, WM_HSCROLL, Thisform.BindWindowsEventsProxy, "_MsgHandler", 4)
		Bindevent(This.ctlHostFormhWnd, WM_VSCROLL, Thisform.BindWindowsEventsProxy, "_MsgHandler", 4)
		
		
		
		
	ENDPROC

	PROCEDURE _callbackproc
		*!* _CallbackProc
		
		Lparameters nHWnd As Integer, Msg As Integer, wParam As Integer, Lparam As Integer
		
		Do Case
		
			Case m.Msg = WM_MOUSEWHEEL
		
				Local m.lnWheelTick As Short
		
				m.lnWheelTicks = ctlHiWord(wParam)
		
				If m.lnWheelTicks > 32767 Then
					m.lnWheelTicks = m.lnWheelTicks - 0xffff - 1
				Endif
		
				m.lnWheelTicks = Int(m.lnWheelTicks / WHEEL_DELTA)
		
				This.ctlValue = This.ctlValue + m.lnWheelTicks
		
				*!* Override default window procedure
				Return 0
		
			Case m.Msg = WM_NOTIFY And This.ctlShowTips = TRUE And This.ctlOrientation = 1
				*!* Here we try to fix vertical trackbar tooltip
				*!* Get NMHDR structure from pointer
				Local m.loNMHdr As _NMHDR, lnCode As Integer
		
				m.loNMHdr = Createobject("_NMHDR", m.Lparam)
		
				m.lnCode = m.loNMHdr.Code
				m.loNMHdr = .Null.
		
				If m.lnCode = TTN_GETDISPINFOW Then
		
					Local m.loNMTTDISPINFO As _NMTTDISPINFO
					m.loNMTTDISPINFO = Createobject("_NMTTDISPINFO", m.Lparam)
		
					m.loNMTTDISPINFO.szText = Strconv(Transform(This.ctlValue) + NULW, 5)
					m.loNMTTDISPINFO = .Null.
		
					*!* Override default window procedure
					Return 0
				Endif
		
		Endcase
		
		*!* Return default window procedure
		Return DoDefault(m.nHWnd, m.Msg, m.wParam, m.Lparam)
		
	ENDPROC

	PROCEDURE _formmessagehandler
		*!* _FormMessageHandler()
		
		DoDefault()
		
		Local m.lnRequest As Integer
		
		Do Case
		
			Case Thisform.BindWindowsEventsProxy._Msg = WM_HSCROLL Or Thisform.BindWindowsEventsProxy._Msg = WM_VSCROLL
		
				If Thisform.BindWindowsEventsProxy._lParam = This._ControlHwnd Then
		
					*!* TBS_DOWNISLEFT style just plain does not work!, so reverse value for
					*!* vertical trackbars
		
					m.lnRequest  = ctlLoWord(Thisform.BindWindowsEventsProxy._wParam)
					m.lnPosition = ctlHiWord(Thisform.BindWindowsEventsProxy._wParam)
		
					Do Case
		
						Case m.lnRequest = TB_ENDTRACK		&& 8
							Return && We dont need to do anything else
		
						Case m.lnRequest = TB_THUMBPOSITION
							If This._ThumbTrack = TRUE && 4
								This._ThumbTrack = FALSE
							Else
								*?"MOUSEWHEEL", apiSendMessageInteger(This._ControlHwnd, TBM_GETPOS, 0, 0), m.lnPosition
								*RETURN
							Endif
		
		
		
						Case m.lnRequest = TB_THUMBTRACK	&& 5
							This._ThumbTrack = TRUE
		
					Endcase
		
					This._EnableUpdates = FALSE
		
					If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
						This.ctlValue = This.ctlMaximum - apiSendMessageInteger(This._ControlHwnd, TBM_GETPOS, 0, 0) + This.ctlMinimum
					Else
						This.ctlValue = apiSendMessageInteger(This._ControlHwnd, TBM_GETPOS, 0, 0)
					Endif
		
					This._EnableUpdates = TRUE
		
				Endif
		
				*!*		Case Thisform.BindWindowsEventsProxy._Msg = WM_NOTIFY
		
				*!*			If This.ctlBackStyle # 0 Then
				*!*				Return
				*!*			Endif
		
				*!*			*!* Get NMHDR structure from pointer
				*!*			Local m.loNMHdr As _NMHDR
				*!*			m.loNMHdr = Createobject("_NMHDR", Thisform.BindWindowsEventsProxy._lParam)
		
				*!*			*!* If the notification is not NM_CUSTOMDRAW, nothing to do
				*!*			If m.loNMHdr.Code # NM_CUSTOMDRAW Then
				*!*				Return
				*!*			Endif
		
				*!*			*!* If the message is not for this control, just return
				*!*			If m.loNMHdr.hwndFrom # This._ControlHwnd Then
				*!*				Return
				*!*			Endif
		
				*!*			*!* We have a NM_CUSTOMDRAW notification, get NMCUSTOMDRAW structure from pointer
				*!*			*!* The NMCUSTOMDRAW first member is the NMHDR we got before
				*!*			Local m.loNMCustomDraw As _NMCUSTOMDRAW
				*!*			m.loNMCustomDraw = Createobject("_NMCUSTOMDRAW", Thisform._2ce01ty4y_lParam)
		
				*!*			*!* If this is prepaint stage, ask to be notified of items prepaints and return.
				*!*			If m.loNMCustomDraw.dwDrawStage = CDDS_PREPAINT
				*!*				This._uItemState = m.loNMCustomDraw.uItemState
				*!*				Thisform._2ce01ty4y_ReturnValue = CDRF_NOTIFYITEMDRAW
				*!*				Return
				*!*			Endif
		
				*!*			*!* At this point, if we dont have a CDDS_ITEMPREPAINT, nothing to do then
				*!*			If m.loNMCustomDraw.dwDrawStage # CDDS_ITEMPREPAINT
				*!*				Return
				*!*			Endif
		
				*!*			Thisform._2ce01ty4y_ReturnValue = CDRF_DODEFAULT
		
				*!*			*!* Before control draws ticks, draw background:
				*!*			If m.loNMCustomDraw.dwItemSpec = TBCD_TICS
				*!*				Local m.lcRect As String
		
				*!*				*!* If control has focus, leave space for focus rectangle
				*!*				*!* Code is not clear, trying to speed things up
				*!*				If Bitand(This._uItemState, CDIS_FOCUS) = CDIS_FOCUS And This.ctlShowFocusCues Then
				*!*					m.lcRect = ;
				*!*						0h0100000001000000 + ;
				*!*						BINTOC(This.Width - 1, "4rs") + ;
				*!*						BINTOC(This.Height - 1, "4rs")
				*!*				Else
				*!*					m.lcRect = ;
				*!*						0h0000000000000000 + ;
				*!*						BINTOC(This.Width, "4rs") + ;
				*!*						BINTOC(This.Height, "4rs")
				*!*				Endif
		
				*!*				apiFillRect(m.loNMCustomDraw.hdc, m.lcRect, This._BackGroundBrush)
		
				*!*				Return
				*!*			Endif
		
				*!*			*!* Before control draws channel, draw channel background, with a width equal to the thumb
				*!*			If m.loNMCustomDraw.dwItemSpec = TBCD_CHANNEL
				*!*				Local m.loRect As _RECT, m.lcRect As String
				*!*				m.loRect = Createobject("_RECT")
				*!*				apiSendMessageInteger(This._ControlHwnd, TBM_GETTHUMBRECT , 0, m.loRect.Address)
		
				*!*				**!* If control has focus, leave space for focus rectangle
				*!*				If Bitand(This._uItemState, CDIS_FOCUS) = CDIS_FOCUS And This.ctlShowFocusCues Then
				*!*					If This.ctlOrientation = 0 Then
				*!*						m.loRect.Left = 1
				*!*						m.loRect.Right = This.Width - 1
				*!*					Else
				*!*						m.loRect.Top = 1
				*!*						m.loRect.Bottom = This.Height - 1
				*!*					Endif
		
				*!*				Else
				*!*					If This.ctlOrientation = 0 Then
				*!*						m.loRect.Left = 0
				*!*						m.loRect.Right = This.Width
				*!*					Else
				*!*						m.loRect.Top = 0
				*!*						m.loRect.Bottom = This.Height
				*!*					Endif
				*!*				Endif
		
				*!*				m.lcRect = m.loRect.Value
		
				*!*				*apiFillRect(m.loNMCustomDraw.hdc, m.lcRect, This._BackGroundBrush)
		
				*!*			Endif
		
		Endcase
		
	ENDPROC

	PROCEDURE _getdefaultsize
		*!* _GetDefaultSize()
		
		*!* This gets the size (width for horizontal trackbars, height for vertical)
		*!* of the tickmarks area, the margin between the border and the tickmarks or thumb,
		*!* and the default thumb size. Also saves the initial width/height of the control.
		*!* If ctlAutosize is set to FALSE, this initial widht/height is used to size the control
		*!* properties used are:
		
		*!* _MarginSize
		*!* _DefaultThumbSize
		*!* _TicksSize
		*!* _DefaultSize
		
		*!* See ctlDefaultHeight/Width_Access where this properties are used
		
		*!* http://msdn2.microsoft.com/en-us/library/system.windows.forms.trackbar.defaultsize.aspx
		
		Local ;
			loRect As _RECT, ;
			lnStyle As Integer, ;
			lnOldStyle As Integer
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
		
		*!* Save current value
		m.lnOldStyle = m.lnStyle
		
		m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_AUTOTICKS), TBS_AUTOTICKS)
		m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_NOTICKS), TBS_NOTICKS)
		m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_TOP), TBS_TOP)
		m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_BOTTOM), TBS_BOTTOM)
		m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_BOTH), TBS_BOTH)
		m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_VERT), TBS_VERT)
		m.lnStyle = Bitor(m.lnStyle, TBS_HORZ)
		
		m.loRect = Createobject("_RECT")
		
		*!* Remove all ticks and get top margin and thumb height
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, Bitor(m.lnStyle, TBS_NOTICKS))
		apiSendMessageInteger(This._ControlHwnd, TBM_GETTHUMBRECT , 0, m.loRect.Address)
		
		This._MarginSize = m.loRect.Top
		
		*!* Save the Windows default thumb size once:
		This._DefaultThumbSize = m.loRect.Height
		
		*!* Add ticks at the top, calculate ticks height
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, Bitor(m.lnStyle, TBS_TOP, TBS_AUTOTICKS))
		apiSendMessageInteger(This._ControlHwnd, TBM_GETTHUMBRECT , 0, m.loRect.Address)
		
		This._TicksSize = m.loRect.Top - This._MarginSize
		
		This._DefaultHeight = This.Height
		This._DefaultWidth = This.Width
		
		*!* Set style to saved style
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnOldStyle)
		
	ENDPROC

	PROCEDURE _getdwexstyle
		*!* _GetdwExStyle()
		
		Return 0 &&BITOR(WS_EX_TOOLWINDOW, WS_EX_TOPMOST)
		
	ENDPROC

	PROCEDURE _getdwstyle
		*!* _GetdwStyle()
		
		Local ;
			dwStyle As Integer, ;
			lnTickStyle As Integer
		
		m.dwStyle = Bitor(WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS, WS_TABSTOP) &&, WS_POPUP)
		
		m.dwStyle = Bitor(m.dwStyle, TBS_FIXEDLENGTH, TBS_DOWNISLEFT)
		
		If This.ctlShowTips = TRUE Then
			m.dwStyle = Bitor(m.dwStyle, TBS_TOOLTIPS)
		Endif
		
		If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
			m.dwStyle = Bitor(m.dwStyle, TBS_VERT)
		Else
			m.dwStyle = Bitor(m.dwStyle, TBS_HORZ)
		Endif
		
		m.lnTickStyle = Min(Max(This.ctlTickStyle, CTLTICKSTYLE_NONE), CTLTICKSTYLE_BOTH)
		
		If This.ctlShowTicks = FALSE Or m.lnTickStyle = CTLTICKSTYLE_NONE Then
			m.dwStyle = Bitor(m.dwStyle, TBS_NOTICKS)
		Else
			m.dwStyle = Bitor(m.dwStyle, TBS_AUTOTICKS)
		Endif
		
		Do Case
		
		Case m.lnTickStyle = CTLTICKSTYLE_TOPLEFT
			m.dwStyle = Bitor(m.dwStyle, TBS_TOP)
		
		Case m.lnTickStyle = CTLTICKSTYLE_BOTTOMRIGHT
			m.dwStyle = Bitor(m.dwStyle, TBS_BOTTOM)
		
		Case m.lnTickStyle = CTLTICKSTYLE_BOTH
			m.dwStyle = Bitor(m.dwStyle, TBS_BOTH)
		
		Endcase
		
		Return m.dwStyle
		
	ENDPROC

	PROCEDURE _getlpclassname
		Return TRACKBAR_CLASSA
		
	ENDPROC

	PROCEDURE _postcreate
		*!* _PostCreate()
		
		This._SetMinimum()
		This._SetMaximum()
		
		This._SetLargeChange()
		This._SetSmallChange()
		
		This._SetTickFrequency()
		This._SetToolTipPosition()
		
		This._SetShowFocusCues()
		
		This._SetThumbSize()
		
	ENDPROC

	PROCEDURE _setautosize
		*!* _SetAutosize()
		
		Local lnAnchor As Integer
		
		m.lnAnchor = This.Anchor
		
		This.Anchor = 0
		
		If This.ctlAutoSize = TRUE Then
		
			*!* Save previous dimensions
			This._DefaultHeight = This.Height
			This._DefaultWidth = This.Width
		
			If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
				This.Width = This.ctlDefaultWidth
			Else
				This.Height = This.ctlDefaultHeight
			Endif
		
		Else
		
			If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
				This.Width = This._DefaultWidth
			Else
				This.Height = This._DefaultHeight
			Endif
		
		Endif
		
		This.Anchor = m.lnAnchor
		
	ENDPROC

	PROCEDURE _setbackcolor
		This._CreateBackGroundBrush()
		This.ctlRefresh()
		
	ENDPROC

	PROCEDURE _setlargechange
		*!* _SetLargeChange()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, TBM_SETPAGESIZE, 0, This.ctlLargeChange)
		
	ENDPROC

	PROCEDURE _setmaximum
		*!* _SetMaximum()
		
		#Define FREDRAW 1
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, TBM_SETRANGEMAX, FREDRAW, This.ctlMaximum)
		
	ENDPROC

	PROCEDURE _setminimum
		*!* _SetMinimum()
		
		#Define FREDRAW 1
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, TBM_SETRANGEMIN, FREDRAW, This.ctlMinimum)
		
	ENDPROC

	PROCEDURE _setorientation
		*!* _SetOrientation
		
		Local ;
			dwStyle As Integer, ;
			lnOrientation as Integer, ;
			lnAnchor As Integer, ;
			lnWidth As Integer, ;
			llVisible As Boolean
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		m.dwStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
		
		m.lnOrientation = Min(Max(This.ctlOrientation, CTLORIENTATION_HORIZONTAL), CTLORIENTATION_VERTICAL)
		
		m.lnAnchor = This.Anchor
		m.llVisible = This.ctlVisible
		
		This.ctlVisible = FALSE
		This.Anchor = 0
		
		If m.lnOrientation = CTLORIENTATION_HORIZONTAL Then
			m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_VERT), TBS_VERT)
			m.dwStyle = Bitor(m.dwStyle, TBS_HORZ)
		Else
			m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_HORZ), TBS_HORZ)
			m.dwStyle = Bitor(m.dwStyle, TBS_VERT)
		Endif
		
		m.lnWidth = This.Width
		
		This.Width = This.Height
		This.Height = m.lnWidth
		
		This.Anchor = m.lnAnchor
		
		*!* This will also restore the visible bit
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.dwStyle)
		
		
	ENDPROC

	PROCEDURE _setshowtips
		*!* _SetShowTips()
		
		*!* Control must be recreated
		This._Create()
		
	ENDPROC

	PROCEDURE _setsmallchange
		*!* _SetSmallChange()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, TBM_SETLINESIZE, 0, This.ctlSmallChange)
		
	ENDPROC

	PROCEDURE _setthumbsize
		*!* _SetThumbSize()
		
		Local lnThumbSize As Integer
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		If This.ctlThumbSize <= 0 Then
			m.lnThumbSize = This._DefaultThumbSize
		Else
			m.lnThumbSize = This.ctlThumbSize
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, TBM_SETTHUMBLENGTH, m.lnThumbSize, 0)
		
		This._SetAutoSize()
		
	ENDPROC

	PROCEDURE _settickfrequency
		*!* _SetTickFrequency()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, TBM_SETTICFREQ, This.ctlTickFrequency, 0)
		
		*!* Force control redraw if tick frequency is 0, because control does not
		*!* redraw itself in this case
		
		If This.ctlTickFrequency = 0 Then
			apiSendMessageInteger(This._ControlHwnd, WM_SETFOCUS, 0, 0)
		Endif
		
	ENDPROC

	PROCEDURE _settickstyle
		*!* _SetTickStyle()
		
		Local ;
			dwStyle As Integer, ;
			lnTickStyle As Integer
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		m.dwStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
		
		m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_AUTOTICKS), TBS_AUTOTICKS)
		m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_NOTICKS), TBS_NOTICKS)
		m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_TOP), TBS_TOP)
		m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_BOTTOM), TBS_BOTTOM)
		m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_BOTH), TBS_BOTH)
		
		m.lnTickStyle = Min(Max(This.ctlTickStyle, CTLTICKSTYLE_NONE), CTLTICKSTYLE_BOTH)
		
		If This.ctlShowTicks = FALSE Or m.lnTickStyle = CTLTICKSTYLE_NONE Then
			m.dwStyle = Bitor(m.dwStyle, TBS_NOTICKS)
		Else
			m.dwStyle = Bitor(m.dwStyle, TBS_AUTOTICKS)
		Endif
		
		Do Case
		
		Case m.lnTickStyle = CTLTICKSTYLE_TOPLEFT
			m.dwStyle = Bitor(m.dwStyle, TBS_TOP)
		
		Case m.lnTickStyle = CTLTICKSTYLE_BOTTOMRIGHT
			m.dwStyle = Bitor(m.dwStyle, TBS_BOTTOM)
		
		Case m.lnTickStyle = CTLTICKSTYLE_BOTH
			m.dwStyle = Bitor(m.dwStyle, TBS_BOTH)
		
		Endcase
		
		apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.dwStyle)
		
		If This.ctlAutoSize Then
			This._SetAutoSize()
		Endif
		
	ENDPROC

	PROCEDURE _settooltipposition
		*!* _SetToolTipPosition()
		
		*!*	#Define TBTS_TOP                                                     0
		*!*	#Define TBTS_LEFT                                                    1
		*!*	#Define TBTS_BOTTOM                                                  2
		*!*	#Define TBTS_RIGHT                                                   3
		
		Local lnToolTipStyle as Integer
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		m.lnToolTipPosition = Min(Max(This.ctlToolTipPosition, TBTS_TOP), TBTS_RIGHT)
		
		apiSendMessageInteger(This._ControlHwnd, TBM_SETTIPSIDE, m.lnToolTipPosition, 0)
		
		
		
		
	ENDPROC

	PROCEDURE _setvalue
		*!* _SetValue()
		
		DoDefault()
		
		#Define FREDRAW 1
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		If This._EnableUpdates = FALSE
			Return
		Endif
		
		*!* TBS_DOWNISLEFT style just plain does not work!
		
		If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
			apiSendMessageInteger(This._ControlHwnd, TBM_SETPOS, FREDRAW, This.ctlMaximum - This.ctlValue + This.ctlMinimum)
		Else
			apiSendMessageInteger(This._ControlHwnd, TBM_SETPOS, FREDRAW, This.ctlValue)
		Endif
		
		*!* Refresh control
		If This.ctlFocused = FALSE Then
			apiSendMessageInteger(This._ControlHwnd, WM_SETFOCUS, 0, 0)
		Endif
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctl32_updown AS ctl32_controlbase OF "ctl32.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="ctl32_updown.bmp" />

	#INCLUDE "ctl32.h"
	*<DefinedPropArrayMethod>
		*m: ctlmaximum_assign
		*m: ctlminimum_assign
		*m: _setmaximum
		*m: _setminimum
		*p: ctllargechange		&& Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
		*p: ctlmaximum		&& Gets or sets the upper limit of values of the scrollable range.
		*p: ctlminimum		&& Gets or sets the lower limit of values of the scrollable range.
		*p: ctlsmallchange		&& Gets or sets the value to be added to or subtracted from the Value property when the scroll box is moved a small distance.
	*</DefinedPropArrayMethod>

	ctllargechange = 10		&& Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
	ctlmaximum = 100		&& Gets or sets the upper limit of values of the scrollable range.
	ctlminimum = 0		&& Gets or sets the lower limit of values of the scrollable range.
	ctlsmallchange = 1		&& Gets or sets the value to be added to or subtracted from the Value property when the scroll box is moved a small distance.
	Height = 18
	Name = "ctl32_updown"
	Width = 84
	ctlTextBox.Name = "ctlTextBox"
	lblname.Caption = "ctl32_updown"
	lblname.Name = "lblname"
	
	PROCEDURE ctldefaultheight_access
		*!* ctlDefaultHeight_Access()
		
		Local ;
			lnHeight As Integer
		
		If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
			m.lnHeight = SYSMETRIC(8)
		Else
			m.lnHeight = SYSMETRIC(8) * 2
		Endif
		
		Return m.lnHeight
		
	ENDPROC

	PROCEDURE ctldefaultwidth_access
		*!* ctlDefaultWidth_Access()
		
		Local ;
			lnWidth As Integer
		
		If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
			m.lnWidth = Sysmetric(5) * 2
		Else
			m.lnWidth = Sysmetric(5)
		Endif
		
		Return m.lnWidth
		
	ENDPROC

	PROCEDURE ctlmaximum_assign
		*!* ctlMaximum_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlMaximum # m.tuNewValue Then
			This.ctlMaximum = m.tuNewValue
			This._SetMaximum()
		Endif
		
	ENDPROC

	PROCEDURE ctlminimum_assign
		*!* ctlMinimum_Assign()
		
		Lparameters m.tuNewValue
		
		If This.ctlMinimum # m.tuNewValue Then
			This.ctlMinimum = m.tuNewValue
			This._SetMinimum()
		Endif
		
	ENDPROC

	PROCEDURE _bindevents
		*!* _BindEvents()
		
		DoDefault()
		
		Bindevent(This.ctlHostFormhWnd, WM_HSCROLL, Thisform.BindWindowsEventsProxy, "_MsgHandler", 4)
		Bindevent(This.ctlHostFormhWnd, WM_VSCROLL, Thisform.BindWindowsEventsProxy, "_MsgHandler", 4)
		
	ENDPROC

	PROCEDURE _formmessagehandler
		*!* _FormMessageHandler()
		
		DoDefault()
		
		Local ;
			m.lnValue As Integer, ;
			m.lnRequest As Integer
		
		Do Case
		
			Case Thisform.BindWindowsEventsProxy._Msg = WM_HSCROLL Or Thisform.BindWindowsEventsProxy._Msg = WM_VSCROLL
		
				If Thisform.BindWindowsEventsProxy._lParam = This._ControlHwnd Then
		
					This._EnableUpdates = FALSE
					This.ctlValue = apiSendMessageInteger(This._ControlHwnd, UDM_GETPOS32, 0, 0)
					This._EnableUpdates = TRUE
				Endif
		
		Endcase
	ENDPROC

	PROCEDURE _getdefaultsize
		*!* _GetDefaultSize()
		
		This._DefaultHeight = This.Height
		This._DefaultWidth = This.Width
		
	ENDPROC

	PROCEDURE _getdwstyle
		*!* _GetdwStyle()
		
		Local dwStyle As Integer
		
		m.dwStyle = Bitor(WS_CHILD, WS_CLIPSIBLINGS, UDS_HOTTRACK)
		
		*!* Orientation
		If This.ctlOrientation = 0  Then
			m.dwStyle = Bitor(m.dwStyle, UDS_HORZ)
		Endif
		
		Return m.dwStyle
		
	ENDPROC

	PROCEDURE _getlpclassname
		*!* _GetlpClassName()
		
		Return UPDOWN_CLASSA
		
	ENDPROC

	PROCEDURE _postcreate
		This._SetMaximum()
		
		This._SetAutoSize()
	ENDPROC

	PROCEDURE _setautosize
		*!* _SetAutosize()
		
		Local lnAnchor As Integer
		
		m.lnAnchor = This.Anchor
		
		This.Anchor = 0
		
		If This.ctlAutoSize = TRUE Then
		
			*!* Save previous dimensions
			This._DefaultHeight = This.Height
			This._DefaultWidth = This.Width
		
			This.Width = This.ctlDefaultWidth
			This.Height = This.ctlDefaultHeight
		
		Else
		
			This.Width = This._DefaultWidth
			This.Height = This._DefaultHeight
		
			*!* _http://support.microsoft.com/kb/180077/en-us/
			*!* PRB: Cannot Change Width of Vertical Up-Down Control
			If This._ControlHwnd # 0 And This.ctlOrientation = CTLORIENTATION_VERTICAL Then
				Local ;
					lhwnd As Integer, ;
					lhWndInsertAfter As Integer, ;
					lx As Integer, ;
					ly As Integer, ;
					lcx As Integer, ;
					lcy As Integer, ;
					lwFlags As Integer
		
				m.lhwnd 			= This._ControlHwnd
				m.lhWndInsertAfter 	= 0
				m.lx 				= This.ctlLocationLeft
				m.ly  				= This.ctlLocationTop
				m.lcx 				= This.Width
				m.lcy 				= This.Height
				m.lwFlags 			= SWP_NOZORDER
		
				apiSetWindowPos( ;
					m.lhwnd, ;
					m.lhWndInsertAfter,;
					m.lx, ;
					m.ly, ;
					m.lcx, ;
					m.lcy, ;
					m.lwFlags)
		
			Endif
		Endif
		
		This.Anchor = m.lnAnchor
		
	ENDPROC

	PROCEDURE _setbackcolor
		*!* _SetBackColor()
		
		This._CreateBackGroundBrush()
		This.ctlRefresh()
		
	ENDPROC

	PROCEDURE _setmaximum
		*!* _SetMaximum()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, UDM_SETRANGE32, This.ctlMinimum, This.ctlMaximum)
		
		
	ENDPROC

	PROCEDURE _setminimum
		*!* _SetMinimum()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, UDM_SETRANGE32, This.ctlMinimum, This.ctlMaximum)
		
		
	ENDPROC

	PROCEDURE _setvalue
		*!* _SetValue()
		
		DoDefault()
		
		If This._ControlHwnd = 0
			Return
		Endif
		
		If This._EnableUpdates = FALSE
			Return
		Endif
		
		apiSendMessageInteger(This._ControlHwnd, UDM_SETPOS32, 0, This.ctlValue)
		
		
	ENDPROC

ENDDEFINE
