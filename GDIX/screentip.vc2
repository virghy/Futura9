*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="screentip.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS screentip AS control 
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="tmrShow" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrHide" UniqueID="" Timestamp="" />

	#INCLUDE "themedcontrols.h"
	*<DefinedPropArrayMethod>
		*m: changetheme
		*m: colortorgb
		*m: createwindow
		*m: drawbackground
		*m: drawroundedrect
		*m: drawscreentip
		*m: drawshadow
		*m: drawtext
		*m: fadewindow
		*m: hide		&& Hides a Form, FormSet, or ToolBar by setting the Visible property to false (.F.).
		*m: hideinterval_assign
		*m: initthemedcontrol
		*m: opacitystep_access
		*m: setwindowposition
		*m: setwindowtransparency
		*m: show		&& Displays a Form and specifies if the Form is modal or modeless.
		*m: showinterval_assign
		*m: showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		*p: effects
		*p: endbackcolor
		*p: hideinterval
		*p: hwnd		&& Specifies the Window handle of the Window.
		*p: image
		*p: imgbackground
		*p: initialized
		*p: margin		&& Specifies the margin width created in the text portion of the control.
		*p: maxwidth		&& Specifies the maximum width the Form can be resized to.
		*p: opacitystep
		*p: roundfactor
		*p: shadowcolor
		*p: shadowdistance
		*p: shadowlength
		*p: showinterval
		*p: startbackcolor
		*p: text		&& Returns all of the text in a text-entry area of a control.
		*p: title
		*p: type		&& Display ScreenTip at [1] mouse X and Y pos or [2] left bottom pos of active control.
		*p: version
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN effects,hwnd,image,imgbackground,margin,maxwidth,opacitystep,roundfactor,shadowdistance,shadowlength,text,title,type
	PROTECTED Init
	endbackcolor = .F.
	Height = 23
	hideinterval = 0
	hwnd = 0		&& Specifies the Window handle of the Window.
	image = ("")
	imgbackground = ("")
	initialized = .F.
	margin = 1		&& Specifies the margin width created in the text portion of the control.
	maxwidth = 194		&& Specifies the maximum width the Form can be resized to.
	Name = "screentip"
	opacitystep = 0
	roundfactor = 6
	shadowcolor = .F.
	shadowdistance = 5
	shadowlength = 3
	showinterval = 0
	startbackcolor = .F.
	text = ("")		&& Returns all of the text in a text-entry area of a control.
	title = ("")
	type = 1		&& Display ScreenTip at [1] mouse X and Y pos or [2] left bottom pos of active control.
	version = 3.5.7
	Visible = .F.
	Width = 46
	_memberdata = <VFPData>
		<memberdata name="changetheme" type="method" display="ChangeTheme"/>
		<memberdata name="initthemedcontrol" type="method" display="InitThemedControl"/>
		<memberdata name="endbackcolor" type="property" display="EndBackcolor"/>
		<memberdata name="startbackcolor" type="property" display="StartBackcolor"/>
		<memberdata name="shadowcolor" type="property" display="ShadowColor"/>
		<memberdata name="version" type="property" display="Version"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'tmrHide' AS timer WITH ;
		Height = 23, ;
		Left = 22, ;
		Name = "tmrHide", ;
		Top = 0, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'tmrShow' AS timer WITH ;
		Height = 23, ;
		Left = 0, ;
		Name = "tmrShow", ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE changetheme
		With _Screen.ThemesManager
		   This.StartBackColor = .GetMember("ScreenTip.StartBackColor")
		   This.EndBackColor = .GetMember("ScreenTip.EndBackColor")
		   This.BorderColor = .GetMember("ScreenTip.BorderColor")
		   This.ShadowColor = .GetMember("ScreenTip.ShadowColor")
		Endwith
	ENDPROC

	PROCEDURE colortorgb
		Lparameters tnColor, tnR, tnG, tnB
		* nColor = nR + nG*256 + nB*256*256
		tnR = Bitand(tnColor, 0xFF)
		tnG = Bitand(Bitrshift(tnColor, 8), 0xFF)
		tnB = Bitand(Bitrshift(tnColor, 16), 0xFF)
	ENDPROC

	HIDDEN PROCEDURE createwindow
		Local lnParentHwnd, lcClass, lnSize, lnExStyle, lnStyle, lnHwnd
		lnParentHwnd = apiGetActiveWindow()
		lcClass = Space(250)
		lnSize = apiRealGetWindowClass(lnParentHwnd, @lcClass, Len(lcClass))
		lcClass = Strtran(Substr(lcClass, 1,lnSize), Chr(0), "")
		lnExStyle = WS_EX_TOPMOST + WS_EX_LAYERED + WS_EX_TRANSPARENT + WS_EX_NOACTIVATE
		lnStyle = WS_DISABLED
		lnHwnd = apiCreateWindowEx (lnExStyle, lcClass, "", lnStyle, 0, 0, 0, 0, lnParentHwnd, 0, 0, 0)
		This.HWnd = lnHwnd
	ENDPROC

	HIDDEN PROCEDURE drawbackground
		Lparameters lnHeight, lnWidth, lcTitle, lcText, lcScreenshot
		Local lcImage, llImage, ;
		   loBmp As xfcBitmap, ;
		   loGfx As xfcGraphics, ;
		   lnTop, lnLeft, lnHeight, lnWidth
		Store 0 To lnTop, lnLeft
		With _Screen.System.Drawing As xfcDrawing
		   * Create a new bitmap
		   loBmp = .Bitmap.New(lnWidth, lnHeight, .Imaging.PixelFormat.Format32bppARGB)
		
		   * Get a Graphics object for drawing
		   loGfx = .Graphics.FromImage(loBmp)
		
		   loGfx.SmoothingMode = .Drawing2D.SmoothingMode.AntiAlias
		
		   * Draw the shadow
		   This.DrawShadow(loGfx, ;
		      This.Margin + lnLeft + This.ShadowDistance, ;
		      This.Margin + lnTop + This.ShadowDistance, ;
		      lnWidth - This.Margin - This.ShadowDistance - 1, ;
		      lnHeight - This.Margin - This.ShadowDistance - 1, ;
		      This.RoundFactor)
		
		   * Draw the rounded rectangle
		   Local lnStartR, lnStartG, lnStartB, ;
		      lnEndR, lnEndG, lnEndB, ;
		      lnBorderR, lnBorderG, lnBorderB
		   This.ColorToRGB(This.StartBackcolor,@lnStartR,@lnStartG,@lnStartB)
		   This.ColorToRGB(This.EndBackcolor,@lnEndR,@lnEndG,@lnEndB)
		   This.ColorToRGB(This.BorderColor,@lnBorderR,@lnBorderG,@lnBorderB)
		   This.DrawRoundedRect(loGfx, ;
		      .Color.FromRGB(lnStartR, lnStartG, lnStartB), ;
		      .Color.FromRGB(lnEndR, lnEndG, lnEndB), ;
		      .Color.FromRGB(lnBorderR, lnBorderG, lnBorderB), ;
		      This.Margin + lnLeft, ;
		      This.Margin + lnTop, ;
		      lnWidth - This.Margin - This.ShadowLength - 1, ;
		      lnHeight - This.Margin - This.ShadowLength - 1, ;
		      This.RoundFactor)
		
		   * Draw the image
		   If Not Empty(lcScreenshot) And ;
		         File(lcScreenshot)
		      Local loImage As xfcBitmap
		      loImage = .Bitmap.FromFile(lcScreenshot)
		      loGfx.DrawImage(loImage,6,30,110,128)
		      loImage = Null
		      llImage = .T.
		   Endif
		
		   * Draw the title and the text
		   This.DrawText(loGfx, lcTitle, lcText, llImage)
		
		   * Save image to file
		   lcImage = Addbs(_Screen.ThemesManager.TempFolder) + "ScreenTip_Background.Png"
		   loBmp.Save(lcImage, .Imaging.ImageFormat.Png)
		   This.imgBackground = lcImage
		
		   Store Null To loBmp, loGfx
		Endwith
	ENDPROC

	HIDDEN PROCEDURE drawroundedrect
		Lparameters toGfx As xfcGraphics, ;
		   loStartGradColor As xfcColor, ;
		   loEndGradColor As xfcColor, ;
		   loBorderColor As xfcColor, ;
		   tnX, tnY, tnWidth, tnHeight, ;
		   tnRadius)
		Local loGPath As xfcGraphicsPath, ;
		   loLinearGradientBrush As xfcLinearGradientBrush
		With _Screen.System.Drawing
		   loGPath = .Drawing2D.GraphicsPath.New()
		   With loGPath
		      .AddArc(tnX, tnY, tnRadius, tnRadius, 180, 90) && Upper left corner
		      .AddArc(tnX+tnWidth - tnRadius, tnY, tnRadius, tnRadius, 270, 90) && Upper right corner
		      .AddArc(tnX+tnWidth - tnRadius, tnY+tnHeight - tnRadius, tnRadius, tnRadius, 0, 90) && Lower right corner
		      .AddArc(tnX, tnY+tnHeight - tnRadius, tnRadius, tnRadius, 90, 90) && Lower left corner
		      .CloseFigure()
		   Endwith
		   loLinearGradientBrush = .Drawing2D.LinearGradientBrush.New(.Rectangle.New(tnX,tnY,tnWidth,tnHeight), loStartGradColor, loEndGradColor, 90, .F.)
		   toGfx.FillPath(loLinearGradientBrush, loGPath)
		   toGfx.DrawPath(.Pen.New(loBorderColor, 1), loGPath)
		   Store Null To ;
		      loGPath, ;
		      loLinearGradientBrush, ;
		      loStartGradColor, ;
		      loEndGradColor, ;
		      loBorderColor
		Endwith
	ENDPROC

	HIDDEN PROCEDURE drawscreentip
		Lparameters lcTitle, lcText, lcImage
		Local lnHeight, lnWidth
		If Not Empty(lcTitle) And ;
		      Not Empty(lcText) And ;
		      Not Empty(lcImage)
		   lnHeight = 165
		   lnWidth = 302
		Else
		   Store 0 To lnHeight, ;
		      lnWidth
		   With _Screen.System.Drawing As xfcDrawing
		      Local ;
		         loBmp As xfcBitmap, ;
		         loGfx As xfcGraphics, ;
		         loFont As xfcFont, ;
		         loSizeTitle As xfcSize, ;
		         loSizeText As xfcSize, ;
		         loStringFormat As xfcStringFormat, ;
		         loMaxSize As xfcSizeF
		      loBmp = .Bitmap.New(1, 1)
		      loGfx = .Graphics.FromImage(loBmp)
		      If Not Empty(lcTitle)
		         loFont = .Font.New("Arial", 8, .FontStyle.Bold)
		         loSizeTitle = loGfx.MeasureString(lcTitle, loFont)
		         lnHeight = loSizeTitle.Height + 2
		         lnWidth = loSizeTitle.Width
		      Endif
		      If Not Empty(lcText)
		         loFont = .Font.New("Arial", 8)
		         loMaxSize = .SizeF.New()
		         loMaxSize.Height = 0
		         loMaxSize.Width = This.MaxWidth
		         loStringFormat = .StringFormat.New()
		         loStringFormat.Alignment = .StringAlignment.Near
		         loStringFormat.FormatFlags = .StringFormatFlags.MeasureTrailingSpaces
		         loSizeText = loGfx.MeasureString(lcText, loFont, loMaxSize, loStringFormat)
		         lnHeight = lnHeight + loSizeText.Height + 2
		         lnWidth = Max(lnWidth, loSizeText.Width)
		      Endif
		      lnHeight = lnHeight + 2
		      lnWidth = lnWidth + 3 + 3
		      Store Null To loFont, loSizeTitle, loSizeText, loMaxSize, loStringFormat, loBmp, loGfx
		   Endwith
		Endif
		lnHeight = This.Margin + lnHeight + This.ShadowLength
		lnWidth = This.Margin + lnWidth + This.ShadowLength
		With This
		   .Height = lnHeight
		   .Width = lnWidth
		   .DrawBackground(lnHeight, lnWidth, lcTitle, lcText, lcImage)
		Endwith
		
	ENDPROC

	HIDDEN PROCEDURE drawshadow
		Lparameters toGfx As xfcGraphics, ;
		   tnX, tnY, tnWidth, tnHeight, ;
		   tnRadius)
		Local loGPath As xfcGraphicsPath
		With _Screen.System.Drawing
		   loGPath = .Drawing2D.GraphicsPath.New()
		   With loGPath
		      .AddArc(tnX, tnY, tnRadius, tnRadius, 180, 90) && Upper left corner
		      .AddArc(tnX+tnWidth - tnRadius, tnY, tnRadius, tnRadius, 270, 90) && Upper right corner
		      .AddArc(tnX+tnWidth - tnRadius, tnY+tnHeight - tnRadius, tnRadius, tnRadius, 0, 90) && Lower right corner
		      .AddArc(tnX, tnY+tnHeight - tnRadius, tnRadius, tnRadius, 90, 90) && Lower left corner
		      .CloseFigure()
		   Endwith
		   Local lnShadowR, lnShadowG, lnShadowB
		   This.ColorToRGB(This.ShadowColor,@lnShadowR,@lnShadowG,@lnShadowB)
		   toGfx.FillPath(.SolidBrush.New(.Color.FromArgb(180, lnShadowR, lnShadowG, lnShadowB)), loGPath) && A = 126
		   toGfx.DrawPath(.Pen.New(.Color.FromArgb(95, lnShadowR, lnShadowG, lnShadowB), 1), loGPath) && A = 41
		   Store Null To loGPath
		Endwith
	ENDPROC

	HIDDEN PROCEDURE drawtext
		Lparameters loGfx, lcTitle, lcText, llImage
		With _Screen.System.Drawing
		   Local ;
		      lnTop, ;
		      loFont As xfcFont, ;
		      loSize As xfcSize, ;
		      loBrush As xfcSolidBrush, ;
		      loRect As xfcRectangleF, ;
		      loStringFormat As xfcStringFormat, ;
		      loMaxSize As xfcSizeF
		   lnTop = 2
		   loBrush = .SolidBrush.New(.Color.FromRGB(76,76,76))
		   If Not Empty(lcTitle)
		      loFont = .Font.New("Arial", 8, .FontStyle.Bold)
		      loSize = loGfx.MeasureString(lcTitle, loFont)
		      If llImage
		         loRect = .RectangleF.New(7, 10, loSize.Width, loSize.Height)
		      Else
		         loRect = .RectangleF.New(3, lnTop, loSize.Width, loSize.Height)
		      Endif
		      loGfx.DrawString(lcTitle, loFont, loBrush, loRect)
		      lnTop = lnTop + loSize.Height + 2
		   Endif
		   If Not Empty(lcText)
		      loFont = .Font.New("Arial", 8)
		      loMaxSize = .SizeF.New()
		      loMaxSize.Height = 0
		      loMaxSize.Width = This.MaxWidth
		      loStringFormat = .StringFormat.New()
		      loStringFormat.Alignment = .StringAlignment.Near
		      loStringFormat.FormatFlags = .StringFormatFlags.MeasureTrailingSpaces
		      If llImage
		         loRect = .RectangleF.New(123, 32, 170, 125)
		      Else
		         loSize = loGfx.MeasureString(lcText, loFont, loMaxSize, loStringFormat)
		         loRect = .RectangleF.New(3, lnTop, loSize.Width, loSize.Height)
		      Endif
		      loGfx.DrawString(lcText, loFont, loBrush, loRect, loStringFormat)
		   Endif
		   Store Null To loFont, loSize, loMaxSize, loStringFormat, loBrush, loRect
		Endwith
	ENDPROC

	HIDDEN PROCEDURE fadewindow
		Lparameters lcAction
		Local lnInitialOpacity, lnFinalOpacity, lnStep, loBlend, lnOpacity, lcBlend
		If lcAction=="IN"
		   lnInitialOpacity = 1
		   lnFinalOpacity = 255
		   lnStep = This.OpacityStep
		Else
		   lnInitialOpacity = 255
		   lnFinalOpacity = 1
		   lnStep = (This.OpacityStep * -1)
		Endif
		loBlend = Createobject('VFP_BLENDFUNCTION')
		loBlend.fld['BlendOp'] = AC_SRC_OVER
		loBlend.fld['BlendFlags'] = 0
		loBlend.fld['AlphaFormat'] = AC_SRC_ALPHA
		For lnOpacity=lnInitialOpacity To lnFinalOpacity Step lnStep
		   loBlend.fld['SourceConstantAlpha'] = lnOpacity
		   lcBlend = loBlend.Structure
		   apiUpdateLayeredWindow(This.HWnd, 0, 0, 0, 0, 0, 0, @lcBlend, ULW_ALPHA)
		   apiSleep(1)
		Endfor
		If Not Mod(255,Abs(lnStep))==0
		   loBlend.fld['SourceConstantAlpha'] = lnFinalOpacity
		   lcBlend = loBlend.Structure
		   apiUpdateLayeredWindow(This.HWnd, 0, 0, 0, 0, 0, 0, @lcBlend, ULW_ALPHA)
		   apiSleep(1)
		Endif
		loBlend = Null
	ENDPROC

	PROCEDURE hide		&& Hides a Form, FormSet, or ToolBar by setting the Visible property to false (.F.).
		With This
		   .ShowInterval = 0
		   .HideInterval = 0
		   If .Initialized
		      *
		      If .Effects
		         * Fade out ScreenTip window
		         .FadeWindow("OUT")
		      Endif
		      * Hide ScreenTip window
		      apiShowWindow(.HWnd, SW_HIDE)
		      * Destroy ScreenTip window
		      apiDestroyWindow(.HWnd)
		   Endif
		   .Initialized = .F.
		Endwith
	ENDPROC

	HIDDEN PROCEDURE hideinterval_assign
		Lparameters vNewVal
		Store m.vNewVal To ;
			This.HideInterval, ;
			This.tmrHide.Interval
	ENDPROC

	PROTECTED PROCEDURE Init
		* If OS is Windows 2000 or higher, turn effects on
		This.Effects = ctlGetOsVersion()>=NTDDI_WIN2K
		This.InitThemedControl()
	ENDPROC

	HIDDEN PROCEDURE initthemedcontrol
		If Not Vartype(_Screen.ThemesManager)=="O"
		   _Screen.Newobject("ThemesManager","ThemesManager",Forcepath('ThemedControls.vcx', Justpath(This.ClassLibrary)))
		Endif
		This.ChangeTheme()
	ENDPROC

	HIDDEN PROCEDURE opacitystep_access
		Local lnStep
		If This.OpacityStep==0 && Auto
		   lnStep = 25
		Else && Manual
		   lnStep = This.OpacityStep
		Endif
		Return lnStep
	ENDPROC

	HIDDEN PROCEDURE setwindowposition
		Local lnLeft, lnTop
		Store 0 To lnLeft, lnTop
		If This.Type==1 && Display at mouse X and Y pos
		   Local lcPoint
		   m.lcPoint = Space(8)
		   apiGetCursorPos(@m.lcPoint)
		   lnLeft = ctlGetXFromPoint(m.lcPoint)
		   lnTop = ctlGetYFromPoint(m.lcPoint) + ;
		      (apiGetSystemMetrics(SM_CXCURSOR)*0.68)
		Else && Display at left bottom pos of active control
		   Local loControl, llInsideRibbon
		   loControl = Sys(1270)
		   If Vartype(loControl)=="O"
		      If Pemstatus(loControl,"Height",5)
		         lnTop = lnTop + loControl.Height
		      Endif
		      Do While .T.
		         If Upper(loControl.BaseClass)=="FORM"
		            Do Case
		               Case loControl.TitleBar==1
		                  lnTop = lnTop + Sysmetric(9)
		                  lnTop = lnTop + Sysmetric(4)
		               Case Pemstatus(loControl,"SumEvenIfTitleBarIsOff",5)
		                  lnTop = lnTop + loControl.Top
		            Endcase
		            Do Case
		               Case loControl.BorderStyle==0 && No border
		                  lnLeft = lnLeft + Sysmetric(10)
		               Case loControl.BorderStyle==3 && Sizeable
		                  lnLeft = lnLeft + Sysmetric(3)
		               Otherwise && Fixed single ou fixed dialog
		                  lnLeft = lnLeft + Sysmetric(12)
		            Endcase
		         Endif
		         If Pemstatus(loControl,"Left",5)
		            lnLeft = lnLeft + loControl.Left
		         Endif
		         If Pemstatus(loControl,"ShowScreenTipAtBottom",5)
		            llInsideRibbon = .T.
		            lnLeft = lnLeft - 2
		            lnTop = loControl.Top + loControl.Height
		         Else
		            If Not llInsideRibbon And ;
		                  Pemstatus(loControl,"Top",5)
		               lnTop = lnTop + loControl.Top
		            Endif
		         Endif
		         If Type("loControl.Parent")=="O"
		            loControl = loControl.Parent
		         Else
		            Exit
		         Endif
		      Enddo
		   Endif
		   loControl = Null
		Endif
		With This
		   .Left = lnLeft
		   .Top = lnTop
		Endwith
	ENDPROC

	HIDDEN PROCEDURE setwindowtransparency
		With This
		   Local loPointSource, loTopPos, loSize, loBlend
		   loPointSource = Createobject('VFP_POINT')
		   loTopPos = Createobject('VFP_POINT')
		   loSize = Createobject('VFP_SIZE')
		   loBlend = Createobject('VFP_BLENDFUNCTION')
		
		   Local screenDc, memDc, hBitmap, oldBitmap, loBitmap As xfcBitmap
		   screenDc = apiGetDC(0)
		   memDc = apiCreateCompatibleDC(screenDc)
		   hBitmap = 0
		   oldBitmap = 0
		
		   loBitmap = _Screen.System.Drawing.Bitmap.New(.imgBackground)
		   hBitmap = loBitmap.GetHbitmap(_Screen.System.Drawing.Color.FromArgb(0))
		   oldBitmap = apiSelectObject(memDc, hBitmap)
		
		   loSize.fld['cx'] = loBitmap.Width
		   loSize.fld['cy'] = loBitmap.Height
		
		   loTopPos.fld['x'] = .Left
		   loTopPos.fld['Y'] = .Top
		
		   loBlend.fld['BlendOp'] = AC_SRC_OVER
		   loBlend.fld['BlendFlags'] = 0
		   loBlend.fld['SourceConstantAlpha'] = 0 && Opacity: 0 to 255
		   loBlend.fld['AlphaFormat'] = AC_SRC_ALPHA
		
		   Local lcTopPos, lcSize, lcPointSource, lcBlend
		   lcTopPos = loTopPos.Structure
		   lcSize = loSize.Structure
		   lcPointSource = loPointSource.Structure
		   lcBlend = loBlend.Structure
		
		   apiUpdateLayeredWindow(.HWnd, screenDc, @lcTopPos, @lcSize, memDc, @lcPointSource, 0, @lcBlend, ULW_ALPHA)
		
		   apiReleaseDC(0, screenDc)
		   If (hBitmap != 0)
		      apiSelectObject(memDc, oldBitmap)
		      apiDeleteObject(hBitmap)
		   Endif
		   apiDeleteDC(memDc)
		
		   Store Null To loBitmap
		
		   Store Null To loPointSource, loTopPos, loSize, loBlend
		Endwith
	ENDPROC

	PROCEDURE show		&& Displays a Form and specifies if the Form is modal or modeless.
		Lparameters lcTitle, lcText, lcImage, lnType
		If Not Empty(lcTitle) Or ;
		      Not Empty(lcText) Or ;
		      Not Empty(lcImage)
		   With This
		      .Title = lcTitle
		      .Text = lcText
		      .Image = lcImage
		      .Type = Evl(lnType,.Type)
		      .HideInterval = 0
		      .ShowInterval = 900
		   Endwith
		Endif
	ENDPROC

	HIDDEN PROCEDURE showinterval_assign
		Lparameters vNewVal
		Store m.vNewVal To ;
			This.ShowInterval, ;
			This.tmrShow.Interval
	ENDPROC

	PROCEDURE showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		With This
		   * Create a window to host the ScreenTip
		   .CreateWindow()
		   * Set ScreenTip window position
		   .SetWindowPosition()
		   * Draw the ScreenTip to an image file
		   .DrawScreenTip(.Title, .Text, .Image)
		   *
		   * Show ScreenTip window
		   If .Effects
		      * Set ScreenTip window transparency
		      .SetWindowTransparency()
		   Endif
		   * Show ScreenTip window
		   apiShowWindow(.HWnd, SW_SHOWNA)
		   *
		   If .Effects
		      * Fade in ScreenTip window
		      .FadeWindow("IN")
		   Endif
		   *
		   .Initialized = .T.
		Endwith
	ENDPROC

	PROCEDURE tmrHide.Timer
		This.Parent.Hide()
	ENDPROC

	PROCEDURE tmrShow.Timer
		This.Interval = 0
		This.Parent.ShowWindow()
		This.Parent.HideInterval = 20000
	ENDPROC

ENDDEFINE
