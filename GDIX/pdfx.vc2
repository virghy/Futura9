*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="pdfx.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfasimagelistener AS reportlistener 		&& Listener to Create PDF Files as Images
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "hpdf_consts.h"
	*<DefinedPropArrayMethod>
		*m: addblankpage
		*m: cleardlls
		*m: declaredll		&& Method to Start Dll Declarations
		*m: encryptpdf		&& Method to Encrypt the Pdf Document
		*m: shellexec
		*m: startpdfdocument		&& Method to start pdf generation
		*m: writepdfinformation		&& Writes Information About the File
		*p: cmasterpassword		&& Master Password of the Pdf Document
		*p: cpdfauthor		&& Pdf Author
		*p: cpdfcreator		&& Pdf Creator
		*p: cpdfkeywords		&& Pdf Keywords
		*p: cpdfsubject		&& Pdf Subject
		*p: cpdftitle		&& Pdf Title
		*p: ctargetfilename
		*p: cuserpassword		&& User Pasword of the Document
		*p: encryptdocument		&& Property to Know if the Document Will Be Encrypted
		*p: lcanaddnotes
		*p: lcancopy
		*p: lcanedit
		*p: lcanprint		&& If .T. User will be allowed to print the document, if 0 he won't
		*p: lencryptdocument
		*p: lopenviewer		&& If .T. Adobe Reader will be opened
		*p: mergedocument
		*p: mergedocumentname
		*p: nencryptionlevel		&& Accepts a Value of 0 Or 1, 0 = Standard 40-bit encryption. 1 = Advanced 128-bit encryption.
		*p: npageheight
		*p: oimagescollection		&& Collection of images files used in the report
		*p: opage		&& Property to Store the Page Object
		*p: oprogress		&& Property to Store Progress Bar
		*p: oregistry
		*p: pageheight		&& Height of The Report Pages
		*p: pagewidth		&& Width of Report Pages
		*p: pdfhandle		&& Handle for the Pdf Document To Generate
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cmasterpassword = 		&& Master Password of the Pdf Document
	cpdfauthor = 		&& Pdf Author
	cpdfcreator = 		&& Pdf Creator
	cpdfkeywords = 		&& Pdf Keywords
	cpdfsubject = 		&& Pdf Subject
	cpdftitle = 		&& Pdf Title
	ctargetfilename = 
	cuserpassword = 		&& User Pasword of the Document
	encryptdocument = .F.		&& Property to Know if the Document Will Be Encrypted
	FRXDataSession = -1
	Height = 23
	lcanaddnotes = .F.
	lcancopy = .T.
	lcanedit = .F.
	lcanprint = .T.		&& If .T. User will be allowed to print the document, if 0 he won't
	lencryptdocument = .F.
	ListenerType = 2
	lopenviewer = .F.		&& If .T. Adobe Reader will be opened
	mergedocument = .F.
	mergedocumentname = 
	Name = "pdfasimagelistener"
	nencryptionlevel = 5		&& Accepts a Value of 0 Or 1, 0 = Standard 40-bit encryption. 1 = Advanced 128-bit encryption.
	npageheight = 0
	oimagescollection = .NULL.		&& Collection of images files used in the report
	opage = .NULL.		&& Property to Store the Page Object
	oprogress = .F.		&& Property to Store Progress Bar
	oregistry = .F.
	pageheight = 0		&& Height of The Report Pages
	pagewidth = 0		&& Width of Report Pages
	pdfhandle = 0		&& Handle for the Pdf Document To Generate
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="pdfhandle" type="property" display="PdfHandle"/>
		<memberdata name="pageheight" type="property" display="PageHeight"/>
		<memberdata name="pagewidth" type="property" display="PageWidth"/>
		<memberdata name="encryptdocument" type="property" display="EncryptDocument"/>
		<memberdata name="oprogress" type="property" display="oProgress"/>
		<memberdata name="oregistry" type="property" display="oRegistry"/>
		<memberdata name="mergedocument" type="property" display="MergeDocument"/>
		<memberdata name="mergedocumentname" type="property" display="MergeDocumentName"/>
		<memberdata name="opage" type="property" display="oPage"/>
		<memberdata name="oimagescollection" type="property" display="oImagesCollection"/>
		<memberdata name="cpdfauthor" type="property" display="cPdfAuthor"/>
		<memberdata name="cuserpassword" type="property" display="cUserPassword"/>
		<memberdata name="lencryptdocument" type="property" display="lEncryptDocument"/>
		<memberdata name="nencryptionlevel" type="property" display="nEncryptionLevel"/>
		<memberdata name="addblankpage" type="method" display="AddBlankPage"/>
		<memberdata name="npageheight" type="property" display="nPageHeight"/>
		<memberdata name="lcanedit" type="property" display="lCanEdit"/>
		<memberdata name="lcancopy" type="property" display="lCanCopy"/>
		<memberdata name="lcanaddnotes" type="property" display="lCanAddNotes"/>
		<memberdata name="lcanprint" type="property" display="lCanPrint"/>
		<memberdata name="cleardlls" type="method" display="ClearDLLS"/>
		<memberdata name="encryptpdf" type="method" display="EncryptPdf"/>
		<memberdata name="shellexec" type="method" display="ShellExec"/>
		<memberdata name="startpdfdocument" type="method" display="StartPdfDocument"/>
		<memberdata name="writepdfinformation" type="method" display="WritePdfInformation"/>
		<memberdata name="lopenviewer" type="property" display="lOpenViewer"/>
		<memberdata name="cmasterpassword" type="property" display="cMasterPassword"/>
		<memberdata name="ctargetfilename" type="property" display="cTargetFileName"/>
		<memberdata name="declaredll" type="method" display="DeclareDll"/>
		<memberdata name="cpdfcreator" type="property" display="cPdfCreator"/>
		<memberdata name="cpdfkeywords" type="property" display="cPdfKeyWords"/>
		<memberdata name="cpdfsubject" type="property" display="cPdfSubject"/>
		<memberdata name="cpdftitle" type="property" display="cPdfTitle"/>
		<memberdata name="previewcontainer" type="property" display="PreviewContainer"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addblankpage
		With This
			.oPage=HPDF_AddPage(.pdfHandle) &&Add a New Page
			HPDF_Page_SetWidth(.oPage,(.GetPageWidth()/960)*72) &&Establish the Width of the page
			.nPageHeight=(.GetPageHeight()/960)*72
			HPDF_Page_SetHeight(.oPage, .nPageHeight) &&Establish the Height of the page
		EndWith
	ENDPROC

	PROCEDURE AfterReport
		DoDefault()
		With This
			HPDF_SaveToFile(.pdfHandle,.cTargetFileName)
			HPDF_Free(.pdfHandle)
			If .lOpenViewer Then
				.ShellExec(.cTargetFileName)
			EndIf
		EndWith
	ENDPROC

	PROCEDURE BeforeReport
		This.oImagesCollection=CreateObject("Collection")
		This.DeclareDLL()
	ENDPROC

	PROCEDURE cleardlls
		Clear Dlls "HPDF_New,HPDF_Free","HPDF_SaveToFile","HPDF_SetPageMode","HPDF_AddPage","HPDF_Page_SetWidth","HPDF_Page_SetHeight",;
		"HPDF_LoadJpegImageFromFile","HPDF_SetInfoAttr","HPDF_SetPassword","HPDF_SetPermission","HPDF_SetEncryptionMode",;
		"HPDF_SetCompressionMode","HPDF_Page_Concat","HPDF_Page_DrawImage"
	ENDPROC

	PROCEDURE declaredll		&& Method to Start Dll Declarations
		Declare Integer HPDF_New In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Free In libhpdf.dll Integer
		Declare Integer HPDF_SaveToFile In libhpdf.dll Integer, String
		Declare Integer HPDF_SetPageMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_AddPage In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetWidth In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetHeight In libhpdf.dll Integer, Single
		Declare Integer HPDF_LoadJpegImageFromFile In libhpdf.dll Integer, String
		Declare Integer HPDF_SetInfoAttr In  libhpdf.dll Integer, Integer, String
		Declare Integer HPDF_SetPassword In  libhpdf.dll Integer, String, String
		Declare Integer HPDF_SetPermission In libhpdf.dll Integer, Integer
		Declare Integer HPDF_SetEncryptionMode In libhpdf.dll Integer, Integer, Integer
		Declare Integer HPDF_SetCompressionMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Page_Concat In libhpdf.dll Integer, Single, Single, Single, Single, Single, Single
		Declare Integer HPDF_Page_DrawImage In libhpdf.dll Integer, Integer, Single, Single, Single, Single
	ENDPROC

	PROCEDURE encryptpdf		&& Method to Encrypt the Pdf Document
		With This
			If .lEncryptDocument Then &&Protect the document with password
				If !Empty(.cMasterPassword) Then
					If .cMasterPassword!=.cUserPassword Then &&User Password and Master Password can't be the same
						HPDF_SetPassword(.pdfHandle,.cMasterPassword,.cUserPassword)
						Local lnPermit As Integer
						lnPermit=0
						&&Establish PDF files permissions
						If .lCanPrint Then
							lnPermit = lnPermit + HPDF_ENABLE_PRINT
						EndIf
						If .lCanEdit Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT_ALL
						EndIf
						If .lCanCopy Then
							lnPermit = lnPermit + HPDF_ENABLE_COPY
						EndIf
						If .lCanAddNotes Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT
						EndIf
						HPDF_SetPermission(This.pdfHandle,lnPermit)
						If .nEncriptionLevel!=5 Then
							HPDF_SetEncryptionMode(.pdfHandle,HPDF_ENCRYPT_R3,.nEncriptionLevel)
						Else
							HPDF_SetEncryptionMode(.pdfHandle,HPDF_ENCRYPT_R2,.nEncriptionLevel)
						EndIf
					EndIf
				EndIf
			EndIf
		EndWith
	ENDPROC

	PROCEDURE OutputPage
		Lparameters nPageNo, eDevice, nDeviceType, nLeft, nTop, nWidth, nHeight, nClipLeft, nClipTop, nClipWidth, nClipHeight
		#Define OutputNothing -1
		#Define OutputTIFF 101
		#Define OutputTIFFAdditive (OutputTIFF+100)
		#Define OutPutJPEG 102
		#Define COULDNTCREATE "Could Not Create PDF Document"
		Local lnHandle As Integer, lcFile As String
		With This
			If (nDeviceType == OutputNothing) Then
				If nPageNo == 1 Then
					nDeviceType = OutputJPEG && Start JPEG Generation Process
					.DeclareDll()
					.StartPdfDocument()
				Else
					.AddBlankPage() 
					nDeviceType = OutputJPEG && Start JPEG GEneration Process
				EndIf
				lcFile=GetEnv("TEMP")+"\"+Sys(2015)+".Jpg"
				.OutputPage(nPageNo, lcFile, nDeviceType)
				lnHandle=HPDF_LoadJpegImageFromFile(.pdfHandle,lcFile)
				HPDF_Page_DrawImage(.oPage,lnHandle,0,0,(.GetPageWidth()/960)*72,(.GetPageHeight()/960)*72)
				.oImagesCollection.Add(lcFile)
				NoDefault
			EndIf
		EndWith
	ENDPROC

	PROCEDURE shellexec
		Lparameter lcLink, lcAction, lcParms
		lcAction = Iif(Empty(lcAction), "Open", lcAction)
		lcParms = Iif(Empty(lcParms), "", lcParms)
		Declare Integer ShellExecute ;
			In SHELL32.Dll ;
			Integer nWinHandle, ;
			String cOperation, ;
			String cFileName, ;
			String cParameters, ;
			String cDirectory, ;
			Integer nShowWindow
		Declare Integer FindWindow ;
			In WIN32API ;
			String cNull,String cWinName
		Return ShellExecute(FindWindow(0, _Screen.Caption), ;
			lcAction, lcLink, ;
			lcParms, Sys(2023), 1)
	ENDPROC

	PROCEDURE startpdfdocument		&& Method to start pdf generation
		With This
			.pdfHandle=HPDF_New(0,0) &&Create a New Document
			HPDF_SetCompressionMode(.pdfHandle,HPDF_COMP_ALL) &&Set Document Compression Method
			HPDF_SetPageMode(.pdfHandle,HPDF_PAGE_MODE_USE_OUTLINE) &&Set the how Document should be displayed
			.WritePdfInformation() &&Stablish PDF File Information
			.EncryptPdf()
			.AddBlankPage()
		EndWith
	ENDPROC

	PROCEDURE UnloadReport
		DoDefault()
		With This
			If Vartype(.oImagesCollection)="O" Then &&Cleanup Temporary Images Files
				Local lcItem As String
				For Each lcItem In .oImagesCollection FOXOBJECT
					Delete File (lcItem)
				EndFor
				.oImagesCollection=Null
			EndIf
			.ClearDLLS()
		EndWith
	ENDPROC

	PROCEDURE writepdfinformation		&& Writes Information About the File
		With This
			If !Empty(.cPdfAuthor) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_AUTHOR,.cPdfAuthor)
			EndIf
			If !Empty(.cPdfTitle) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_TITLE,.cpdfTitle)
			EndIf
			If !Empty(.cPdfSubject) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_SUBJECT,.cPdfSubject)
			EndIf
			If !Empty(.cPdfKeyWords) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_KEYWORDS,.cPdfKeywords)
			EndIf
			If !Empty(.cPdfCreator) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_CREATOR,.cPDFCreator)
			EndIf
		EndWith
	ENDPROC

ENDDEFINE

DEFINE CLASS pdflistener AS reportlistener 		&& PDF Listener using HARU Library
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "hpdf_consts.h"
	*<DefinedPropArrayMethod>
		*m: addblankpage		&& Method to add a Blank Page to the document
		*m: addpdfstandardfonts
		*m: cleardlls		&& Method to Clear from Memory all the DLL Calls
		*m: cropimage		&& Method to Crop an Image, uses code from Cesar Chalom Samples
		*m: declaredll		&& Method to Declare all DLL required for the Job
		*m: encryptpdf
		*m: findfontfilename		&& Method to find the real filename of a True Type Font, it will look in the Registry for it
		*m: getfontstyle
		*m: proccessfields
		*m: proccesslabel
		*m: proccesslines
		*m: proccesspictures
		*m: proccessshapes
		*m: resetdatasession
		*m: searchfont
		*m: setfrxdatasession
		*m: shellexec
		*m: startpdfdocument
		*m: writepdfinformation
		*p: ccodepage		&& Code Page to be used by the pdf listener when loading fonts
		*p: cmasterpassword		&& Master Password for the PDF document
		*p: cpdfauthor		&& Author of the Pdf File
		*p: cpdfcreator		&& Name of the Pdf Creator
		*p: cpdfkeywords		&& Keywords of the PDF Document
		*p: cpdfsubject		&& Subject of the PDF File
		*p: cpdftitle		&& Title of the PDF Document
		*p: ctargetfilename		&& Name of the PDF File to create
		*p: cuserpassword		&& User Password for the PDF document
		*p: lcanaddnotes		&& Property to know if the user can add or modify annotations
		*p: lcancopy		&& Property to know if user can copy the document contents
		*p: lcanedit		&& Property to know if user can Edit the contents of the document
		*p: lcanprint		&& Property to know if user can print or can't print the document
		*p: lembedfont		&& Property to Know if the font is Embedded into the document, if .T. file size will increase
		*p: lencryptdocument		&& Property to know if the document should be Encripted
		*p: lopenviewer		&& Flag to execute the default PDF reader of the pc
		*p: lstarted		&& Property to know if the conversion procces has started
		*p: ndivisionfactor		&& Factor to be used for the conversion between unit of measures
		*p: nencriptionlevel		&& A Value Between 5(40bit) and 16(128bit) can be specified for length of the key
		*p: nlastpageproccesed		&& Number of the last page proccesed by the system
		*p: npageheight		&& Height of the page, used to invert the coordinate system of the pdf library
		*p: nspacesfortab		&& Number of Spaces per TAB character
		*p: ofonts		&& Fonts Collection used in the library
		*p: oimagescollection		&& Property to store the collection for Images used in the PDF Generation
		*p: opage		&& Current Page object returned by the library
		*p: oregistry		&& Property to store the Registry Object, this object will provide access to windows registry
		*p: pdfhandle		&& Handle to the PDF file to create by the DLL
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	ccodepage = CP1252		&& Code Page to be used by the pdf listener when loading fonts
	cmasterpassword = 		&& Master Password for the PDF document
	cpdfauthor = 		&& Author of the Pdf File
	cpdfcreator = 		&& Name of the Pdf Creator
	cpdfkeywords = 		&& Keywords of the PDF Document
	cpdfsubject = 		&& Subject of the PDF File
	cpdftitle = 		&& Title of the PDF Document
	ctargetfilename = 		&& Name of the PDF File to create
	cuserpassword = 		&& User Password for the PDF document
	FRXDataSession = -1
	Height = 23
	lcanaddnotes = .F.		&& Property to know if the user can add or modify annotations
	lcancopy = .T.		&& Property to know if user can copy the document contents
	lcanedit = .F.		&& Property to know if user can Edit the contents of the document
	lcanprint = .T.		&& Property to know if user can print or can't print the document
	lembedfont = .F.		&& Property to Know if the font is Embedded into the document, if .T. file size will increase
	lencryptdocument = .F.		&& Property to know if the document should be Encripted
	lopenviewer = .F.		&& Flag to execute the default PDF reader of the pc
	lstarted = .F.		&& Property to know if the conversion procces has started
	Name = "pdflistener"
	ndivisionfactor = 0		&& Factor to be used for the conversion between unit of measures
	nencriptionlevel = 5		&& A Value Between 5(40bit) and 16(128bit) can be specified for length of the key
	nlastpageproccesed = 0		&& Number of the last page proccesed by the system
	npageheight = 0		&& Height of the page, used to invert the coordinate system of the pdf library
	nspacesfortab = 4		&& Number of Spaces per TAB character
	ofonts = .NULL.		&& Fonts Collection used in the library
	oimagescollection = .NULL.		&& Property to store the collection for Images used in the PDF Generation
	opage = .NULL.		&& Current Page object returned by the library
	oregistry = .NULL.		&& Property to store the Registry Object, this object will provide access to windows registry
	pdfhandle = 0		&& Handle to the PDF file to create by the DLL
	SendGDIPlusImage = 1
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="declaredll" type="method" display="DeclareDLL"/>
		<memberdata name="setfrxdatasession" type="method" display="SetFRXDataSession"/>
		<memberdata name="writepdfinformation" type="method" display="WritePDFInformation"/>
		<memberdata name="getfontstyle" type="method" display="GetFontStyle"/>
		<memberdata name="proccessfields" type="method" display="ProccessFields"/>
		<memberdata name="proccesslabel" type="method" display="ProccessLabel"/>
		<memberdata name="proccesslines" type="method" display="ProccessLines"/>
		<memberdata name="proccesspictures" type="method" display="ProccessPictures"/>
		<memberdata name="proccessshapes" type="method" display="ProccessShapes"/>
		<memberdata name="searchfont" type="method" display="SearchFont"/>
		<memberdata name="shellexec" type="method" display="ShellExec"/>
		<memberdata name="startpdfdocument" type="method" display="StartPdfDocument"/>
		<memberdata name="cleardlls" type="method" display="ClearDLLS"/>
		<memberdata name="encryptpdf" type="method" display="EncryptPdf"/>
		<memberdata name="resetdatasession" type="method" display="ResetDataSession"/>
		<memberdata name="pdfhandle" type="property" display="pdfHandle"/>
		<memberdata name="nlastpageproccesed" type="property" display="nLastPageProccesed"/>
		<memberdata name="ndivisionfactor" type="property" display="nDivisionFactor"/>
		<memberdata name="cpdfauthor" type="property" display="cPdfAuthor"/>
		<memberdata name="cpdftitle" type="property" display="cpdfTitle"/>
		<memberdata name="cpdfsubject" type="property" display="cPdfSubject"/>
		<memberdata name="cpdfkeywords" type="property" display="cPdfKeywords"/>
		<memberdata name="cpdfcreator" type="property" display="cPDFCreator"/>
		<memberdata name="lcanprint" type="property" display="lCanPrint"/>
		<memberdata name="lcancopy" type="property" display="lCanCopy"/>
		<memberdata name="lcanedit" type="property" display="lCanEdit"/>
		<memberdata name="lcanaddnotes" type="property" display="lCanAddNotes"/>
		<memberdata name="lencryptdocument" type="property" display="lEncryptDocument"/>
		<memberdata name="cuserpassword" type="property" display="cUserPassword"/>
		<memberdata name="cmasterpassword" type="property" display="cMasterPassword"/>
		<memberdata name="nencriptionlevel" type="property" display="nEncriptionLevel"/>
		<memberdata name="opage" type="property" display="oPage"/>
		<memberdata name="lstarted" type="property" display="lStarted"/>
		<memberdata name="addblankpage" type="method" display="AddBlankPage"/>
		<memberdata name="ctargetfilename" type="property" display="cTargetFileName"/>
		<memberdata name="lopenviewer" type="property" display="lOpenViewer"/>
		<memberdata name="ofonts" type="property" display="oFonts"/>
		<memberdata name="addpdfstandardfonts" type="method" display="AddPDFStandardFonts"/>
		<memberdata name="findfontfilename" type="method" display="FindFontFileName"/>
		<memberdata name="oregistry" type="property" display="oRegistry"/>
		<memberdata name="npageheight" type="property" display="nPageHeight"/>
		<memberdata name="nspacesfortab" type="property" display="nSpacesforTab"/>
		<memberdata name="lembedfont" type="property" display="lEmbedFont"/>
		<memberdata name="oimagescollection" type="property" display="oImagesCollection"/>
		<memberdata name="cropimage" type="method" display="CropImage"/>
		<memberdata name="ccodepage" type="property" display="cCodePage"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addblankpage		&& Method to add a Blank Page to the document
		*!* Change page coordinates and measure system
		With This
			.oPage=HPDF_AddPage(.pdfHandle) &&Add a New Page
			HPDF_Page_SetWidth(.oPage,(.GetPageWidth()/960)*72) &&Establish the Width of the page
			.nPageHeight=(.GetPageHeight()/960)*72
			HPDF_Page_SetHeight(.oPage, .nPageHeight) &&Establish the Height of the page
		EndWith
		*!*		errorn=HPDF_GetError(This.pdfHandle)
		*!*		HPDF_ResetError(This.pdfHandle)
		*HPDF_Page_Concat(This.oPage, 72/960, 0, 0, 72/ 960, 0, 0) &&Change to 960 DPI to be equal as the report listener
	ENDPROC

	PROCEDURE addpdfstandardfonts
		With This.oFonts
			.Add("Courier","Courier")
			.Add("Courier-Bold","Courier-Bold")
			.Add("Courier-Oblique","Courier-Oblique")
			.Add("Courier-BoldOblique","Courier-BoldOblique")
			.Add("Helvetica","Helvetica")
			.Add("Helvetica-Bold","Helvetica-Bold")
			.Add("Helvetica-Oblique","Helvetica-Oblique")
			.Add("Helvetica-BoldOblique","Helvetica-BoldOblique")
			.Add("Times-Roman","Times-Roman")
			.Add("Times-Bold","Times-Bold")
			.Add("Times-Italic","Times-Italic")
			.Add("Times-BoldItalic","Times-BoldItalic")
			.Add("Symbol","Symbol")
			.Add("ZapfDingbats","ZapfDingbats")
		EndWith
	ENDPROC

	PROCEDURE AfterReport
		DoDefault()
		With This
			HPDF_SaveToFile(.pdfHandle,.cTargetFileName)
			HPDF_Free(.pdfHandle)
			If .lOpenViewer Then
				.ShellExec(.cTargetFileName)
			EndIf
		EndWith
	ENDPROC

	PROCEDURE BeforeReport
		With This
			.oFonts=CreateObject("Collection")
			.AddPDFStandardFonts()
			.DeclareDLL()
		EndWith
	ENDPROC

	PROCEDURE cleardlls		&& Method to Clear from Memory all the DLL Calls
		Clear Dlls "HPDF_New","HPDF_Free","HPDF_SaveToFile","HPDF_GetError","HPDF_ResetError","HPDF_SetPageMode",;
		"HPDF_GetCurrentPage","HPDF_AddPage","HPDF_Page_SetWidth","HPDF_Page_SetHeight","HPDF_GetFont","HPDF_LoadTTFontFromFile",;
		"HPDF_GetEncoder","HPDF_GetCurrentEncoder","HPDF_SetCurrentEncoder","HPDF_Encoder_GetType","HPDF_Encoder_GetByteType",;
		"HPDF_Encoder_GetUnicode","HPDF_Encoder_GetWritingMode","HPDF_UseJPEncodings","HPDF_UseKREncodings","HPDF_UseCNSEncodings",;
		"HPDF_UseCNTEncodings","HPDF_LoadPngImageFromFile","HPDF_LoadJpegImageFromFile","HPDF_Image_GetWidth","HPDF_Image_GetHeight",;
		"HPDF_SetInfoAttr","HPDF_SetPassword","HPDF_SetPermission","HPDF_SetEncryptionMode","HPDF_SetCompressionMode",;
		"HPDF_Font_MeasureText","HPDF_Page_GetWidth","HPDF_Page_GetHeight","HPDF_Page_TextWidth","HPDF_Page_GetCurrentFont",;
		"HPDF_Page_MeasureText","HPDF_Page_GetRGBFill","HPDF_Page_GetCurrentFont","HPDF_Page_GetCurrentFontSize","HPDF_Page_SetLineWidth",;
		"HPDF_Page_SetDash","HPDF_Page_MoveTo","HPDF_Page_LineTo","HPDF_Page_ClosePath","HPDF_Page_Rectangle","HPDF_Page_Concat",;
		"HPDF_Page_SetCharSpace","HPDF_Page_SetWordSpace","HPDF_Page_SetHorizontalScalling","HPDF_Page_SetTextLeading",;
		"HPDF_Page_SetTextRise","HPDF_Page_Stroke","HPDF_Page_ClosePathStroke","HPDF_Page_Fill","HPDF_Page_FillStroke",;
		"HPDF_Page_EndPath","HPDF_Page_BeginText","HPDF_Page_EndText","HPDF_Page_SetFontAndSize","HPDF_Page_SetTextRenderingMode",;
		"HPDF_Page_MoveTextPos","HPDF_Page_MoveToNextLine","HPDF_Page_SetRGBFill","HPDF_Page_SetRGBStroke","HPDF_Page_Ellipse",;
		"HPDF_Page_DrawImage","HPDF_Page_TextRect","HPDF_Page_TextOut"
	ENDPROC

	PROCEDURE cropimage		&& Method to Crop an Image, uses code from Cesar Chalom Samples
		Lparameters lcFile As String, lnHeight As Integer, lnWidth As Integer
		If Vartype(_Screen.System)!="O" Then
			Do System.App &&Initializes GDIPLUSX
		EndIf
		With _Screen.System.Drawing
		*	lnWidth = (lnWidth / 72) * 960 &&Return the values to default of VFP
		*	lnHeight = (lnHeight / 72) * 960 &&Return the values to default of VFP
			Local loBmp As xfcBitmap
			loBmp = .Bitmap.FromFile(lcFile)
			lnWidth2 = loBmp.Width
			lnHeight2 = loBmp.Height
			* Crop Image
			Local loCropped As xfcBitmap, loRect As xfcRectangle
			loRect = .Rectangle.New(0, 0, lnWidth, lnHeight)
			loCropped = loBmp.Clone(loRect)
			lcFile=Substr(lcFile,1,Len(lcFile)-3)+"Png"
			loCropped.Save(lcFile, .Imaging.ImageFormat.Png)
			Return lcFile
		EndWith
	ENDPROC

	PROCEDURE declaredll		&& Method to Declare all DLL required for the Job
		Declare Integer HPDF_New In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Free In libhpdf.dll Integer
		Declare Integer HPDF_SaveToFile In libhpdf.dll Integer, String
		Declare Integer HPDF_GetError In libhpdf.dll Integer
		Declare Integer HPDF_ResetError In libhpdf.dll Integer
		Declare Integer HPDF_SetPageMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_GetCurrentPage In libhpdf.dll Integer
		Declare Integer HPDF_AddPage In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetWidth In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetHeight In libhpdf.dll Integer, Single
		Declare Integer HPDF_GetFont In libhpdf.dll Integer, String, String
		Declare String  HPDF_LoadTTFontFromFile In libhpdf.dll Integer, String, Integer
		Declare Integer HPDF_GetEncoder In libhpdf.dll Integer, String
		Declare Integer HPDF_GetCurrentEncoder In libhpdf.dll Integer
		Declare Integer HPDF_SetCurrentEncoder In libhpdf.dll Integer, String
		Declare Integer HPDF_Encoder_GetType In libhpdf.dll Integer
		Declare Integer HPDF_Encoder_GetByteType  In libhpdf.dll Integer, String, Integer
		Declare String  HPDF_Encoder_GetUnicode In libhpdf.dll Integer, String
		Declare Integer HPDF_Encoder_GetWritingMode In libhpdf.dll Integer
		Declare Integer HPDF_UseJPEncodings In libhpdf.dll Integer
		Declare Integer HPDF_UseKREncodings In libhpdf.dll Integer
		Declare Integer HPDF_UseCNSEncodings In libhpdf.dll Integer
		Declare Integer HPDF_UseCNTEncodings In libhpdf.dll Integer
		Declare Integer HPDF_LoadPngImageFromFile In libhpdf.dll Integer, String
		Declare Integer HPDF_LoadJpegImageFromFile In libhpdf.dll Integer, String
		Declare Integer HPDF_Image_GetWidth In libhpdf.dll Integer
		Declare Integer HPDF_Image_GetHeight In libhpdf.dll Integer
		Declare Integer HPDF_SetInfoAttr In  libhpdf.dll Integer, Integer, String
		Declare Integer HPDF_SetPassword In  libhpdf.dll Integer, String, String
		Declare Integer HPDF_SetPermission In libhpdf.dll Integer, Integer
		Declare Integer HPDF_SetEncryptionMode In libhpdf.dll Integer, Integer, Integer
		Declare Integer HPDF_SetCompressionMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Font_MeasureText In libhpdf.dll Integer, String, Integer, Single, Single, Single, Single, Integer, Single @
		Declare Single  HPDF_Page_GetWidth In libhpdf.dll Integer
		Declare Single  HPDF_Page_GetHeight In libhpdf.dll Integer
		Declare Single  HPDF_Page_TextWidth In libhpdf.dll Integer, String
		Declare Integer HPDF_Page_GetCurrentFont In libhpdf.dll Integer
		Declare Integer HPDF_Page_MeasureText In libhpdf.dll Integer, String, Single, Integer, Single @
		Declare Integer HPDF_Page_GetRGBFill In libhpdf.dll Integer
		Declare Integer HPDF_Page_GetCurrentFont In libhpdf.dll Integer
		Declare Single  HPDF_Page_GetCurrentFontSize In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetLineWidth In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetDash In libhpdf.dll Integer, String, Integer, Integer
		Declare Integer HPDF_Page_MoveTo In libhpdf.dll Integer, Single, Single
		Declare Integer HPDF_Page_LineTo In libhpdf.dll Integer, Single, Single
		Declare Integer HPDF_Page_ClosePath In libhpdf.dll Integer
		Declare Integer HPDF_Page_Rectangle In libhpdf.dll Integer, Single, Single, Single, Single
		Declare Integer HPDF_Page_Concat In libhpdf.dll Integer, Single, Single, Single, Single, Single, Single
		Declare Integer HPDF_Page_SetCharSpace In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetWordSpace In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetHorizontalScalling In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetTextLeading In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_SetTextRise In libhpdf.dll Integer, Single
		Declare Integer HPDF_Page_Stroke In libhpdf.dll Integer
		Declare Integer HPDF_Page_ClosePathStroke In libhpdf.dll Integer
		Declare Integer HPDF_Page_Fill In libhpdf.dll Integer
		Declare Integer HPDF_Page_FillStroke In libhpdf.dll Integer
		Declare Integer HPDF_Page_EndPath In libhpdf.dll Integer
		Declare Integer HPDF_Page_BeginText In libhpdf.dll Integer
		Declare Integer HPDF_Page_EndText In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetFontAndSize  In libhpdf.dll Integer, Integer, Single
		Declare Integer HPDF_Page_SetTextRenderingMode In libhpdf.dll Integer, Integer
		Declare Integer HPDF_Page_MoveTextPos In libhpdf.dll Integer, Single, Single
		Declare Integer HPDF_Page_MoveToNextLine In libhpdf.dll Integer
		Declare Integer HPDF_Page_SetRGBFill In libhpdf.dll Integer, Single, Single, Single
		Declare Integer HPDF_Page_SetRGBStroke In libhpdf.dll Integer, Single, Single, Single
		Declare Integer HPDF_Page_Ellipse In libhpdf.dll Integer, Single, Single, Single, Single
		Declare Integer HPDF_Page_DrawImage In libhpdf.dll Integer, Integer, Single, Single, Single, Single
		Declare Integer HPDF_Page_TextRect In libhpdf.dll Integer, Single, Single, Single, Single, String, Integer, Integer
		Declare Integer HPDF_Page_TextOut In libhpdf.dll Integer, Single, Single, String
	ENDPROC

	PROCEDURE encryptpdf
		With This
			If .lEncryptDocument Then &&Protect the document with password
				If !Empty(.cMasterPassword) Then
					If .cMasterPassword!=.cUserPassword Then &&User Password and Master Password can't be the same
						HPDF_SetPassword(.pdfHandle,.cMasterPassword,.cUserPassword)
						Local lnPermit As Integer
						lnPermit=0
						&&Establish PDF files permissions
						If .lCanPrint Then
							lnPermit = lnPermit + HPDF_ENABLE_PRINT
						EndIf
						If .lCanEdit Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT_ALL
						EndIf
						If .lCanCopy Then
							lnPermit = lnPermit + HPDF_ENABLE_COPY
						EndIf
						If .lCanAddNotes Then
							lnPermit = lnPermit + HPDF_ENABLE_EDIT
						EndIf
						HPDF_SetPermission(This.pdfHandle,lnPermit)
						If .nEncriptionLevel!=5 Then
							HPDF_SetEncryptionMode(.pdfHandle,HPDF_ENCRYPT_R3,.nEncriptionLevel)
						Else
							HPDF_SetEncryptionMode(.pdfHandle,HPDF_ENCRYPT_R2,.nEncriptionLevel)
						EndIf
					EndIf
				EndIf
			EndIf
		EndWith
	ENDPROC

	PROCEDURE findfontfilename		&& Method to find the real filename of a True Type Font, it will look in the Registry for it
		Lparameters lcFontName As String
		Local lcFileName As String, lcFolder As String
		If Vartype(This.oRegistry)!="O" Then
			This.oRegistry=NewObject("Registry","PDFx")
		EndIf
		lcFolder = Iif(Os(3)< "5","SOFTWARE\Microsoft\Windows\CurrentVersion\Fonts","Software\Microsoft\Windows NT\CurrentVersion\Fonts")
		lcFileName=GetEnv("windir")+"\Fonts\"+This.oRegistry.ReadRegistryString(HKEY_LOCAL_MACHINE,lcFolder,lcFontName+" (TrueType)")
		If !IsNull(lcFileName) Then
			errorn=HPDF_GetError(This.pdfHandle)
			HPDF_ResetError(This.pdfHandle)
			Return HPDF_LoadTTFontFromFile(This.pdfHandle,lcFileName,This.lEmbedFont)
		Else
			Return ""
		EndIf
	ENDPROC

	PROCEDURE getfontstyle
	ENDPROC

	PROCEDURE proccessfields
		Lparameters lcFontFace As String, liFontStyle As Integer, lnFontSize As Number, lnPenRed As Number, lnPenGreen As Number,;
		lnPenBlue As Number, lnFillRed As Number, lnFillGreen As Number, lnFillBlue As Number, nLeft As Number, nTop As Number,;
		lcContents As String, lcFillChar As String, lnOffset As Integer, lbStretch As Boolean, lnCodePage As Integer, nHeight As Number,nWidth As Integer
		Local lnOcurrences As Integer, lnAncho As Integer, lnFontHandle As Integer, lnAlto As Integer
		With This
			nTop = .nPageHeight - nTop &&Change the Top Coordinates Because of the PDF Coordinate System
			lnFontHandle = HPDF_GetFont(.pdfHandle,.SearchFont(lcFontFace,liFontStyle),Iif(Empty(.cCodePage),NULL,.cCodePage)) &&Find and select the font	
			HPDF_Page_BeginText(.oPage) &&Change to Text Mode
			HPDF_Page_SetFontAndSize(.oPage, lnFontHandle, lnFontSize) &&Find and choose the font
			lnOcurrences=Occurs(Chr(9),lcContents)
			If lnOcurrences>0 Then &&Replace TAB with spaces
				lcContents=Chrtranc(lcContents,Chr(9),Replicate(" ",.nSpacesforTab))
			EndIf
			If lnPenRed=-1 And lnPenBlue=-1 And lnPenGreen=-1 Then &&Default Colors of VFP Report Designer
				Store 0 To lnPenBlue,lnPenRed,lnPenGreen
			EndIf
			lnAncho=HPDF_Page_TextWidth(.oPage,lcContents) &&Get the size of the text width
			lnAlto=HPDF_Page_GetCurrentFontSize(.oPage) &&Get the height of the current font
			HPDF_Page_SetRGBFill(.oPage,lnPenRed/255,lnPenGreen/255,lnPenBlue/255) &&Convert colors to PDF mode
			HPDF_Page_SetTextLeading(.oPage, 0) &&Space between lines
			Do Case
				Case lnOffset=0 &&Left Aligned
					If lbStretch Then &&Stretch with Overflow use it
						HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+nWidth,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_LEFT,0)
					Else
						HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+nWidth,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_LEFT,0)
					EndIf
				Case lnOffset=1 &&Right Aligned
					If lbStretch Then &&Stretch with Overflow use it
						HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+nWidth,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_RIGHT,0)
					Else
						HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+nWidth,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_RIGHT,0)
					EndIf
				Case lnOffset=2 &&Center Aligned
					If lbStretch Then &&Stretch with Overflow use it
						HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+nWidth,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_CENTER,0)
					Else
						HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+nWidth,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_CENTER,0)
					EndIf	
			EndCase
			HPDF_Page_EndText(.oPage)
		EndWith
	ENDPROC

	PROCEDURE proccesslabel
		Lparameters lcFontFace As String, liFontStyle As Integer, lnFontSize As Number, lnPenRed As Number, lnPenGreen As Number,;
		lnPenBlue As Number, lnFillRed As Number, lnFillGreen As Number, lnFillBlue As Number, nLeft As Number, nTop As Number,;
		lcContents As String, lcFillChar As String, lnOffset As Integer, nWidth As Integer, lnCodePage As Integer, nHeight As Number,;
		lcPicture As String
		Local lnAlto As Number, lnAncho As String, lnFontHandle As Integer
		With This
			If lnPenRed=-1 And lnPenBlue=-1 And lnPenGreen=-1 Then &&Replace the Default forecolor of VFP with Black
				Store 0 To lnPenBlue,lnPenRed,lnPenGreen
			EndIf
			nTop = .nPageHeight - nTop &&Change the Top Coordinates Because of the PDF Coordinate System
			lnFontHandle = HPDF_GetFont(.pdfHandle,.SearchFont(lcFontFace,liFontStyle),Iif(Empty(.cCodePage),NULL,.cCodePage)) &&Find and select the font
			HPDF_Page_BeginText(.oPage) &&Start text proccesing mode
			HPDF_Page_SetFontAndSize(.oPage, lnFontHandle, lnFontSize) 
			lnAncho = HPDF_Page_TextWidth(.oPage,lcContents) &&Get the size of the text width
			lnAlto=HPDF_Page_GetCurrentFontSize(.oPage)
			HPDF_Page_SetRGBFill(.oPage,lnPenRed/255,lnPenGreen/255,lnPenBlue/255) &&Set Forecolor of the text
			If Empty(lcPicture) Then &&lnOffset=1
				HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+lnAncho,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_LEFT,0)
			Else 
				If lcPicture="@I" Then
					HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+lnAncho,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_RIGHT,0)
				Else
					HPDF_Page_TextRect(.oPage,nLeft,nTop,nLeft+lnAncho,nTop-nHeight-lnAlto,lcContents,HPDF_TALIGN_CENTER,0)
				EndIf
			EndIf 
			HPDF_Page_EndText(.oPage)
		EndWith
	ENDPROC

	PROCEDURE proccesslines
		Lparameters lnPenRed As Integer,lnPenGreen As Integer,lnPenBlue As Integer,nTop As Number,nLeft As Number,nWidth As Number,;
		nHeight As Number, lnPenSize As Integer, lnOffSet As Number, lnPenPat As Integer
		Local lcDash As String
		With This
			If lnPenRed!=-1 And lnPenGreen!=-1 And lnPenBlue!=-1 Then
				HPDF_Page_SetRGBStroke(.oPage,lnPenRed/255,lnPenGreen/255,lnPenBlue/255)
			Else
				HPDF_Page_SetRGBStroke(.oPage,0,0,0)
			EndIf
			nTop = .nPageHeight - nTop
			Do Case
				Case lnPenPat=8 &&Normal Mode
					HPDF_Page_SetDash(.oPage,Null,0,0)
				Case lnPenPat=1 &&Dotted
					lcDash=CHR(3) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,1,1)
				Case lnPenPat=2 &&Dashed
					lcDash = CHR(3) + CHR(0) + CHR(7) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,2,2)
				Case lnPenPat=3 &&Dash-dot
					lcDash = CHR(8) + CHR(0) + CHR(7) + CHR(0) + CHR(2) + CHR(0) + CHR(7) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,4,0)
				Case lnPenPat=4 &&Dash-dot-dot
					lcDash = CHR(8) + CHR(0) + CHR(7) + CHR(0) + CHR(2) + CHR(0) + CHR(7) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,4,0)		
			EndCase
			If lnOffSet=1 Then &&Horizontal Line
				If lnPenSize>=1 Then
					HPDF_Page_SetLineWidth(.oPage,lnPenSize)
				Else
					HPDF_Page_SetLineWidth(.oPage,0)
				EndIf
				HPDF_Page_MoveTo(.oPage,nLeft,nTop) &&Move to the screen position
				HPDF_Page_LineTo(.oPage,nLeft+nWidth,nTop)
			Else &&Vertical Line
				If lnPenSize>=1 Then
					HPDF_Page_SetLineWidth(.oPage,lnPenSize)
				Else
					HPDF_Page_SetLineWidth(.oPage,0)
				EndIf
				HPDF_Page_MoveTo(.oPage,nLeft,nTop - nHeight) 
				HPDF_Page_LineTo(.oPage,nLeft, nTop )
			EndIf
			HPDF_Page_Stroke(.oPage)
		EndWith
	ENDPROC

	PROCEDURE proccesspictures
		Lparameters nTop As Number,nLeft As Number,nWidth As Number,nHeight As Number,lcContents As String,;
		GDIPlusImage As Number, lnOffset As Integer, liPictureMode As Integer
		#Define PICTURE_SOURCE_FILENAME         0  && stored in PICTURE column
		#Define PICTURE_SOURCE_GENERAL          1  && stored in NAME    column
		#Define PICTURE_SOURCE_EXPRESSION       2  && stored in NAME    column
		Local lcFile As String
		nTop = This.nPageHeight - nTop
		If GDIPlusImage!=0 Then &&General Field or Expresion
			Do System.App &&Initialize GDIPLUSX library
			Local loImage As xfcBitmap
			With _Screen.System.Drawing
				loImage=.Bitmap.New()
				loImage.Handle = GDIPlusImage
				lcFile=GetEnv("TEMP")+"\"+Sys(2015)+".Png"
				loImage.Save(lcFile, .Imaging.Imageformat.png)
			EndWith
		Else &&File Name
			If File(lcContents) Then
				lcFile=GetEnv("TEMP")+"\"+Sys(2015)+"."+JustExt(lcContents)
				Local lcFileStream As String
				lcFileStream=FileToStr(lcContents)
				Try
					StrToFile(lcFileStream,lcFile,0)
				Catch
				EndTry
			EndIf
		EndIf
		If File(lcFile) Then
			Local lcExtension As String, lnHandle As Integer
			lcExtension=Upper(JustExt(lcFile))
			Do Case
				Case lcExtension="JPG" Or lcExtension="JPEG"
					lnHandle=HPDF_LoadJpegImageFromFile(This.pdfHandle,lcFile)
				Case lcExtension="PNG"
					lnHandle=HPDF_LoadPngImageFromFile(This.pdfHandle,lcFile)
				Otherwise &&Not Supported Format, will never happen when is a general field
					Do System.App &&Initialize GDIPLUSX library
					Local loImage As xfcBitmap
					With _Screen.System.Drawing
						loImage=.Bitmap.New(lcFile)
						lcFile=GetEnv("TEMP")+"\"+Sys(2015)+".Png"
						loImage.Save(lcFile,.Imaging.ImageFormat.Png)
						lnHandle=HPDF_LoadPngImageFromFile(This.pdfHandle,lcFile)
					EndWith
			EndCase
			If !IsNull(lnHandle) Then &&Valid Image Handle
				Do Case
					Case liPictureMode=0 &&Clip 
						lcFile=This.CropImage(lcFile,nHeight,nWidth)
						lnHandle=HPDF_LoadPngImageFromFile(This.pdfHandle,lcFile)
						HPDF_Page_DrawImage(This.oPage,lnHandle,nLeft,nTop-nHeight,nWidth,nHeight)
						*iSEDDrawImage(nLeft,nTop,nWidth,nHeight)
					Case liPictureMode=1 &&Scale Keeping the Shape
						HPDF_Page_DrawImage(This.oPage,lnHandle,nLeft,nTop-nHeight,nWidth,nHeight)
						*iSEDFitImage(nLeft,nTop,nWidth,nHeight,0,0,0)
					Otherwise &&Stretch
						HPDF_Page_DrawImage(This.oPage,lnHandle,nLeft,nTop-nHeight,nWidth,nHeight)
						*iSEDDrawImage(nLeft,nTop,nWidth,nHeight)
				EndCase
			EndIf
		EndIf
		If Vartype(This.oImagesCollection)!="O" Then
			This.oImagesCollection=CreateObject("Collection")
		EndIf
		This.oImagesCollection.Add(lcFile)
	ENDPROC

	PROCEDURE proccessshapes
		Lparameters lnFillRed As Integer,lnFillGreen As Integer,lnFillBlue As Integer,lnPenRed As Integer,lnPenGreen As Integer,;
		lnPenBlue As Integer,nLeft As Number,nTop As Number,nWidth As Number,nHeight As Number,lnOffset As Integer, ;
		lnPenSize As Integer, lnPenPat As Integer, lnFillPat As Integer
		Local lcDash As String
		With This
			nTop = .nPageHeight - nTop
			If lnFillRed!=-1 And lnFillGreen!=-1 And lnFillBlue!=-1 Then
				HPDF_Page_SetRGBFill(.oPage,lnFillRed/255,lnFillGreen/255,lnFillBlue/255)
			Else
				HPDF_Page_SetRGBFill(.oPage,1,1,1)
			EndIf
			If lnPenRed!=-1 And lnPenGreen!=-1 And lnPenBlue!=-1 Then
				HPDF_Page_SetRGBStroke(.oPage,lnPenRed/255,lnPenGreen/255,lnPenBlue/255)
			Else
				HPDF_Page_SetRGBStroke(.oPage,0,0,0)
			EndIf
			If lnPenSize>=1 Then
				HPDF_Page_SetLineWidth(.oPage,lnPenSize)
			Else
				HPDF_Page_SetLineWidth(.oPage,0)
			EndIf
			Do Case
				Case lnPenPat=8 &&Normal Mode
					HPDF_Page_SetDash(.oPage,Null,0,0)
				Case lnPenPat=1 &&Dotted
					lcDash=CHR(3) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,1,1)
				Case lnPenPat=2 &&Dashed
					lcDash = CHR(3) + CHR(0) + CHR(7) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,2,2)
				Case lnPenPat=3 &&Dash-dot
					lcDash = CHR(8) + CHR(0) + CHR(7) + CHR(0) + CHR(2) + CHR(0) + CHR(7) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,4,0)
				Case lnPenPat=4 &&Dash-dot-dot
					lcDash = CHR(8) + CHR(0) + CHR(7) + CHR(0) + CHR(2) + CHR(0) + CHR(7) + CHR(0) + CHR(0)
					HPDF_Page_SetDash(.oPage,lcDash,4,0)		
			EndCase
			If lnOffSet=0 Then
				HPDF_Page_Rectangle(.oPage,nLeft,nTop - nHeight ,nWidth,nHeight)
			Else
				HPDF_Page_Ellipse(.oPage,nLeft+(nWidth/2),nTop-(nHeight/2),nWidth/2,nHeight/2 )
			EndIf
			HPDF_Page_FillStroke (.oPage)
			*HPDF_Page_Stroke(This.oPage)
		EndWith
	ENDPROC

	PROCEDURE Render
		Lparameters nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		#Define OBJ_COMMENT                  0
		#Define OBJ_LABEL                    5
		#Define OBJ_LINE                     6
		#Define OBJ_RECTANGLE                7
		#Define OBJ_FIELD                    8
		#Define OBJ_PICTURE                 17
		#Define OBJ_VARIABLE                18
		Local lbProcces As Boolean
		If This.TwoPassProcess Then &&Report will run twice because the use of _PageTotal variable
			If This.CurrentPass=1 Then  &&Run only in the second pass, 0 is the first one
				lbProcces=.T.
			Else
				lbProcces=.F.
			EndIf
		Else
			lbProcces=.T.
		EndIf
		If lbProcces Then
			Local lcContents As String, loError As Exception
			*!* Modify the measures according to the PDF library
			nLeft = (nLeft / 960) * 72
			nTop = (nTop / 960) * 72
			nWidth = (nWidth / 960) * 72
			nHeight = (nHeight / 960) * 72 
			With This
				.SetFRXDataSession()
				If !.lStarted Then &&Start PDF Document
					.StartPdfDocument() &&Method Called to Start the PDF Generation
					.nLastPageProccesed=.PageNo
				EndIf
				If .PageNo!=.nLastPageProccesed Then &&Add a New Page
					.AddBlankPage()
					.nLastPageProccesed=.PageNo
				EndIf
				If Empty(cContentsToBeRendered) Then
					lcContents = ''
				EndIf
			EndWith
			*!* TO DO: Start drawing of objects
			*!* Change to FRX Datasession and take out the important values
			Go nFRXRecno In FRX
			Scatter Memo Name oFrx
			With oFrx
				*!* Restore Report Datasession
				This.ResetDataSession()
				*!* Start Generation Proccess depending of Object Type
				Do Case
					Case .ObjType=OBJ_LABEL &&Label
						If !Empty(.ResoId) And .ResoId!=1 Then
							&&Convert from Unicode
							lcContents = Strconv(cContentsToBeRendered, 6,.ResoId,2)
							This.Tag=lcContents
						Else
							&&Convert from Unicode
							lcContents = Strconv(cContentsToBeRendered, 6)
							This.Tag=""
						EndIf
						Try
							This.ProccessLabel(.FontFace,.FontStyle,.FontSize,.PenRed,.PenGreen,.PenBlue,.FillRed,.FillGreen,.FillBlue,nLeft,nTop,lcContents,.FillChar,.Offset,nWidth,.ResoId,nHeight,.Picture)
						Catch To loError
							*!* Handle Error Here
						EndTry
					Case .ObjType=OBJ_FIELD &&Field
						If !Empty(.ResoId) And .ResoId!=1 Then
							&&Convert from Unicode
							lcContents = Strconv(cContentsToBeRendered, 6,.ResoId,2)
							This.Tag=lcContents
						Else
							&&Convert from Unicode
							lcContents = Strconv(cContentsToBeRendered, 6)
							This.Tag=""
						EndIf
						Try
							This.ProccessFields(.FontFace,.FontStyle,.FontSize,.PenRed,.PenGreen,.PenBlue,.FillRed,.FillGreen,.FillBlue,nLeft,nTop,lcContents,.FillChar,.Offset,.Stretch,.ResoId,nHeight,nWidth)
						Catch To loError
							*!* Handle Error Here
						EndTry
					Case .ObjType=OBJ_LINE  &&Line
						Try
							This.ProccessLines(.PenRed,.PenGreen,.PenBlue,nTop,nLeft,nWidth,nHeight,.PenSize,.Offset,.PenPat)
						Catch To loError
							*!* Handle Error Here
						EndTry
					Case .ObjType=OBJ_PICTURE &&Picture or General Field
						lcContents =cContentsToBeRendered
						Try
							This.ProccessPictures(nTop,nLeft,nWidth,nHeight,lcContents,GDIPlusImage,.Offset,.General)
						Catch To loError
							*!* Handle Error Here
						EndTry
					Case .ObjType=OBJ_RECTANGLE &&Rectangle
						Try
							This.ProccessShapes(.FillRed,.FillGreen,.FillBlue,.PenRed,.PenGreen,.PenBlue,nLeft,nTop,nWidth,nHeight,.Offset,.PenSize,.PenPat,.FillPat)
						Catch To loError
							*!* Handle Error Here
						EndTry
				EndCase
			EndWith
		EndIf
	ENDPROC

	PROCEDURE resetdatasession
		Try
			Set DataSession To (This.CurrentDataSession)
		Catch When .T.
			*Can't Return DataSession to do: handle this
		EndTry
	ENDPROC

	PROCEDURE searchfont
		Lparameters lcFontName As String, lnStyle As Integer &&, lnCodePage As Integer
		Local lcRetorno As String
		With This
			If Bittest(lnStyle,0) Then &&Bold 
				lcFontName = lcFontName + " Bold"
			EndIf
			If Bittest(lnStyle,1) Then &&Italic
				lcFontName = lcFontName + " Italic"
			EndIf
			Local lbResult As Boolean, lnI As Integer
			*!* Look for the font in the current collection
			For lnI=1 To This.oFonts.Count
				If This.oFonts.GetKey(lnI)==lcFontName Then
					lbResult=.T.
					Exit
				EndIf
			EndFor
			If !lbResult Then &&Font Does Not Exists, let's added it to the collection
				Local lcKey As String
				lcKey=This.FindFontFileName(lcFontName)
				If !Empty(lcKey) Then
					This.oFonts.Add(lcKey,lcFontName)
				Else &&Can't add fonts 
					lcFontName="Times-Roman" 
				EndIf
			EndIf
		EndWith
		lcRetorno=This.oFonts.Item(This.oFonts.GetKey(lcFontName))
		Return lcRetorno
	ENDPROC

	PROCEDURE setfrxdatasession
		With This
			If (.FRXDatasession > -1) And (.FRXDatasession # Set("DATASESSION")) Then
				Try
					Set DataSession To (.FRXDatasession)
				Catch When .T.
					.ResetToDefault("FRXDataSession")
					.ResetDataSession()
				EndTry
			EndIf
		EndWith
	ENDPROC

	PROCEDURE shellexec
		Lparameter lcLink As String, lcAction As String, lcParms As String
		lcAction = Iif(Empty(lcAction), "Open", lcAction)
		lcParms = Iif(Empty(lcParms), "", lcParms)
		Declare Integer ShellExecute In SHELL32.Dll Integer nWinHandle, String cOperation, ;
			String cFileName, String cParameters, String cDirectory, Integer nShowWindow
		Declare Integer FindWindow In WIN32API String cNull,String cWinName
		Return ShellExecute(FindWindow(0, _Screen.Caption), lcAction, lcLink, lcParms, Sys(2023), 1)
	ENDPROC

	PROCEDURE startpdfdocument
		With This
			.pdfHandle=HPDF_New(0,0) &&Create a New Document
			HPDF_SetCompressionMode(.pdfHandle,HPDF_COMP_ALL) &&Set Document Compression Method
			HPDF_SetPageMode(.pdfHandle,HPDF_PAGE_MODE_USE_OUTLINE) &&Set the how Document should be displayed
			.WritePdfInformation() &&Stablish PDF File Information
			.EncryptPdf()
			.AddBlankPage()
			.lStarted=.T.
		EndWith
	ENDPROC

	PROCEDURE UnloadReport
		DoDefault()
		With This
			If Vartype(.oImagesCollection)="O" Then &&Cleanup Temporary Images Files
				Local lcItem As String
				For Each lcItem In .oImagesCollection FOXOBJECT
					Delete File (lcItem)
				EndFor
				.oImagesCollection=Null
			EndIf
			.ClearDLLS()
		EndWith
	ENDPROC

	PROCEDURE writepdfinformation
		With This
			If !Empty(.cPdfAuthor) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_AUTHOR,.cPdfAuthor)
			EndIf
			If !Empty(.cPdfTitle) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_TITLE,.cpdfTitle)
			EndIf
			If !Empty(.cPdfSubject) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_SUBJECT,.cPdfSubject)
			EndIf
			If !Empty(.cPdfKeyWords) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_KEYWORDS,.cPdfKeywords)
			EndIf
			If !Empty(.cPdfCreator) Then
				HPDF_SetInfoAttr(.pdfHandle,HPDF_INFO_CREATOR,.cPDFCreator)
			EndIf
		EndWith
	ENDPROC

ENDDEFINE

DEFINE CLASS registry AS custom 		&& Provides read and write access to the  System Registry. The Functionality provided is greatly abstracted resulting in using a single method call to set and retrieve values from the registry.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "hpdf_consts.h"
	*<DefinedPropArrayMethod>
		*m: deleteregistrykey		&& Elimina una llave del registro de Windows
		*m: enumregistrykey		&& Retorna un valor del registro basado en un indice. Permite llamadas desde un ciclo FOR
		*m: enumvalue		&& Retorna el nombre de un valor del registro
		*m: examples		&& Ejemplos de Uso de la Clase
		*m: getenumkeys		&& Retorna todas las subclaves de una clave especificada
		*m: getenumvalues		&& Retorna todos los valores de una llave en un array
		*m: readregistryint		&& Lee un valor Integer (DWORD)  o Short en el registro de Windows
		*m: readregistrystring		&& Lee un Valor String del Registro de Windows
		*m: writeregistrybinary		&& Escribe un valor binario en el registro de Windows
		*m: writeregistryint		&& Escribe una valor numérico en el Registro de windows
		*m: writeregistrystring		&& Escribe una valor String en el Registro de Windows
	*</DefinedPropArrayMethod>

	Height = 19
	Name = "registry"
	Width = 35
	
	PROCEDURE deleteregistrykey		&& Elimina una llave del registro de Windows
		************************************************************************
		* Registry :: DeleteRegistryKey
		*********************************
		***  Function: Deletes a registry key. Note this does not delete
		***            an entry but the key (ie. a path node).
		***            Use WriteRegistryString/Int with a .NULL. to
		***            Delete an entry.
		***      Pass: tnHKey    -   Registry Root node key
		***            tcSubkey  -   Path to clip
		***    Return: .T. or .NULL.
		************************************************************************
		Lparameters tnHKEY,tcSubKey
		Local lnResult, lnRegHandle
		tnHKEY=Iif(Type("tnHKey")="N",tnHKEY,HKEY_LOCAL_MACHINE)
		lnRegHandle=0
		lnResult=RegOpenKey(tnHKEY,tcSubKey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Key doesn't exist or can't be opened
			Return .Null.
		EndIf
		lnResult=RegDeleteKey(tnHKEY,tcSubKey)
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		Return .T.
	ENDPROC

	PROTECTED PROCEDURE enumregistrykey		&& Retorna un valor del registro basado en un indice. Permite llamadas desde un ciclo FOR
		************************************************************************
		* wwAPI :: EnumRegistryKey
		*********************************
		***  Function: Returns a registry key name based on an index
		***            Allows enumeration of keys in a FOR loop. If key
		***            is empty end of list is reached or the key doesn't
		***            exist or is empty.
		***      Pass: tnHKey    -   HKEY_ root key
		***            tcSubkey  -   Subkey string
		***            tnIndex   -   Index of key name to get (0 based)
		***    Return: "" on error - Key name otherwise
		************************************************************************
		Lparameters tnHKey, tcSubKey, tnIndex
		Local lcSubKey, lcReturn, lnResult, lcDataBuffer
		lnRegHandle=0
		*** Open the registry key
		lnResult=RegOpenKey(tnHKey,tcSubKey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		Declare Integer RegEnumKey ;
			IN WIN32API ;
			INTEGER nHKey, ;
			INTEGER nIndex, ;
			STRING @cSubkey, ;
			INTEGER nSize
		lcDataBuffer=Space(MAX_INI_BUFFERSIZE)
		lnSize=MAX_INI_BUFFERSIZE
		lnReturn=RegEnumKey(lnRegHandle, tnIndex, @lcDataBuffer, lnSize)
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		Return Trim(Chrtran(lcDataBuffer,Chr(0),""))
	ENDPROC

	PROTECTED PROCEDURE enumvalue		&& Retorna el nombre de un valor del registro
		************************************************************************
		* Registry :: EnumValue
		*********************************
		***  Function: Returns the name of a registry Value key. Note the actual
		***            Value is not returned but just the key. This is done
		***            so you can check the type first and use the appropriate
		***            ReadRegistryX method. The type is returned by ref in the
		***            last parameter.
		***    Assume:
		***      Pass: tnHKey   -   HKEY value
		***            tcSubkey -   The key to enumerate valuekeys for
		***            tnIndex  -   Index of key to work on
		***            @tnType  -   Used to pass back the type of the value
		***    Return: String of ValueKey or .NULL.
		************************************************************************
		Lparameters tnHKey, tcSubKey, tnIndex, tnType
		Local lcSubKey, lcReturn, lnResult, lcDataBuffer
		tnType=Iif(Type("tnType")="N",tnType,0)
		lnRegHandle=0
		*** Open the registry key
		lnResult=RegOpenKey(tnHKey,tcSubKey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		*** Need to define here specifically for Return Type
		*** for lpdData parameter or VFP will choke.
		*** Here it's STRING.
		Declare Integer RegEnumValue ;
			IN Win32API ;
			INTEGER nHKey,;
			INTEGER nIndex,;
			STRING @lpszValueName,;
			INTEGER @lpdwSize,;
			INTEGER dwReserved,;
			INTEGER @lpdwType,;
			STRING @lpbData,;
			INTEGER @lpcbData
		tcSubKey=Space(MAX_INI_BUFFERSIZE)
		tcValue=Space(MAX_INI_BUFFERSIZE)
		lnSize=MAX_INI_BUFFERSIZE
		lnValSize=MAX_INI_BUFFERSIZE
		lnReturn=RegEnumValue(lnRegHandle, tnIndex, @tcSubKey,@lnValSize, 0, @tnType, @tcValue, @lnSize)
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
		*** Not Found
			Return .Null.
		EndIf
		Return Trim(Chrtran(tcSubKey,Chr(0),""))
		
	ENDPROC

	PROCEDURE examples		&& Ejemplos de Uso de la Clase
		*** Create a new Tree
		? oRegistry.WriteRegistryString(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies",;
		                               "","",.T.)
		
		*** Now create a a key off the root and add a value                                
		? oRegistry.WriteRegistryString(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "CurrentVersion","1.45",.T.)
		
		*** Add another Value - numeric
		? oRegistry.WriteRegistryInt  (HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "Timeout",60,.T.)
		
		*** Now Read the values back
		? oRegistry.ReadRegistryString(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "CurrentVersion")
		
		? oRegistry.ReadRegistryInt(HKEY_LOCAL_MACHINE,;
		                               "SOFTWARE\West Wind Technologies\WebConnection",;
		                               "Timeout")
		
		*** Uncomment this code to delete the registry entries again
		
		*-**** Now delete the value entries - Write with a NULL
		*-*? oRegistry.WriteRegistryString(HKEY_LOCAL_MACHINE,;
		*-*                               "SOFTWARE\West Wind Technologies\WebConection",;
		*-*                               "CurrentVersion",.NULL.,.T.)
		*-*
		*-**** And the numeric entry - again with a .NULL.
		*-*? oRegistry.WriteRegistryInt  (HKEY_LOCAL_MACHINE,;
		*-*                               "SOFTWARE\West Wind Technologies\WebConection",;
		*-*                               "Timeout",.NULL.,.T.)
		*-*
		*-**** Get rid of the keys - Web Connection
		*-*? oRegistry.DeleteRegistryKey(HKEY_LOCAL_MACHINE,;
		*-*                            "SOFTWARE\West Wind Technologies\WebConection")
		*-*
		*-**** Again the West Wind Technologies Key
		*-*? oRegistry.DeleteRegistryKey(HKEY_LOCAL_MACHINE,;
		*-*                              "SOFTWARE\West Wind Technologies")
		
		*#ENDIF
		
	ENDPROC

	PROCEDURE getenumkeys		&& Retorna todas las subclaves de una clave especificada
		************************************************************************
		* Registry :: GetEnumKeys
		*********************************
		***  Function: Returns an array of all subkeys for a given key
		***            NOTE: This function does not return Value Keys only
		***                  Tree Keys!!!!
		***      Pass: @taKeys  -   An array that gets filled with key names
		***            tnHKEY   -   Root Key
		***            tcSubkey -   Subkey to enumerate for
		***    Return: Number of keys or 0
		************************************************************************
		Lparameters taKeys, tnHKey, tcSubKey
		Local x, lcKey
		lcKey="x"
		x=0
		Do While !Empty(lcKey) Or Isnull(lcKey)
			lnType=0
			lcKey=This.EnumKey(tnHKey,tcSubKey,x)
			If Isnull(lcKey) Or Empty(lcKey)
				Exit
			EndIf
			x=x+1
			Dimension  taKeys[x]
			taKeys[x]=lcKey
		EndDo
		
		Return x
	ENDPROC

	PROCEDURE getenumvalues		&& Retorna todos los valores de una llave en un array
		************************************************************************
		* Registry :: GetEnumValues
		*********************************
		***  Function: Retrieves all Values off a key into an array. The
		***            array is 2D and consists of: Key Name, Value
		***    Assume: Not tested with non-string values
		***      Pass: @taValues     -   Result Array: Pass by Reference
		***            tnHKEY        -   ROOT KEY value
		***            tcSubKey      -   SubKey to work on
		***    Return: Count of Values retrieved
		************************************************************************
		Lparameters taValues, tnHKey, tcSubKey
		Local x, lcKey
		lcKey="x"
		x=0
		Do While !Empty(lcKey) Or Isnull(lcKey)
			lnType=0
			lcKey=This.EnumValue(tnHKey,tcSubKey,x,@lnType)
			If Isnull(lcKey) Or Empty(lcKey)
				Exit
			EndIf
			x=x+1
			Dimension  taValues[x,2]
		
			Do Case
			Case lnType=REG_SZ Or lnType=REG_BINARY Or lnType=REG_NONE
				lcValue=oRegistry.ReadRegistryString(tnHKey,tcSubKey,lcKey)
				taValues[x,1]=lcKey
				taValues[x,2]=lcValue
			Case lnType=REG_DWORD
				lnValue=oRegistry.ReadRegistryInt(tnHKey,tcSubKey,lcKey)
				taValues[x,1]=lcKey
				taValues[x,2]=lnValue
			Otherwise
				taValues[x,1]=lcKey
				taValues[x,2]=""
			EndCase
		EndDo
		Return x
	ENDPROC

	PROCEDURE Init
		************************************************************************
		* Registry :: Init
		*********************************
		***  Function: Loads required DLLs. Note Read and Write DLLs are
		***            not loaded here since they need to be reloaded each
		***            time depending on whether String or Integer values
		***            are required
		************************************************************************
		
		*** Open Registry Key
		Declare Integer RegOpenKey ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING cSubKey,;
			INTEGER @nHandle
		
		*** Create a new Key
		Declare Integer RegCreateKey ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING cSubKey,;
			INTEGER @nHandle
		
		*** Close an open Key
		Declare Integer RegCloseKey ;
			IN Win32API ;
			INTEGER nHKey
		
		*** Delete a key (path)
		Declare Integer RegDeleteKey ;
			IN Win32API ;
			INTEGER nHKEY,;
			STRING cSubkey
		
		*** Delete a value from a key
		Declare Integer RegDeleteValue ;
			IN Win32API ;
			INTEGER nHKEY,;
			STRING cEntry
	ENDPROC

	PROCEDURE readregistryint		&& Lee un valor Integer (DWORD)  o Short en el registro de Windows
		************************************************************************
		* Registry :: ReadRegistryInt
		*********************************
		***  Function: Reads an integer (DWORD) or short (4 byte or less) binary
		***            value from the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to retrieve
		***    Return: Registry String or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		
		lnRegHandle=0
		
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		*** Need to define here specifically for Return Type
		*** for lpdData parameter or VFP will choke.
		*** Here's it's an INTEGER
		Declare Integer RegQueryValueEx ;
			IN Win32API As RegQueryInt;
			INTEGER nHKey,;
			STRING lpszValueName,;
			INTEGER dwReserved,;
			Integer @lpdwType,;
			INTEGER @lpbData,;
			INTEGER @lpcbData
		
		lnDataBuffer=0
		lnSize=4
		lnResult=RegQueryInt(lnRegHandle,tcEntry,0,@tnType,;
			@lnDataBuffer,@lnSize)
		=RegCloseKey(lnRegHandle)
		
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		Return lnDataBuffer
		
	ENDPROC

	PROCEDURE readregistrystring		&& Lee un Valor String del Registro de Windows
		************************************************************************
		* Registry :: ReadRegistryString
		*********************************
		***  Function: Reads a string value from the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to retrieve
		***    Return: Registry String or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		
		lnRegHandle=0
		
		*** Open the registry key
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		*** Need to define here specifically for Return Type
		*** for lpdData parameter or VFP will choke.
		*** Here it's STRING.
		Declare Integer RegQueryValueEx ;
			IN Win32API As RegQueryString;
			INTEGER nHKey,;
			STRING lpszValueName,;
			INTEGER dwReserved,;
			INTEGER @lpdwType,;
			STRING @lpbData,;
			INTEGER @lpcbData
		
		*** Return buffer to receive value
		lcDataBuffer=Space(MAX_INI_BUFFERSIZE)
		lnSize=Len(lcDataBuffer)
		lnType=0
		
		lnResult=RegQueryString(lnRegHandle,tcEntry,0,@lnType,;
			@lcDataBuffer,@lnSize)
		
		=RegCloseKey(lnRegHandle)
		
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		If lnSize<2
			Return ""
		EndIf
		
		*** Return string based on length returned
		Return Substr(lcDataBuffer,1,lnSize-1)
		
		
	ENDPROC

	PROCEDURE writeregistrybinary		&& Escribe un valor binario en el registro de Windows
		************************************************************************
		* Registry :: WriteRegistryBinary
		*********************************
		***  Function: Writes a binary value to the registry.
		***            Binary must be written as character values:
		***            chr(80)+chr(13)  will result in "50 1D"
		***            for example.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to write to
		***            tcValue   -  Value to write or .NULL. to delete key
		***            tnLength  -  you have to supply the length
		***            tlCreate  -  Create if it doesn't exist
		***    Assume: Use with extreme caution!!! Blowing your registry can
		***            hose your system!
		***    Return: .T. or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry, tcValue,tnLength,tlCreate
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		tnLength=Iif(Type("tnLength")="N",tnLength,Len(tcValue))
		lnRegHandle=0
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			If !tlCreate
				Return .Null.
			Else
				lnResult=RegCreateKey(tnHKey,tcSubkey,@lnRegHandle)
				If lnResult#ERROR_SUCCESS
					Return .Null.
				EndIf
			EndIf
		EndIf
		
		*** Need to define here specifically for Return Type!
		*** Here lpbData is STRING.
		Declare Integer RegSetValueEx ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING lpszEntry,;
			INTEGER dwReserved,;
			INTEGER fdwType,;
			STRING @lpbData,;
			INTEGER cbData
		
		*** Check for .NULL. which means delete key
		If !Isnull(tcValue)
		*** Nope - write new value
			lnResult=RegSetValueEx(lnRegHandle,tcEntry,0,REG_BINARY,;
				@tcValue,tnLength)
		Else
		*** DELETE THE KEY
			lnResult=RegDeleteValue(lnRegHandle,tcEntry)
		EndIf
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		Return .T.
	ENDPROC

	PROCEDURE writeregistryint		&& Escribe una valor numérico en el Registro de windows
		************************************************************************
		* Registry :: WriteRegistryInt
		*********************************
		***  Function: Writes a numeric value to the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to write to
		***            tcValue   -  Value to write or .NULL. to delete key
		***            tlCreate  -  Create if it doesn't exist
		***    Assume: Use with extreme caution!!! Blowing your registry can
		***            hose your system!
		***    Return: .T. or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry, tnValue,tlCreate
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		lnRegHandle=0
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			If !tlCreate
				Return .Null.
			Else
				lnResult=RegCreateKey(tnHKey,tcSubkey,@lnRegHandle)
				If lnResult#ERROR_SUCCESS
					Return .Null.
				EndIf
			EndIf
		EndIf
		
		*** Need to define here specifically for Return Type!
		*** Here lpbData is STRING.
		Declare Integer RegSetValueEx ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING lpszEntry,;
			INTEGER dwReserved,;
			INTEGER fdwType,;
			INTEGER @lpbData,;
			INTEGER cbData
		
		*** Check for .NULL. which means delete key
		If !Isnull(tnValue)
		*** Nope - write new value
			lnSize=4
			lnResult=RegSetValueEx(lnRegHandle,tcEntry,0,REG_DWORD,;
				@tnValue,lnSize)
		Else
		*** DELETE THE KEY
			lnResult=RegDeleteValue(lnRegHandle,tcEntry)
		EndIf
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		
		Return .T.
	ENDPROC

	PROCEDURE writeregistrystring		&& Escribe una valor String en el Registro de Windows
		************************************************************************
		* Registry :: WriteRegistryString
		*********************************
		***  Function: Reads a string value from the registry.
		***      Pass: tnHKEY    -  HKEY value (in CGIServ.h)
		***            tcSubkey  -  The Registry subkey value
		***            tcEntry   -  The actual Key to write to
		***            tcValue   -  Value to write or .NULL. to delete key
		***            tlCreate  -  Create if it doesn't exist
		***    Assume: Use with extreme caution!!! Blowing your registry can
		***            hose your system!
		***    Return: .T. or .NULL. on error
		************************************************************************
		Lparameters tnHKey, tcSubkey, tcEntry, tcValue,tlCreate
		Local lnRegHandle, lnResult, lnSize, lcDataBuffer, tnType
		
		tnHKey=Iif(Type("tnHKey")="N",tnHKey,HKEY_LOCAL_MACHINE)
		
		lnRegHandle=0
		
		lnResult=RegOpenKey(tnHKey,tcSubkey,@lnRegHandle)
		If lnResult#ERROR_SUCCESS
			If !tlCreate
				Return .Null.
			Else
				lnResult=RegCreateKey(tnHKey,tcSubkey,@lnRegHandle)
				If lnResult#ERROR_SUCCESS
					Return .Null.
				EndIf
			EndIf
		EndIf
		
		*** Need to define here specifically for Return Type!
		*** Here lpbData is STRING.
		Declare Integer RegSetValueEx ;
			IN Win32API ;
			INTEGER nHKey,;
			STRING lpszEntry,;
			INTEGER dwReserved,;
			INTEGER fdwType,;
			STRING lpbData,;
			INTEGER cbData
		
		*** Check for .NULL. which means delete key
		If !Isnull(tcValue)
		*** Nope - write new value
			lnSize=Len(tcValue)
			lnResult=RegSetValueEx(lnRegHandle,tcEntry,0,REG_SZ,;
				tcValue,lnSize)
		Else
		*** DELETE THE KEY
			lnResult=RegDeleteValue(lnRegHandle,tcEntry)
		EndIf
		=RegCloseKey(lnRegHandle)
		If lnResult#ERROR_SUCCESS
			Return .Null.
		EndIf
		Return .T.
		
	ENDPROC

ENDDEFINE
