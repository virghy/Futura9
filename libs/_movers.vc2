*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_movers.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _fieldmover AS _supermover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\_movers.h"
	*<DefinedPropArrayMethod>
		*m: acolscan		&& Scans specific column in array.
		*m: addtoarray		&& Adds item to array.
		*m: alert		&& Displays a messagebox dialog.
		*m: fieldchange		&& Triggered when fields selected changes.
		*m: gettabledata		&& Retrieves fields from table.
		*m: initdata		&& Initializes data.
		*m: initvars		&& Initializes variables used by movers.
		*m: juststem		&& Retrieves filename stem.
		*m: setdataprops		&& Sets data properties.
		*m: updatestatusbar		&& Updates status bar.
		*p: allowreadonly		&& Allows for read-only datasource.
		*p: autoinit		&& Automatically run on load.
		*p: currentalias		&& Current alias determined by ALIAS().
		*p: currentdbc		&& Current database file.
		*p: cursortype		&& Type of cursor. 1-local view, 2-remote view, 3-table.
		*p: dbctable		&& Name of table in DBC.
		*p: multitable		&& Whether to support multiple tables.
		*p: refreshfields
		*p: savemessage
		*p: setfields
		*p: setfieldsglobal
		*p: skiperror
		*p: skipgeneral		&& Do not include General fields in list.
		*p: skipmemo		&& Do not include Memo fields in list.
		*p: tabletype		&& Returns table type - SYS(2029).
	*</DefinedPropArrayMethod>

	allowreadonly = (.F.)		&& Allows for read-only datasource.
	autoinit = (.T.)		&& Automatically run on load.
	currentalias = ("")		&& Current alias determined by ALIAS().
	currentdbc = ("")		&& Current database file.
	cursortype = (3)		&& Type of cursor. 1-local view, 2-remote view, 3-table.
	dbctable = ("")		&& Name of table in DBC.
	Height = 111
	Name = "_fieldmover"
	refreshfields = (.T.)
	setfields = (.F.)
	setfieldsglobal = (.F.)
	skiperror = (.F.)
	skipgeneral = (.F.)		&& Do not include General fields in list.
	skipmemo = (.F.)		&& Do not include Memo fields in list.
	SpecialEffect = 0
	TabIndex = 1
	tabletype = (0)		&& Returns table type - SYS(2029).
	updated = (.F.)
	Width = 294
	cmdadd.Caption = ""
	cmdadd.Enabled = .F.
	cmdadd.Height = 21
	cmdadd.Left = 136
	cmdadd.Name = "cmdadd"
	cmdadd.TabIndex = 2
	cmdadd.Top = 19
	cmdadd.Width = 23
	cmdaddall.Caption = ""
	cmdaddall.Enabled = .F.
	cmdaddall.Height = 21
	cmdaddall.Left = 136
	cmdaddall.Name = "cmdaddall"
	cmdaddall.TabIndex = 3
	cmdaddall.Top = 42
	cmdaddall.Width = 23
	cmdremove.Caption = ""
	cmdremove.Height = 21
	cmdremove.Left = 136
	cmdremove.Name = "cmdremove"
	cmdremove.TabIndex = 4
	cmdremove.Top = 65
	cmdremove.Width = 23
	cmdremoveall.Caption = ""
	cmdremoveall.Height = 21
	cmdremoveall.Left = 136
	cmdremoveall.Name = "cmdremoveall"
	cmdremoveall.TabIndex = 5
	cmdremoveall.Top = 88
	cmdremoveall.Width = 23
	label1.Caption = "\<Campos disponibles:"
	label1.Height = 14
	label1.Left = 0
	label1.Name = "label1"
	label1.Top = 2
	label1.Width = 124
	label2.Caption = "Campos \<seleccionados:"
	label2.Height = 14
	label2.Left = 159
	label2.Name = "label2"
	label2.Top = 2
	label2.Width = 138
	lstleft.Height = 95
	lstleft.Left = 0
	lstleft.Name = "lstleft"
	lstleft.TabIndex = 1
	lstleft.Top = 16
	lstleft.Width = 129
	lstright.Height = 95
	lstright.Left = 166
	lstright.Name = "lstright"
	lstright.TabIndex = 6
	lstright.Top = 16
	lstright.Width = 129
	
	PROCEDURE acolscan		&& Scans specific column in array.
		LPARAMETERS WZTARR, WZTEXPR, WZTCOL
		PRIVATE APOS
		IF TYPE('wztcol')<>'N'
		WZTCOL = 1
		ENDIF
		M.APOS = 1
		DO WHILE .T.
		M.APOS = ASCAN(WZTARR, M.WZTEXPR, M.APOS)
		DO CASE
		CASE M.APOS=0
		EXIT
		CASE ASUBSCRIPT(WZTARR, M.APOS, 2)=M.WZTCOL
		EXIT
		OTHERWISE
		M.APOS = M.APOS+1
		ENDCASE
		ENDDO
		RETURN M.APOS
	ENDPROC

	PROCEDURE addtoarray		&& Adds item to array.
		LPARAMETERS AADDTOARRAY, SCONTENTS, IROW
		IF ALEN(AADDTOARRAY)=1 .AND. EMPTY(AADDTOARRAY(1))
		AADDTOARRAY[1] = M.SCONTENTS
		ELSE
		DIMENSION AADDTOARRAY[ALEN(AADDTOARRAY)+1, 1]
		IF PARAMETERS()=2
		AADDTOARRAY[ALEN(AADDTOARRAY)] = M.SCONTENTS
		ELSE
		= AINS(AADDTOARRAY, IROW+1)
		AADDTOARRAY[M.IROW+1] = M.SCONTENTS
		ENDIF
		ENDIF
		RETURN
	ENDPROC

	PROCEDURE alert		&& Displays a messagebox dialog.
		LPARAMETERS PMESSAGE
		LOCAL OLDLOCKSCRN
		M.OLDLOCKSCRN = THISFORM.LOCKSCREEN
		THISFORM.LOCKSCREEN = .F.
		= MESSAGEBOX(M.PMESSAGE)
		THISFORM.LOCKSCREEN = M.OLDLOCKSCRN
	ENDPROC

	PROCEDURE Destroy
		IF EMPTY(THIS.SAVEMESSAGE)
		SET MESSAGE TO
		ELSE
		SET MESSAGE TO THIS.SAVEMESSAGE
		ENDIF
	ENDPROC

	PROCEDURE Error
		LPARAMETERS NERROR, CMETHOD, NLINE
		IF THIS.SKIPERROR
		THIS.ALERT(MESSAGE())
		RETURN
		ENDIF
		LOCAL CMESSAGE
		M.CMESSAGE = MESSAGE()
		= MESSAGEBOX("Error nº"+ALLTRIM(STR(M.NERROR))+" en "+M.CMETHOD+" ("+ALLTRIM(STR(M.NLINE))+"): "+M.CMESSAGE, 048, "Microsoft Visual FoxPro")
		RETURN TO MASTER 
	ENDPROC

	PROCEDURE fieldchange		&& Triggered when fields selected changes.
		LPARAMETERS NBUTTON
		**
		** ReFox - este procedimiento es vacío **
		**
	ENDPROC

	PROCEDURE gettabledata		&& Retrieves fields from table.
		LOCAL I, NTMPLEN, ATMPFLDS, CTMPFLD, LSETFIELDS, LSETGLOBAL
		LOCAL CCALCNAME, CCALCEXPR, LSKIPMEMO, LSKIPGEN
		LOCAL AWIZFLIST, ACALCFIELDS, APICKFIELDS
		DIMENSION AWIZFLIST[1]
		DIMENSION ACALCFIELDS[1, 2]
		DIMENSION APICKFIELDS[1, 1]
		STORE "" TO AWIZFLIST
		STORE "" TO ACALCFIELDS
		STORE "" TO APICKFIELDS
		M.LSETFIELDS = IIF(TYPE("THIS.SETFIELDS")="L", THIS.SETFIELDS, .F.)
		M.LSETGLOBAL = IIF(TYPE("THIS.SETFIELDSGLOBAL")="L", THIS.SETFIELDSGLOBAL, .F.)
		M.LSKIPMEMO = IIF(TYPE("THIS.SKIPMEMO")="L", THIS.SKIPMEMO, .F.)
		M.LSKIPGEN = IIF(TYPE("THIS.SKIPGENERAL")="L", THIS.SKIPGENERAL, .F.)
		THIS.SETDATAPROPS()
		IF TYPE("THIS.RefreshFields")="L" .AND.  .NOT. THIS.REFRESHFIELDS
		RETURN
		ENDIF
		IF EMPTY(THIS.CURRENTALIAS)
		THIS.LSTLEFT.CLEAR
		THIS.LSTLEFT.ENABLED = .F.
		THIS.CMDADD.ENABLED = .F.
		THIS.CMDADDALL.ENABLED = .F.
		IF  .NOT. THIS.MULTITABLE
		THIS.LSTRIGHT.CLEAR
		THIS.LSTRIGHT.ENABLED = .F.
		THIS.CMDREMOVE.ENABLED = .F.
		THIS.CMDREMOVEALL.ENABLED = .F.
		ENDIF
		RETURN
		ENDIF
		DO CASE
		CASE M.LSETFIELDS
		SET FIELDS ON
		IF EMPTY(FLDLIST())
		SET FIELDS OFF
		ENDIF
		CASE SET("FIELDS")="ON"
		SET FIELDS OFF
		ENDCASE
		= AFIELDS(AWIZFLIST)
		IF M.LSETGLOBAL .AND. M.LSETFIELDS
		SET FIELDS GLOBAL
		= AFIELDS(ATMPFLDS)
		M.I = 1
		DO WHILE  .NOT. EMPTY(FLDLIST(M.I))
		M.CTMPFLD = FLDLIST(M.I)
		M.CCALCNAME = ALLTRIM(LEFT(M.CTMPFLD, AT('=', M.CTMPFLD)-1))
		M.CCALCEXPR = SUBSTR(M.CTMPFLD, AT('=', M.CTMPFLD)+1)
		IF AT('=', M.CTMPFLD)<>0
		M.NTMPLEN = ALEN(AWIZFLIST)
		DIMENSION AWIZFLIST[ALEN(AWIZFLIST, 1)+1, 16]
		= ACOPY(ATMPFLDS, AWIZFLIST, (M.I-1)*16+1, 16, M.NTMPLEN+1)
		IF  .NOT. EMPTY(ACALCFIELDS(1, 1))
		DIMENSION ACALCFIELDS[ALEN(ACALCFIELDS, 1)+1, 2]
		ENDIF
		ACALCFIELDS[ALEN(ACALCFIELDS, 1), 1] = UPPER(M.CCALCNAME)
		ACALCFIELDS[ALEN(ACALCFIELDS, 1), 2] = M.CCALCEXPR
		M.CCALCEXPR = STRTRAN(M.CCALCEXPR, '"', "'")
		ENDIF
		M.I = M.I+1
		ENDDO
		SET FIELDS LOCAL
		SET FIELDS OFF
		ENDIF
		IF  .NOT. _DOS .AND.  .NOT. M.LSKIPGEN .AND.  .NOT. M.LSKIPMEMO
		DIMENSION APICKFIELDS[FCOUNT(), 1]
		FOR M.I = 1 TO FCOUNT()
		IF LEN(FIELD(M.I))=LENC(FIELD(M.I))
		APICKFIELDS[M.I, 1] = PROPER(FIELD(M.I))
		ELSE
		APICKFIELDS[M.I, 1] = FIELD(M.I)
		ENDIF
		ENDFOR
		ELSE
		FOR M.I = 1 TO ALEN(AWIZFLIST, 1)
		DO CASE
		CASE AWIZFLIST(M.I, 2)="G" .AND. (_DOS .OR. M.LSKIPGEN)
		LOOP
		CASE AWIZFLIST(M.I, 2)="M" .AND. M.LSKIPMEMO
		LOOP
		ENDCASE
		THIS.ADDTOARRAY(@APICKFIELDS, PROPER(AWIZFLIST(M.I, 1)))
		ENDFOR
		ENDIF
		THIS.LSTLEFT.CLEAR
		IF  .NOT. THIS.MULTITABLE
		THIS.LSTRIGHT.CLEAR
		ELSE
		FOR I = ALEN(APICKFIELDS) TO 1 STEP -1
		IF ASCAN(THIS.ASELECTIONS, ALIAS()+"."+APICKFIELDS(M.I), 1, 3)<>0
		IF ALEN(APICKFIELDS)=1
		APICKFIELDS[1] = ""
		ELSE
		= ADEL(APICKFIELDS, M.I)
		DIMENSION APICKFIELDS[ALEN(APICKFIELDS)-1]
		ENDIF
		IF EMPTY(APICKFIELDS(1))
		THIS.LSTLEFT.CLEAR
		THIS.REFRESH()
		EXIT
		ENDIF
		ENDIF
		ENDFOR
		ENDIF
		IF  .NOT. EMPTY(APICKFIELDS(1))
		THIS.INITCHOICES(@APICKFIELDS)
		THIS.LSTLEFT.VALUE = THIS.LSTLEFT.LIST(1)
		ENDIF
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		THIS.SAVEMESSAGE = SET("MESSAGE", 1)
		IF TYPE("THIS.AUTOINIT")="L" .AND.  .NOT. THIS.AUTOINIT
		THIS.INITVARS()
		ELSE
		THIS.INITDATA()
		ENDIF
	ENDPROC

	PROCEDURE initdata		&& Initializes data.
		THIS.INITVARS()
		IF EMPTY(ALIAS())
		THIS.SETDATAPROPS()
		ELSE
		THIS.GETTABLEDATA()
		ENDIF
	ENDPROC

	PROCEDURE initvars		&& Initializes variables used by movers.
		THIS.UPDATED = IIF(TYPE("THIS.UPDATED")="L", THIS.UPDATED, .F.)
		THIS.ALLOWREADONLY = IIF(TYPE("THIS.ALLOWREADONLY")="L", THIS.ALLOWREADONLY, .F.)
		THIS.SETFIELDS = IIF(TYPE("THIS.SETFIELDS")="L", THIS.SETFIELDS, .F.)
		THIS.SETFIELDSGLOBAL = IIF(TYPE("THIS.SETFIELDSGLOBAL")="L", THIS.SETFIELDSGLOBAL, .F.)
		THIS.SKIPMEMO = IIF(TYPE("THIS.SKIPMEMO")="L", THIS.SKIPMEMO, .F.)
		THIS.SKIPGENERAL = IIF(TYPE("THIS.SKIPGENERAL")="L", THIS.SKIPGENERAL, .F.)
		THIS.SKIPERROR = IIF(TYPE("THIS.SKIPERROR")="L", THIS.SKIPERROR, .F.)
		DIMENSION THIS.ASELECTIONS[1, 2]
	ENDPROC

	PROCEDURE juststem		&& Retrieves filename stem.
		LPARAMETERS M.FILNAME
		IF RATC('\', M.FILNAME)>0
		M.FILNAME = SUBSTR(M.FILNAME, RATC('\', M.FILNAME)+1, 255)
		ENDIF
		IF RATC(':', M.FILNAME)>0
		M.FILNAME = SUBSTR(M.FILNAME, RATC(':', M.FILNAME)+1, 255)
		ENDIF
		IF AT('.', M.FILNAME)>0
		M.FILNAME = SUBSTR(M.FILNAME, 1, AT('.', M.FILNAME)-1)
		ENDIF
		RETURN ALLTRIM(UPPER(M.FILNAME))
	ENDPROC

	PROCEDURE setdataprops		&& Sets data properties.
		THIS.CURRENTALIAS = ALIAS()
		THIS.CURRENTDBC = IIF(EMPTY(ALIAS()), "", CURSORGETPROP("Database"))
		DO CASE
		CASE  .NOT. EMPTY(THIS.CURRENTALIAS) .AND.  .NOT. EMPTY(THIS.CURRENTDBC)
		THIS.DBCTABLE = UPPER(CURSORGETPROP("SourceName"))
		THIS.CURSORTYPE = CURSORGETPROP("SourceType")
		THIS.TABLETYPE = SYS(2029)
		CASE  .NOT. EMPTY(THIS.CURRENTALIAS)
		THIS.DBCTABLE = ""
		THIS.CURSORTYPE = 3
		THIS.TABLETYPE = SYS(2029)
		OTHERWISE
		THIS.DBCTABLE = ""
		THIS.CURSORTYPE = 0
		THIS.TABLETYPE = 0
		ENDCASE
	ENDPROC

	PROCEDURE updatestatusbar		&& Updates status bar.
		LPARAMETERS CARRITEM
		LOCAL CTMPALIAS, CDBC, CDBCALIAS, CSOURCE, ADBC, NPOS
		IF THIS.MULTITABLE .AND. SET("STATUS BAR")="ON" .AND. TYPE("m.cArrItem")="C"
		CTMPALIAS = LEFT(M.CARRITEM, AT(".", M.CARRITEM)-1)
		IF EMPTY(M.CTMPALIAS)
		CTMPALIAS = ALIAS()
		ENDIF
		CSOURCE = CURSORGETPROP("sourcename", M.CTMPALIAS)
		CDBC = CURSORGETPROP("database", M.CTMPALIAS)
		IF  .NOT. EMPTY(M.CDBC)
		DIMENSION ADBC[1]
		= ADATABASES(ADBC)
		NPOS = ASCAN(ADBC, M.CDBC, 1, 3)
		IF NPOS<>0
		CDBCALIAS = ADBC(M.NPOS-1)
		ELSE
		CDBCALIAS = ""
		ENDIF
		ENDIF
		SET MESSAGE TO IIF(EMPTY(M.CDBCALIAS), "", PROPER(M.CDBCALIAS)+"!")+PROPER(M.CSOURCE)
		ENDIF
	ENDPROC

	PROCEDURE validitem
		LOCAL NGETIDX, NPOS
		IF  .NOT. THIS.MULTITABLE
		RETURN .T.
		ENDIF
		NGETIDX = THIS.LSTRIGHT.ITEMIDTOINDEX(THIS.LSTRIGHT.LISTITEMID)
		NPOS = ASCAN(THIS.ASELECTIONS, THIS.LSTRIGHT.LISTITEMID)
		IF M.NPOS=0
		NPOS = M.NGETIDX
		ELSE
		NPOS = ASUBSCRIPT(THIS.ASELECTIONS, M.NPOS, 1)
		ENDIF
		RETURN ATC(ALIAS()+".", THIS.ASELECTIONS(M.NPOS, 1))<>0
	ENDPROC

	PROCEDURE cmdadd.Click
		IF THIS.PARENT.LSTLEFT.LISTINDEX=0 .OR. EMPTY(THIS.PARENT.LSTLEFT.VALUE)
		RETURN
		ENDIF
		_SUPERMOVER.CMDADD::CLICK()
		IF THIS.PARENT.MULTITABLE
		THIS.PARENT.ASELECTIONS[ALEN(THIS.PARENT.ASELECTIONS, 1), 1] = ALIAS()+"."+THIS.PARENT.ASELECTIONS(ALEN(THIS.PARENT.ASELECTIONS, 1), 1)
		ENDIF
		THIS.PARENT.FIELDCHANGE(1)
	ENDPROC

	PROCEDURE cmdaddall.Click
		LOCAL NARRLEN, I
		NARRLEN = IIF(EMPTY(THIS.PARENT.ASELECTIONS(1)), 1, ALEN(THIS.PARENT.ASELECTIONS, 1)+1)
		_SUPERMOVER.CMDADDALL::CLICK()
		IF THIS.PARENT.MULTITABLE
		FOR I = ALEN(THIS.PARENT.ASELECTIONS, 1) TO M.NARRLEN STEP -1
		THIS.PARENT.ASELECTIONS[M.I, 1] = ALIAS()+"."+THIS.PARENT.ASELECTIONS(M.I, 1)
		ENDFOR
		ENDIF
		THIS.PARENT.FIELDCHANGE(2)
	ENDPROC

	PROCEDURE cmdremove.Click
		IF THIS.PARENT.LSTRIGHT.LISTINDEX=0 .OR. EMPTY(THIS.PARENT.LSTRIGHT.VALUE)
		RETURN
		ENDIF
		_SUPERMOVER.CMDREMOVE::CLICK()
		THIS.PARENT.FIELDCHANGE(3)
	ENDPROC

	PROCEDURE cmdremoveall.Click
		LOCAL I, CVALUE, LFOUNDFLD
		CVALUE = THIS.PARENT.LSTRIGHT.VALUE
		IF THIS.PARENT.MULTITABLE .AND.  .NOT. EMPTY(THIS.PARENT.ASELECTIONS(1))
		FOR I = ALEN(THIS.PARENT.ASELECTIONS, 1) TO 1 STEP -1
		IF ATC(ALIAS()+".", THIS.PARENT.ASELECTIONS(M.I, 1))=0
		THIS.PARENT.LSTRIGHT.REMOVEITEM(M.I)
		IF ALEN(THIS.PARENT.ASELECTIONS, 1)=1
		THIS.PARENT.ASELECTIONS[1] = ""
		EXIT
		ELSE
		= ADEL(THIS.PARENT.ASELECTIONS, M.I)
		DIMENSION THIS.PARENT.ASELECTIONS[ALEN(THIS.PARENT.ASELECTIONS, 1)-1, 2]
		ENDIF
		ENDIF
		ENDFOR
		ENDIF
		_SUPERMOVER.CMDREMOVEALL::CLICK()
		LFOUNDFLD = .F.
		FOR I = 1 TO THIS.PARENT.LSTLEFT.LISTCOUNT
		IF THIS.PARENT.LSTLEFT.LIST(M.I)=M.CVALUE
		THIS.PARENT.LSTLEFT.VALUE = THIS.PARENT.LSTLEFT.LIST(M.I)
		THIS.PARENT.LSTLEFT.LISTINDEX = M.I
		LFOUNDFLD = .T.
		EXIT
		ENDIF
		ENDFOR
		IF  .NOT. M.LFOUNDFLD .OR. EMPTY(M.CVALUE)
		THIS.PARENT.LSTLEFT.VALUE = THIS.PARENT.LSTLEFT.LIST(1)
		THIS.PARENT.LSTLEFT.LISTINDEX = 1
		ENDIF
		THIS.PARENT.FIELDCHANGE(4)
		THIS.PARENT.REFRESH()
	ENDPROC

	PROCEDURE lstleft.DblClick
		THIS.PARENT.CMDADD.CLICK()
	ENDPROC

	PROCEDURE lstright.DblClick
		THIS.PARENT.CMDREMOVE.CLICK()
	ENDPROC

	PROCEDURE lstright.When
		LOCAL NGETIDX, NPOS
		IF  .NOT. THIS.PARENT.MULTITABLE .OR. THIS.LISTITEMID=0
		RETURN
		ENDIF
		NGETIDX = THIS.ITEMIDTOINDEX(THIS.LISTITEMID)
		NPOS = ASCAN(THIS.PARENT.ASELECTIONS, THIS.LISTITEMID)
		NPOS = IIF(M.NPOS=0, M.NGETIDX, ASUBSCRIPT(THIS.PARENT.ASELECTIONS, M.NPOS, 1))
		THIS.PARENT.UPDATESTATUSBAR(THIS.PARENT.ASELECTIONS(M.NPOS, 1))
	ENDPROC

ENDDEFINE

DEFINE CLASS _mover AS _container OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemove" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstRight" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\_movers.h"
	*<DefinedPropArrayMethod>
		*m: getselections		&& Retrieves the selected items.
		*m: initchoices		&& Initialize the choices array.
		*m: initselections		&& Initialize the selections array.
		*m: poplist		&& Routine to populate listboxes.
		*m: sizetocontainer
		*m: validitem
		*p: oldlselecteditem
		*p: oldrselecteditem
		*p: sortleft
		*p: updated
		*p: usearrays		&& Whether to use arrays for listboxes.
		*a: achoices[1,0]		&& Array of available choices in left listbox.
		*a: aselections[1,0]		&& Array of selected items in right listbox.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 108
	Name = "_mover"
	sortleft = .F.
	TabIndex = 1
	updated = .F.
	usearrays = .T.		&& Whether to use arrays for listboxes.
	Width = 377

	ADD OBJECT 'cmdAdd' AS _commandbutton WITH ;
		Caption = "Agregar >", ;
		Height = 20, ;
		Left = 160, ;
		Name = "cmdAdd", ;
		TabIndex = 2, ;
		Top = 33, ;
		Width = 75
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemove' AS _commandbutton WITH ;
		Caption = "< Quitar", ;
		Enabled = .F., ;
		Height = 20, ;
		Left = 160, ;
		Name = "cmdRemove", ;
		TabIndex = 3, ;
		Top = 58, ;
		Width = 75
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Label1' AS _label WITH ;
		BackStyle = 0, ;
		Caption = "", ;
		Height = 15, ;
		Left = 0, ;
		Name = "Label1", ;
		Top = 0, ;
		Width = 124
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="label" />

	ADD OBJECT 'Label2' AS _label WITH ;
		BackStyle = 0, ;
		Caption = "", ;
		Height = 15, ;
		Left = 251, ;
		Name = "Label2", ;
		Top = 0, ;
		Width = 124
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="label" />

	ADD OBJECT 'lstLeft' AS _listbox WITH ;
		Height = 92, ;
		Left = 0, ;
		Name = "lstLeft", ;
		Sorted = .T., ;
		TabIndex = 1, ;
		Top = 15, ;
		Width = 143
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="listbox" />

	ADD OBJECT 'lstRight' AS _listbox WITH ;
		Height = 92, ;
		Left = 256, ;
		MoverBars = .T., ;
		Name = "lstRight", ;
		TabIndex = 4, ;
		Top = 15, ;
		Width = 121
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="listbox" />
	
	PROCEDURE getselections		&& Retrieves the selected items.
		PARAMETER ASELECTIONS
		PRIVATE I
		IF THIS.LSTRIGHT.LISTCOUNT>0
		DIMENSION ASELECTIONS[THIS.LSTRIGHT.LISTCOUNT, 1]
		FOR M.I = 1 TO ALEN(ASELECTIONS, 1)
		ASELECTIONS[M.I, 1] = THIS.LSTRIGHT.LIST(M.I)
		ENDFOR
		ENDIF
		RETURN THIS.LSTRIGHT.LISTCOUNT
	ENDPROC

	PROCEDURE Init
		DIMENSION THIS.ASELECTIONS[1, 2]
		DIMENSION THIS.ACHOICES[1]
	ENDPROC

	PROCEDURE initchoices		&& Initialize the choices array.
		LPARAMETERS ACHOICES
		LOCAL LSORTED
		LSORTED = IIF(TYPE("this.sortleft")="L", THIS.SORTLEFT, .T.)
		IF THIS.USEARRAYS
		DIMENSION THIS.ACHOICES[1, 1]
		= ACOPY(ACHOICES, THIS.ACHOICES)
		IF M.LSORTED
		= ASORT(THIS.ACHOICES)
		ENDIF
		THIS.LSTLEFT.ROWSOURCETYPE = 5
		THIS.LSTLEFT.ROWSOURCE = "THIS.Parent.aChoices"
		ELSE
		THIS.LSTLEFT.SORTED = .F.
		THIS.POPLIST(@ACHOICES, THIS.LSTLEFT)
		IF M.LSORTED
		THIS.LSTLEFT.SORTED = .T.
		ENDIF
		ENDIF
		THIS.LSTLEFT.LISTITEMID = THIS.LSTLEFT.INDEXTOITEMID(1)
		THIS.REFRESH()
	ENDPROC

	PROCEDURE initselections		&& Initialize the selections array.
		LPARAMETERS ASELECTIONS
		LOCAL I
		THIS.POPLIST(@ASELECTIONS, THIS.LSTRIGHT)
		THIS.LSTRIGHT.LISTITEMID = THIS.LSTLEFT.INDEXTOITEMID(1)
		DIMENSION THIS.ASELECTIONS[ALEN(ASELECTIONS), 2]
		FOR I = 1 TO ALEN(ASELECTIONS)
		THIS.ASELECTIONS[M.I, 1] = ASELECTIONS(M.I)
		THIS.ASELECTIONS[M.I, 2] = M.I
		ENDFOR
		THIS.REFRESH()
	ENDPROC

	PROCEDURE poplist		&& Routine to populate listboxes.
		LPARAMETERS ALISTARRAY, OLSTREF
		EXTERNAL ARRAY ALISTARRAY
		LOCAL NSTEP, CTMPLISTSTR, I
		PRIVATE CTMPLISTSTR, I, M.NSTEP
		M.CTMPLISTSTR = ""
		M.I = 0
		M.NSTEP = ALEN(ALISTARRAY, 2)
		FOR M.I = 1 TO ALEN(ALISTARRAY) STEP IIF(M.NSTEP==0, 1, M.NSTEP)
		M.OLSTREF.ADDITEM(ALISTARRAY(M.I))
		ENDFOR
	ENDPROC

	PROCEDURE Refresh
		IF TYPE("this.oldLSelectedItem")='L'
		THIS.OLDLSELECTEDITEM = 0
		ENDIF
		IF TYPE("this.oldRSelectedItem")='L'
		THIS.OLDRSELECTEDITEM = 0
		ENDIF
		IF THIS.LSTLEFT.LISTCOUNT=0 .AND. THIS.LSTRIGHT.LISTCOUNT=0
		THIS.LSTLEFT.ENABLED = .F.
		THIS.LSTRIGHT.ENABLED = .F.
		ELSE
		THIS.LSTLEFT.ENABLED = .T.
		THIS.LSTRIGHT.ENABLED = .T.
		ENDIF
		IF THIS.LSTLEFT.LISTCOUNT=0
		THIS.CMDADD.ENABLED = .F.
		ELSE
		THIS.CMDADD.ENABLED = .T.
		IF THIS.OLDLSELECTEDITEM>0
		THIS.LSTLEFT.LISTINDEX = THIS.OLDLSELECTEDITEM
		IF THIS.LSTLEFT.LISTINDEX=0
		THIS.LSTLEFT.LISTINDEX = THIS.OLDLSELECTEDITEM-1
		IF THIS.LSTLEFT.LISTINDEX=0
		THIS.LSTLEFT.LISTINDEX = 1
		ENDIF
		ENDIF
		ENDIF
		ENDIF
		IF THIS.LSTRIGHT.LISTCOUNT=0
		THIS.CMDREMOVE.ENABLED = .F.
		ELSE
		THIS.CMDREMOVE.ENABLED = .T.
		IF THIS.OLDRSELECTEDITEM>0
		THIS.LSTRIGHT.LISTINDEX = THIS.OLDRSELECTEDITEM
		IF THIS.LSTRIGHT.LISTINDEX=0
		THIS.LSTRIGHT.LISTINDEX = THIS.OLDRSELECTEDITEM-1
		IF THIS.LSTRIGHT.LISTINDEX=0
		THIS.LSTRIGHT.LISTINDEX = 1
		ENDIF
		ENDIF
		ENDIF
		ENDIF
		THIS.OLDLSELECTEDITEM = 0
		THIS.OLDRSELECTEDITEM = 0
	ENDPROC

	PROCEDURE sizetocontainer
		PRIVATE M.ISCALEMODE
		M.ISCALEMODE = THISFORM.SCALEMODE
		THISFORM.SCALEMODE = 3
		IF EMPTY(THIS.LABEL1.CAPTION)
		THIS.LABEL1.HEIGHT = 0
		ENDIF
		THIS.LABEL2.HEIGHT = THIS.LABEL1.HEIGHT
		THIS.LABEL1.TOP = 0
		THIS.LABEL2.TOP = 0
		THIS.LSTLEFT.TOP = THIS.LABEL1.HEIGHT
		THIS.LSTRIGHT.TOP = THIS.LSTLEFT.TOP
		THIS.LSTLEFT.HEIGHT = THIS.HEIGHT-THIS.LABEL1.HEIGHT
		THIS.LSTRIGHT.HEIGHT = THIS.LSTLEFT.HEIGHT
		THIS.LSTLEFT.WIDTH = INT((THIS.WIDTH-THIS.CMDADD.WIDTH-36)/2)
		THIS.LSTRIGHT.WIDTH = THIS.LSTLEFT.WIDTH
		THIS.LSTLEFT.LEFT = 0
		THIS.LSTRIGHT.LEFT = THIS.WIDTH-THIS.LSTRIGHT.WIDTH
		THIS.LABEL2.LEFT = THIS.LSTRIGHT.LEFT
		THIS.LABEL1.WIDTH = THIS.LSTLEFT.WIDTH
		THIS.LABEL2.WIDTH = THIS.LABEL1.WIDTH
		THIS.CMDADD.LEFT = INT((THIS.WIDTH-THIS.CMDADD.WIDTH)/2)
		THIS.CMDREMOVE.LEFT = THIS.CMDADD.LEFT
		THIS.CMDREMOVE.HEIGHT = THIS.CMDADD.HEIGHT
		THIS.CMDREMOVE.WIDTH = THIS.CMDADD.WIDTH
		THIS.CMDADD.TOP = THIS.LABEL1.HEIGHT+INT((THIS.LSTLEFT.HEIGHT-((THIS.CMDADD.HEIGHT*2)+6))/2)
		THIS.CMDREMOVE.TOP = THIS.CMDADD.TOP+THIS.CMDADD.HEIGHT+6
		THISFORM.SCALEMODE = M.ISCALEMODE
	ENDPROC

	PROCEDURE validitem
		RETURN .T.
	ENDPROC

	PROCEDURE cmdAdd.Click
		LOCAL CLSTIDX
		IF EMPTY(THIS.PARENT.LSTLEFT.VALUE) .OR. THIS.PARENT.LSTLEFT.LISTINDEX=0
		RETURN
		ENDIF
		THIS.PARENT.UPDATED = .T.
		CLSTIDX = THIS.PARENT.LSTLEFT.LISTINDEX
		THIS.PARENT.LSTRIGHT.ADDITEM(THIS.PARENT.LSTLEFT.LIST(M.CLSTIDX))
		IF  .NOT. EMPTY(THIS.PARENT.ASELECTIONS(1))
		DIMENSION THIS.PARENT.ASELECTIONS[ALEN(THIS.PARENT.ASELECTIONS, 1)+1, 2]
		ENDIF
		THIS.PARENT.ASELECTIONS[ALEN(THIS.PARENT.ASELECTIONS, 1), 1] = THIS.PARENT.LSTLEFT.LIST(M.CLSTIDX)
		THIS.PARENT.ASELECTIONS[ALEN(THIS.PARENT.ASELECTIONS, 1), 2] = THIS.PARENT.LSTRIGHT.INDEXTOITEMID(THIS.PARENT.LSTRIGHT.LISTCOUNT)
		THIS.PARENT.LSTRIGHT.LISTITEMID = THIS.PARENT.LSTRIGHT.INDEXTOITEMID(THIS.PARENT.LSTRIGHT.LISTCOUNT)
		THIS.PARENT.OLDLSELECTEDITEM = M.CLSTIDX
		IF THIS.PARENT.USEARRAYS
		IF ALEN(THIS.PARENT.ACHOICES)=1
		THIS.PARENT.LSTLEFT.CLEAR()
		ELSE
		= ADEL(THIS.PARENT.ACHOICES, M.CLSTIDX)
		DIMENSION THIS.PARENT.ACHOICES[ALEN(THIS.PARENT.ACHOICES)-1]
		THIS.PARENT.LSTLEFT.ROWSOURCE = "this.parent.aChoices"
		ENDIF
		ELSE
		THIS.PARENT.LSTLEFT.REMOVEITEM(M.CLSTIDX)
		ENDIF
		THIS.PARENT.REFRESH()
	ENDPROC

	PROCEDURE cmdRemove.Click
		PARAMETER NPOSITION
		LOCAL CLSTIDX, NLSTPOS, NPOS
		CLSTIDX = THIS.PARENT.LSTRIGHT.LISTINDEX
		NLSTPOS = IIF(PCOUNT()<>0 .AND. TYPE("m.nPosition")="N", NPOSITION, 0)
		IF EMPTY(THIS.PARENT.LSTRIGHT.VALUE) .OR. THIS.PARENT.LSTRIGHT.LISTINDEX=0
		RETURN
		ENDIF
		THIS.PARENT.UPDATED = .T.
		IF THIS.PARENT.VALIDITEM()
		IF THIS.PARENT.USEARRAYS
		IF  .NOT. EMPTY(THIS.PARENT.ACHOICES)
		DIMENSION THIS.PARENT.ACHOICES[ALEN(THIS.PARENT.ACHOICES)+1]
		ENDIF
		THIS.PARENT.ACHOICES[ALEN(THIS.PARENT.ACHOICES)] = THIS.PARENT.LSTRIGHT.LIST(M.CLSTIDX)
		IF THIS.PARENT.SORTLEFT
		= ASORT(THIS.PARENT.ACHOICES)
		ENDIF
		THIS.PARENT.LSTLEFT.ROWSOURCETYPE = 5
		THIS.PARENT.LSTLEFT.ROWSOURCE = "this.parent.aChoices"
		ELSE
		IF NLSTPOS=0
		THIS.PARENT.LSTLEFT.ADDLISTITEM(THIS.PARENT.LSTRIGHT.LIST(M.CLSTIDX))
		THIS.PARENT.LSTLEFT.LISTITEMID = THIS.PARENT.LSTLEFT.INDEXTOITEMID(THIS.PARENT.LSTLEFT.LISTCOUNT)
		ELSE
		THIS.PARENT.LSTLEFT.ADDITEM(THIS.PARENT.LSTRIGHT.LIST(M.CLSTIDX), M.NLSTPOS)
		THIS.PARENT.LSTLEFT.LISTITEMID = THIS.PARENT.LSTLEFT.INDEXTOITEMID(1)
		ENDIF
		ENDIF
		THIS.PARENT.LSTLEFT.VALUE = THIS.PARENT.LSTRIGHT.LIST(M.CLSTIDX)
		ENDIF
		IF ALEN(THIS.PARENT.ASELECTIONS, 1)=1
		THIS.PARENT.ASELECTIONS[1, 1] = ""
		ELSE
		NPOS = ASCAN(THIS.PARENT.ASELECTIONS, THIS.PARENT.LSTRIGHT.LISTITEMID)
		IF M.NPOS<>0
		NPOS = ASUBSCRIPT(THIS.PARENT.ASELECTIONS, M.NPOS, 1)
		ELSE
		NPOS = THIS.PARENT.LSTRIGHT.LISTITEMID
		ENDIF
		= ADEL(THIS.PARENT.ASELECTIONS, M.NPOS)
		DIMENSION THIS.PARENT.ASELECTIONS[ALEN(THIS.PARENT.ASELECTIONS, 1)-1, 2]
		ENDIF
		THIS.PARENT.OLDRSELECTEDITEM = THIS.PARENT.LSTRIGHT.LISTINDEX
		THIS.PARENT.LSTRIGHT.REMOVEITEM(M.CLSTIDX)
		THIS.PARENT.REFRESH
	ENDPROC

	PROCEDURE lstLeft.Clear
		DIMENSION THIS.PARENT.ACHOICES[1]
		THIS.PARENT.ACHOICES[1] = ""
		THIS.ROWSOURCETYPE = 0
		THIS.VALUE = ""
	ENDPROC

	PROCEDURE lstLeft.DblClick
		THIS.PARENT.CMDADD.CLICK
	ENDPROC

	PROCEDURE lstLeft.Init
		THIS.VALUE = ""
	ENDPROC

	PROCEDURE lstLeft.InteractiveChange
		IF EMPTY(THIS.VALUE)
		THIS.VALUE = THIS.LIST(1)
		ENDIF
	ENDPROC

	PROCEDURE lstLeft.OLEDragDrop
		LPARAMETERS ODATAOBJECT, NEFFECT, NBUTTON, NSHIFT, NXCOORD, NYCOORD
		LOCAL OFOXCONTROL
		IF ODATAOBJECT.GETFORMAT("VFP Source Object")
		OFOXCONTROL = ODATAOBJECT.GETDATA("VFP Source Object")
		IF UPPER(OFOXCONTROL.NAME)="LSTRIGHT"
		THIS.PARENT.CMDREMOVE.CLICK()
		ENDIF
		ENDIF
	ENDPROC

	PROCEDURE lstRight.Clear
		DIMENSION THIS.PARENT.ASELECTIONS[1, 2]
		THIS.PARENT.ASELECTIONS[1] = ""
	ENDPROC

	PROCEDURE lstRight.DblClick
		THIS.PARENT.CMDREMOVE.CLICK
	ENDPROC

	PROCEDURE lstRight.Init
		THIS.VALUE = ""
	ENDPROC

	PROCEDURE lstRight.InteractiveChange
		IF EMPTY(THIS.VALUE)
		THIS.VALUE = THIS.LIST(1)
		ENDIF
	ENDPROC

	PROCEDURE lstRight.OLEDragDrop
		LPARAMETERS ODATAOBJECT, NEFFECT, NBUTTON, NSHIFT, NXCOORD, NYCOORD
		LOCAL OFOXCONTROL
		IF ODATAOBJECT.GETFORMAT("VFP Source Object")
		OFOXCONTROL = ODATAOBJECT.GETDATA("VFP Source Object")
		IF UPPER(OFOXCONTROL.NAME)="LSTLEFT"
		THIS.PARENT.CMDADD.CLICK()
		ENDIF
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS _sortmover AS _mover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Optiongroup1" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\_movers.h"
	*<DefinedPropArrayMethod>
		*m: updatemover
		*p: currentalias		&& Current alias for field choices.
		*p: currentdbc		&& Current database for field choices.
		*p: maxfields		&& Maximum number of fields allowed.
		*p: showtags		&& Whether to show existing index tags in addition to fields.
		*p: tagname
		*a: atags[1,1]
	*</DefinedPropArrayMethod>

	currentalias = ("")		&& Current alias for field choices.
	currentdbc = ("")		&& Current database for field choices.
	Height = 150
	maxfields = (3)		&& Maximum number of fields allowed.
	Name = "_sortmover"
	TabIndex = 1
	tagname = ("")
	Width = 466
	cmdAdd.Caption = "A\<gregar >"
	cmdAdd.Enabled = .F.
	cmdAdd.Height = 22
	cmdAdd.Left = 195
	cmdAdd.Name = "cmdAdd"
	cmdAdd.TabIndex = 3
	cmdAdd.Top = 44
	cmdAdd.Width = 73
	cmdRemove.Caption = "< \<Quitar"
	cmdRemove.Height = 22
	cmdRemove.Left = 195
	cmdRemove.Name = "cmdRemove"
	cmdRemove.TabIndex = 4
	cmdRemove.Top = 73
	cmdRemove.Width = 73
	Label1.Caption = "Campos \<disponibles o etiqueta del índice:"
	Label1.Height = 32
	Label1.Left = 0
	Label1.Name = "Label1"
	Label1.TabIndex = 1
	Label1.Top = -1
	Label1.Width = 180
	Label2.Caption = "Campos \<seleccionados:"
	Label2.Height = 15
	Label2.Left = 291
	Label2.Name = "Label2"
	Label2.TabIndex = 6
	Label2.Top = 11
	Label2.Width = 144
	lstLeft.Height = 123
	lstLeft.ItemTips = .T.
	lstLeft.Left = 0
	lstLeft.Name = "lstLeft"
	lstLeft.TabIndex = 2
	lstLeft.Top = 28
	lstLeft.Width = 175
	lstRight.Height = 123
	lstRight.ItemTips = .T.
	lstRight.Left = 291
	lstRight.Name = "lstRight"
	lstRight.TabIndex = 7
	lstRight.Top = 28
	lstRight.Width = 175

	ADD OBJECT 'Optiongroup1' AS _optiongroup WITH ;
		BackStyle = 0, ;
		ButtonCount = 2, ;
		Height = 41, ;
		Left = 182, ;
		Name = "Optiongroup1", ;
		TabIndex = 5, ;
		Top = 101, ;
		Width = 101, ;
		Option1.Caption = "As\<cendente", ;
		Option1.Height = 19, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.TabIndex = 1, ;
		Option1.Top = 2, ;
		Option1.Value = 0, ;
		Option1.Width = 86, ;
		Option2.Caption = "D\<escendente", ;
		Option2.Height = 19, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.TabIndex = 2, ;
		Option2.Top = 20, ;
		Option2.Value = 0, ;
		Option2.Width = 94
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="optiongroup" />
	
	PROCEDURE Refresh
		DODEFAULT()
		LOCAL NPOS
		IF THIS.CMDADD.ENABLED
		IF ATC(" *", THIS.LSTRIGHT.VALUE)<>0 .AND. THIS.SHOWTAGS .AND. THIS.LSTRIGHT.LISTCOUNT>0
		NPOS = ASCAN(THIS.ATAGS, THIS.LSTRIGHT.VALUE)
		IF M.NPOS<>0
		THIS.CMDADD.ENABLED = .F.
		THIS.TAGNAME = THIS.ATAGS(M.NPOS+1)
		ENDIF
		ENDIF
		IF THIS.CMDADD.ENABLED
		THIS.CMDADD.ENABLED = (THIS.LSTRIGHT.LISTCOUNT<THIS.MAXFIELDS)
		ENDIF
		ENDIF
		THIS.OPTIONGROUP1.ENABLED =  .NOT. EMPTY(THIS.LSTLEFT.LISTCOUNT) .OR.  .NOT. EMPTY(THIS.LSTRIGHT.LISTCOUNT)
	ENDPROC

	PROCEDURE updatemover
		LOCAL ATAGLIST, NTOTALTAGS, I, NSAVEALIAS
		LOCAL AFLDS, OLSTREF
		IF EMPTY(ALIAS()) .OR. EMPTY(THIS.CURRENTALIAS)
		RETURN
		ENDIF
		NSAVEALIAS = ALIAS()
		IF ALIAS()<>UPPER(THIS.CURRENTALIAS)
		SELECT (THIS.CURRENTALIAS)
		ENDIF
		THIS.SHOWTAGS = .T.
		THIS.USEARRAYS = .F.
		THIS.TAGNAME = ""
		THIS.LSTRIGHT.CLEAR()
		M.OLSTREF = THIS.LSTLEFT
		M.OLSTREF.CLEAR()
		M.OLSTREF.SORTED = .F.
		M.OLSTREF.VALUE = ""
		DIMENSION ATAGLIST[1]
		ATAGLIST[1] = ""
		NTOTALTAGS = TAGCOUNT('')
		DIMENSION AFLDS[1]
		= AFIELDS(AFLDS)
		DIMENSION THIS.ATAGS[1]
		THIS.ATAGS[1] = ""
		FOR I = 1 TO ALEN(AFLDS, 1)
		IF INLIST(AFLDS(M.I, 2), "M", "G")
		LOOP
		ELSE
		M.OLSTREF.ADDITEM(PROPER(AFLDS(M.I, 1)))
		ENDIF
		ENDFOR
		IF M.NTOTALTAGS>0
		DIMENSION ATAGLIST[M.NTOTALTAGS]
		DIMENSION THIS.ATAGS[M.NTOTALTAGS, 2]
		IF M.OLSTREF.LISTCOUNT>0
		M.OLSTREF.ADDITEM("\-")
		ENDIF
		FOR I = 1 TO M.NTOTALTAGS
		ATAGLIST[M.I] = KEY(M.I)
		THIS.ATAGS[M.I, 1] = LOWER(KEY(M.I))+" *"
		THIS.ATAGS[M.I, 2] = LOWER(TAG(M.I))
		M.OLSTREF.ADDITEM(LOWER(KEY(M.I))+" *")
		ENDFOR
		ENDIF
		IF M.OLSTREF.LISTCOUNT>0
		M.OLSTREF.LISTINDEX = 1
		ENDIF
		THIS.REFRESH()
		SELECT (M.NSAVEALIAS)
	ENDPROC

	PROCEDURE cmdAdd.Click
		IF TYPE('THIS.PARENT.MAXFIELDS')<>'N'
		THIS.PARENT.MAXFIELDS = 0
		ENDIF
		IF THIS.PARENT.MAXFIELDS<>0 .AND. THIS.PARENT.LSTRIGHT.LISTCOUNT=THIS.PARENT.MAXFIELDS
		= MESSAGEBOX("El número máximo de campos para ordenar es "+ALLTRIM(STR(THIS.PARENT.MAXFIELDS)))
		RETURN
		ENDIF
		IF THIS.PARENT.SHOWTAGS .AND. THIS.PARENT.LSTRIGHT.LISTCOUNT>0 .AND. ATCC(" *", THIS.PARENT.LSTLEFT.VALUE)<>0
		IF ASCAN(THIS.PARENT.ATAGS, THIS.PARENT.LSTLEFT.VALUE)<>0 .OR. ASCAN(THIS.PARENT.ATAGS, THIS.PARENT.LSTRIGHT.LIST(1))<>0
		= MESSAGEBOX("No puede combinar etiquetas de índice y campos.")
		RETURN
		ENDIF
		ENDIF
		_MOVER.CMDADD::CLICK
	ENDPROC

	PROCEDURE cmdRemove.Click
		IF THIS.PARENT.SHOWTAGS
		THIS.PARENT.TAGNAME = ""
		IF ASCAN(THIS.PARENT.ATAGS, THIS.PARENT.LSTRIGHT.VALUE)=0
		_MOVER.CMDREMOVE::CLICK(1)
		RETURN
		ENDIF
		ENDIF
		_MOVER.CMDREMOVE::CLICK
	ENDPROC

ENDDEFINE

DEFINE CLASS _supermover AS _mover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdAddAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemoveAll" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\_movers.h"
	*<DefinedPropArrayMethod>
		*p: maxitems		&& Maximum number of items that can be selected.
		*p: maxmessage		&& Message to display if maximum items reached.
	*</DefinedPropArrayMethod>

	Height = 108
	maxitems = 0		&& Maximum number of items that can be selected.
	maxmessage = ("")		&& Message to display if maximum items reached.
	Name = "_supermover"
	Width = 371
	cmdadd.Caption = ""
	cmdadd.Height = 21
	cmdadd.Left = 179
	cmdadd.Name = "cmdadd"
	cmdadd.Picture = graphics\add.bmp
	cmdadd.TabIndex = 3
	cmdadd.Top = 16
	cmdadd.Width = 23
	cmdremove.Caption = ""
	cmdremove.Height = 21
	cmdremove.Left = 179
	cmdremove.Name = "cmdremove"
	cmdremove.Picture = graphics\remove.bmp
	cmdremove.TabIndex = 5
	cmdremove.Top = 63
	cmdremove.Width = 23
	label1.Left = 0
	label1.Name = "label1"
	label1.TabIndex = 1
	label1.Top = 0
	label2.Left = 251
	label2.Name = "label2"
	label2.TabIndex = 7
	label2.Top = 0
	lstleft.Left = 0
	lstleft.Name = "lstleft"
	lstleft.TabIndex = 2
	lstleft.Top = 15
	lstright.Left = 251
	lstright.Name = "lstright"
	lstright.TabIndex = 8
	lstright.Top = 15

	ADD OBJECT 'cmdAddAll' AS _commandbutton WITH ;
		Caption = "", ;
		Height = 21, ;
		Left = 179, ;
		Name = "cmdAddAll", ;
		Picture = graphics\addall.bmp, ;
		TabIndex = 4, ;
		Top = 38, ;
		Width = 23
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemoveAll' AS _commandbutton WITH ;
		Caption = "", ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 179, ;
		Name = "cmdRemoveAll", ;
		Picture = graphics\remall.bmp, ;
		TabIndex = 6, ;
		Top = 85, ;
		Width = 23
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />
	
	PROCEDURE Init
		IF TYPE("THIS.MaxItems")<>"N" .OR. THIS.MAXITEMS<0
		THIS.MAXITEMS = 0
		ENDIF
		IF TYPE("THIS.MaxMessage")<>"C" .OR. EMPTY(THIS.MAXMESSAGE)
		THIS.MAXMESSAGE = "No puede seleccionar más de "+ALLTRIM(STR(THIS.MAXITEMS))+" elementos."
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE Refresh
		DODEFAULT()
		IF THIS.LSTLEFT.LISTCOUNT=0
		THIS.CMDADDALL.ENABLED = .F.
		THIS.CMDADDALL.DEFAULT = .F.
		ELSE
		THIS.CMDADDALL.ENABLED = .T.
		ENDIF
		IF THIS.LSTRIGHT.LISTCOUNT=0
		THIS.CMDREMOVEALL.ENABLED = .F.
		THIS.CMDREMOVEALL.DEFAULT = .F.
		ELSE
		THIS.CMDREMOVEALL.ENABLED = .T.
		ENDIF
	ENDPROC

	PROCEDURE sizetocontainer
		PRIVATE ISCALEMODE
		M.ISCALEMODE = THISFORM.SCALEMODE
		THISFORM.SCALEMODE = 3
		IF EMPTY(THIS.LABEL1.CAPTION)
		THIS.LABEL1.HEIGHT = 0
		ENDIF
		THIS.LABEL2.HEIGHT = THIS.LABEL1.HEIGHT
		THIS.LABEL1.TOP = 0
		THIS.LABEL2.TOP = 0
		THIS.LSTLEFT.TOP = THIS.LABEL1.HEIGHT
		THIS.LSTRIGHT.TOP = THIS.LSTLEFT.TOP
		THIS.LSTLEFT.HEIGHT = THIS.HEIGHT-THIS.LABEL1.HEIGHT
		THIS.LSTRIGHT.HEIGHT = THIS.LSTLEFT.HEIGHT
		THIS.LSTLEFT.WIDTH = INT((THIS.WIDTH-THIS.CMDADD.WIDTH-36)/2)
		THIS.LSTRIGHT.WIDTH = THIS.LSTLEFT.WIDTH
		THIS.LSTLEFT.LEFT = 0
		THIS.LSTRIGHT.LEFT = THIS.WIDTH-THIS.LSTRIGHT.WIDTH
		THIS.LABEL2.LEFT = THIS.LSTRIGHT.LEFT
		THIS.LABEL1.WIDTH = THIS.LSTLEFT.WIDTH
		THIS.LABEL2.WIDTH = THIS.LABEL1.WIDTH
		THIS.CMDADD.LEFT = INT((THIS.WIDTH-THIS.CMDADD.WIDTH)/2)
		THIS.CMDADDALL.LEFT = THIS.CMDADD.LEFT
		THIS.CMDREMOVE.LEFT = THIS.CMDADD.LEFT
		THIS.CMDREMOVEALL.LEFT = THIS.CMDADD.LEFT
		THIS.CMDADDALL.HEIGHT = THIS.CMDADD.HEIGHT
		THIS.CMDREMOVE.HEIGHT = THIS.CMDADD.HEIGHT
		THIS.CMDREMOVEALL.HEIGHT = THIS.CMDADD.HEIGHT
		THIS.CMDADDALL.WIDTH = THIS.CMDADD.WIDTH
		THIS.CMDREMOVE.WIDTH = THIS.CMDADD.WIDTH
		THIS.CMDREMOVEALL.WIDTH = THIS.CMDADD.WIDTH
		THIS.CMDADD.TOP = THIS.LABEL1.HEIGHT+INT((THIS.LSTLEFT.HEIGHT-((THIS.CMDADD.HEIGHT*4)+3))/2)
		THIS.CMDADDALL.TOP = THIS.CMDADD.TOP+THIS.CMDADD.HEIGHT+1
		THIS.CMDREMOVE.TOP = THIS.CMDADDALL.TOP+THIS.CMDADDALL.HEIGHT+1
		THIS.CMDREMOVEALL.TOP = THIS.CMDREMOVE.TOP+THIS.CMDREMOVE.HEIGHT+1
		THISFORM.SCALEMODE = M.ISCALEMODE
	ENDPROC

	PROCEDURE cmdadd.Click
		IF THIS.PARENT.MAXITEMS>0 .AND. (THIS.PARENT.LSTRIGHT.LISTCOUNT+1)>THIS.PARENT.MAXITEMS
		IF  .NOT. EMPTY(THIS.PARENT.MAXMESSAGE) .AND. TYPE("THIS.Parent.MaxMessage")="C"
		MESSAGEBOX(THIS.PARENT.MAXMESSAGE)
		ENDIF
		RETURN
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE cmdAddAll.Click
		LOCAL ALISTITEMS, LSORTED, NTMPLEN, NTMPLEN2, CVALUE, I
		IF THIS.PARENT.LSTLEFT.LISTCOUNT=0
		RETURN
		ENDIF
		IF THIS.PARENT.MAXITEMS>0 .AND. (THIS.PARENT.LSTLEFT.LISTCOUNT+THIS.PARENT.LSTRIGHT.LISTCOUNT)>THIS.PARENT.MAXITEMS
		IF  .NOT. EMPTY(THIS.PARENT.MAXMESSAGE) .AND. TYPE("THIS.Parent.MaxMessage")="C"
		MESSAGEBOX(THIS.PARENT.MAXMESSAGE)
		ENDIF
		RETURN
		ENDIF
		THISFORM.LOCKSCREEN = .T.
		LSORTED = THIS.PARENT.LSTRIGHT.SORTED
		THIS.PARENT.LSTRIGHT.SORTED = .F.
		CVALUE = THIS.PARENT.LSTLEFT.VALUE
		IF THIS.PARENT.USEARRAYS
		DIMENSION ALISTITEMS[ALEN(THIS.PARENT.ACHOICES, 1), 1]
		= ACOPY(THIS.PARENT.ACHOICES, ALISTITEMS)
		ELSE
		DIMENSION ALISTITEMS[THIS.PARENT.LSTLEFT.LISTCOUNT, 1]
		FOR M.I = 1 TO THIS.PARENT.LSTLEFT.LISTCOUNT
		ALISTITEMS[M.I, 1] = THIS.PARENT.LSTLEFT.LIST(M.I)
		ENDFOR
		ENDIF
		THIS.PARENT.LSTLEFT.CLEAR()
		THIS.PARENT.POPLIST(@ALISTITEMS, THIS.PARENT.LSTRIGHT)
		THIS.PARENT.UPDATED = .T.
		IF THIS.PARENT.LSTRIGHT.LISTITEMID=0
		THIS.PARENT.LSTRIGHT.LISTITEMID = 1
		ENDIF
		IF THIS.PARENT.LSTRIGHT.LISTCOUNT=0 .OR. EMPTY(THIS.PARENT.ASELECTIONS(1))
		DIMENSION THIS.PARENT.ASELECTIONS[ALEN(ALISTITEMS, 1), 2]
		FOR I = 1 TO ALEN(ALISTITEMS, 1)
		THIS.PARENT.ASELECTIONS[M.I, 1] = ALISTITEMS(M.I)
		THIS.PARENT.ASELECTIONS[M.I, 2] = M.I
		ENDFOR
		ELSE
		NTMPLEN = ALEN(THIS.PARENT.ASELECTIONS, 1)+1
		NTMPLEN2 = ALEN(THIS.PARENT.ASELECTIONS, 1)+ALEN(ALISTITEMS, 1)
		DIMENSION THIS.PARENT.ASELECTIONS[M.NTMPLEN2, 2]
		FOR I = M.NTMPLEN TO M.NTMPLEN2
		THIS.PARENT.ASELECTIONS[M.I, 1] = ALISTITEMS(M.I+1-M.NTMPLEN)
		THIS.PARENT.ASELECTIONS[M.I, 2] = THIS.PARENT.LSTRIGHT.INDEXTOITEMID(M.I)
		ENDFOR
		ENDIF
		IF M.LSORTED
		THIS.PARENT.LSTRIGHT.SORTED = .T.
		ENDIF
		THIS.PARENT.LSTRIGHT.VALUE = M.CVALUE
		THIS.PARENT.REFRESH
		THISFORM.LOCKSCREEN = .F.
	ENDPROC

	PROCEDURE cmdRemoveAll.Click
		LOCAL ALISTITEMS, LSORTED, NARRLEN, CVALUE, I
		IF THIS.PARENT.LSTRIGHT.LISTCOUNT=0
		RETURN
		ENDIF
		THISFORM.LOCKSCREEN = .T.
		LSORTED = THIS.PARENT.SORTLEFT
		CVALUE = THIS.PARENT.LSTRIGHT.VALUE
		DIMENSION ALISTITEMS[THIS.PARENT.LSTRIGHT.LISTCOUNT, 1]
		FOR M.I = 1 TO THIS.PARENT.LSTRIGHT.LISTCOUNT
		ALISTITEMS[M.I, 1] = THIS.PARENT.LSTRIGHT.LIST(M.I)
		ENDFOR
		IF THIS.PARENT.USEARRAYS
		IF THIS.PARENT.LSTLEFT.LISTCOUNT=0
		DIMENSION THIS.PARENT.ACHOICES[1]
		= ACOPY(ALISTITEMS, THIS.PARENT.ACHOICES)
		ELSE
		NARRLEN = ALEN(THIS.PARENT.ACHOICES, 1)+1
		DIMENSION THIS.PARENT.ACHOICES[ALEN(THIS.PARENT.ACHOICES, 1)+ALEN(ALISTITEMS, 1)]
		= ACOPY(ALISTITEMS, THIS.PARENT.ACHOICES, 1, -1, M.NARRLEN)
		ENDIF
		IF M.LSORTED
		= ASORT(THIS.PARENT.ACHOICES)
		ENDIF
		THIS.PARENT.LSTLEFT.ROWSOURCETYPE = 5
		THIS.PARENT.LSTLEFT.ROWSOURCE = "THIS.Parent.aChoices"
		ELSE
		THIS.PARENT.LSTLEFT.SORTED = .F.
		THIS.PARENT.POPLIST(@ALISTITEMS, THIS.PARENT.LSTLEFT)
		IF M.LSORTED
		THIS.PARENT.LSTLEFT.SORTED = .T.
		ENDIF
		ENDIF
		THIS.PARENT.LSTRIGHT.CLEAR
		THIS.PARENT.UPDATED = .T.
		THIS.PARENT.LSTLEFT.VALUE = M.CVALUE
		IF THIS.PARENT.LSTLEFT.LISTITEMID=0
		THIS.PARENT.LSTLEFT.LISTITEMID = 1
		ENDIF
		THIS.PARENT.REFRESH
		THISFORM.LOCKSCREEN = .F.
	ENDPROC

ENDDEFINE

DEFINE CLASS _tablemover AS _fieldmover OF "_movers.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboData" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOpen" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\_movers.h"
	*<DefinedPropArrayMethod>
		*m: getdbcalias		&& Retrieves DBC alias.
		*m: getdbcdata		&& Retrieves DBC table fields.
		*m: getdbcname		&& Retrieves DBC name.
		*m: getdbctable		&& Retrieves DBC table.
		*m: getfreedata		&& Retrieves free table fields.
		*m: moverrefresh		&& Refreshes movers.
		*m: opentable		&& Routine opens datasource.
		*m: tablechange
		*m: usetable		&& Handles USEing datasource.
		*p: allowquery		&& Whether to allow queries.
		*p: allowviews		&& Whether to allow views.
		*p: excldbf		&& Name of table to exclude from list.
		*p: exclusiveset
		*p: lpublicsinuse
		*p: refreshcurrent
		*p: viewnodata		&& Whether to show view information without retreiving data.
	*</DefinedPropArrayMethod>

	allowquery = (.F.)		&& Whether to allow queries.
	allowviews = (.T.)		&& Whether to allow views.
	dbctable = ("")
	excldbf = ("")		&& Name of table to exclude from list.
	exclusiveset = 0
	Height = 140
	Name = "_tablemover"
	refreshcurrent = (.T.)
	refreshfields = (.T.)
	SpecialEffect = 2
	viewnodata = (.T.)		&& Whether to show view information without retreiving data.
	Width = 466
	cmdadd.Left = 298
	cmdadd.Name = "cmdadd"
	cmdadd.TabIndex = 7
	cmdadd.Top = 34
	cmdadd.Width = 22
	cmdaddall.Left = 298
	cmdaddall.Name = "cmdaddall"
	cmdaddall.TabIndex = 8
	cmdaddall.Top = 57
	cmdaddall.Width = 22
	cmdremove.Left = 298
	cmdremove.Name = "cmdremove"
	cmdremove.TabIndex = 9
	cmdremove.Top = 80
	cmdremove.Width = 22
	cmdremoveall.Left = 298
	cmdremoveall.Name = "cmdremoveall"
	cmdremoveall.TabIndex = 10
	cmdremoveall.Top = 103
	cmdremoveall.Width = 22
	label1.Caption = "Campos \<disponibles:"
	label1.Height = 14
	label1.Left = 152
	label1.Name = "label1"
	label1.TabIndex = 5
	label1.Top = 2
	label1.Width = 139
	label2.Caption = "Campos \<seleccionados:"
	label2.Height = 14
	label2.Left = 332
	label2.Name = "label2"
	label2.TabIndex = 11
	label2.Top = 2
	label2.Width = 143
	lstleft.Height = 123
	lstleft.ItemTips = .T.
	lstleft.Left = 152
	lstleft.Name = "lstleft"
	lstleft.TabIndex = 6
	lstleft.Top = 16
	lstleft.Width = 133
	lstright.Height = 123
	lstright.ItemTips = .T.
	lstright.Left = 332
	lstright.Name = "lstright"
	lstright.TabIndex = 12
	lstright.Top = 16
	lstright.Width = 133

	ADD OBJECT 'cboData' AS _combobox WITH ;
		Height = 25, ;
		Left = 0, ;
		Name = "cboData", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 16, ;
		Width = 114
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdOpen' AS _commandbutton WITH ;
		Caption = "...", ;
		Height = 23, ;
		Left = 121, ;
		Name = "cmdOpen", ;
		TabIndex = 3, ;
		Top = 17, ;
		Width = 22
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Label3' AS _label WITH ;
		Caption = "\<Bases de datos y tablas:", ;
		Height = 13, ;
		Left = 0, ;
		Name = "Label3", ;
		TabIndex = 1, ;
		Top = 1, ;
		Width = 139
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="label" />

	ADD OBJECT 'lstTables' AS _listbox WITH ;
		Height = 92, ;
		ItemTips = .T., ;
		Left = 0, ;
		Name = "lstTables", ;
		TabIndex = 4, ;
		Top = 47, ;
		Width = 143
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="listbox" />
	
	PROCEDURE Destroy
		DODEFAULT()
		IF  .NOT. THIS.LPUBLICSINUSE
		RELEASE ADBFLIST, ADBCLIST, ASKIPTABLES
		ENDIF
	ENDPROC

	PROCEDURE Error
		PARAMETER NERROR, CMETHOD, NLINE
		IF THIS.SKIPERROR
		IF NERROR=1977
		USE EXCLUSIVE (M.CGETDBF)
		RETURN
		ENDIF
		ENDIF
		DODEFAULT(NERROR, CMETHOD, NLINE)
	ENDPROC

	PROCEDURE getdbcalias		&& Retrieves DBC alias.
		LPARAMETERS CDBC
		LOCAL ADBCTMP, CGETDBC, NPOS
		IF TYPE("m.cDBC")<>"C"
		M.CDBC = ""
		ENDIF
		IF EMPTY(M.CDBC) .AND. EMPTY(DBC())
		RETURN ""
		ENDIF
		M.CGETDBC = IIF(EMPTY(M.CDBC), DBC(), UPPER(M.CDBC))
		DIMENSION ADBCTMP[1, 2]
		= ADATABASES(ADBCTMP)
		M.NPOS = ASCAN(ADBCTMP, M.CGETDBC)
		RETURN IIF(M.NPOS=0, "", ADBCTMP(M.NPOS-1))
	ENDPROC

	PROCEDURE getdbcdata		&& Retrieves DBC table fields.
		LPARAMETERS CDBCNAME
		LOCAL NDBCCOUNT, I, CTMPLISTSTR, NSCANPOS, CTMPALIAS, NVIEWCOUNT
		LOCAL ATMPARR, ATMPARR2, ADBCTABLES, NTBLCOUNT, CTMPVIEW, COLDEXCL
		DIMENSION ATMPARR[1]
		DIMENSION ATMPARR2[1]
		DIMENSION ADBCTABLES[1]
		M.CTMPALIAS = ""
		M.CTMPLISTSTR = ""
		M.CDBCNAME = ALLTRIM(M.CDBCNAME)
		IF EMPTY(M.CDBCNAME)
		RETURN
		ENDIF
		SET DATABASE TO (M.CDBCNAME)
		IF EMPTY(DBC())
		COLDEXCL = SET("EXCL")
		DO CASE
		CASE TYPE("THIS.ExclusiveSet")<>"N"
		CASE THIS.EXCLUSIVESET=1
		SET EXCLUSIVE OFF
		CASE THIS.EXCLUSIVESET=2
		SET EXCLUSIVE ON
		ENDCASE
		OPEN DATABASE (M.CDBCNAME)
		SET EXCLUSIVE &COLDEXCL
		IF EMPTY(DBC())
		RETURN
		ENDIF
		ENDIF
		THIS.CURRENTDBC = DBC()
		IF THIS.CBODATA.LISTCOUNT=0
		THIS.CBODATA.ADDITEM("Tablas libres")
		ENDIF
		IF THIS.CBODATA.LISTCOUNT=1
		THIS.CBODATA.ADDITEM("\-")
		ENDIF
		FOR I = 1 TO THIS.CBODATA.LISTCOUNT
		IF ALLTRIM(THIS.CBODATA.LISTITEM(M.I))=M.CDBCNAME
		EXIT
		ENDIF
		ENDFOR
		IF ALLTRIM(THIS.CBODATA.LISTITEM(M.I))<>M.CDBCNAME
		THIS.CBODATA.ADDITEM(M.CDBCNAME)
		ENDIF
		THIS.CBODATA.VALUE = M.CDBCNAME
		M.NDBCCOUNT = ADBOBJECTS(ATMPARR, "TABLE")
		M.NVIEWCOUNT = ADBOBJECTS(ATMPARR2, "VIEW")
		IF  .NOT. THIS.ALLOWVIEWS
		M.NVIEWCOUNT = 0
		ENDIF
		IF M.NVIEWCOUNT>1
		FOR I = M.NVIEWCOUNT TO 1 STEP -1
		IF DBGETPROP(ATMPARR2(M.I), "view", "sourcetype")=2
		M.CTMPVIEW = ATMPARR2(M.I)
		= ADEL(ATMPARR2, M.I)
		ATMPARR2[M.NVIEWCOUNT] = M.CTMPVIEW
		ENDIF
		ENDFOR
		ENDIF
		IF M.NDBCCOUNT+M.NVIEWCOUNT=0
		SELECT 0
		ELSE
		DIMENSION ADBCTABLES[M.NDBCCOUNT+M.NVIEWCOUNT, 2]
		FOR I = 1 TO M.NDBCCOUNT
		ADBCTABLES[M.I, 1] = ATMPARR(M.I)
		ADBCTABLES[M.I, 2] = FULLPATH(DBGETPROP(ATMPARR(M.I), 'TABLE', 'path'), DBC())
		ENDFOR
		FOR I = 1 TO M.NVIEWCOUNT
		ADBCTABLES[M.I+M.NDBCCOUNT, 1] = ATMPARR2(M.I)
		ADBCTABLES[M.I+M.NDBCCOUNT, 2] = ATMPARR2(M.I)
		ENDFOR
		ENDIF
		THIS.LSTTABLES.CLEAR()
		IF THIS.REFRESHFIELDS
		THIS.LSTLEFT.CLEAR()
		THIS.CMDADD.ENABLED = .F.
		THIS.CMDADDALL.ENABLED = .F.
		IF  .NOT. THIS.MULTITABLE
		THIS.LSTRIGHT.CLEAR()
		THIS.CMDREMOVE.ENABLED = .F.
		THIS.CMDREMOVEALL.ENABLED = .F.
		ENDIF
		ENDIF
		IF M.NDBCCOUNT>0
		FOR I = 1 TO M.NDBCCOUNT
		IF ASCAN(ASKIPTABLES, ADBCTABLES(M.I, 2))<>0 .OR. ADBCTABLES(M.I, 2)==UPPER(THIS.EXCLDBF)
		LOOP
		ENDIF
		THIS.LSTTABLES.ADDITEM(UPPER(ADBCTABLES(M.I, 1)))
		ENDFOR
		THIS.LSTTABLES.PICTURE[0] = "dbtable.bmp"
		ENDIF
		M.NTBLCOUNT = THIS.LSTTABLES.LISTCOUNT
		IF M.NVIEWCOUNT>0
		M.CTMPLISTSTR = ""
		FOR I = 1 TO M.NVIEWCOUNT
		IF UPPER(ATMPARR2(M.I))==UPPER(THIS.EXCLDBF)
		LOOP
		ENDIF
		THIS.LSTTABLES.ADDITEM(UPPER(ATMPARR2(M.I)))
		ENDFOR
		FOR I = (M.NTBLCOUNT+1) TO THIS.LSTTABLES.LISTCOUNT
		IF DBGETPROP(ALLTRIM(THIS.LSTTABLES.LIST(M.I)), "view", "sourcetype")=1
		THIS.LSTTABLES.PICTURE[M.I] = "dblview.bmp"
		ELSE
		THIS.LSTTABLES.PICTURE[M.I] = "dbrview.bmp"
		ENDIF
		ENDFOR
		ENDIF
		IF  .NOT. EMPTY(ALIAS())
		IF THIS.GETDBCNAME()==DBC() .AND. ASCAN(ASKIPTABLES, DBF())=0 .AND. UPPER(THIS.EXCLDBF)<>DBF()
		DO CASE
		CASE CURSORGETPROP("SourceType")=3
		M.NSCANPOS = ASCAN(ADBCTABLES, DBF())
		IF M.NSCANPOS<>0
		THIS.DBCTABLE = ADBCTABLES(M.NSCANPOS-1)
		THIS.LSTTABLES.VALUE = THIS.DBCTABLE
		ELSE
		SELECT 0
		ENDIF
		OTHERWISE
		M.NSCANPOS = ASCAN(ATMPARR2, ALIAS())
		IF  .NOT. THIS.ALLOWVIEWS .OR. M.NSCANPOS=0
		SELECT 0
		ELSE
		THIS.DBCTABLE = ALIAS()
		THIS.LSTTABLES.VALUE = THIS.DBCTABLE
		ENDIF
		ENDCASE
		ELSE
		SELECT 0
		ENDIF
		ENDIF
		IF EMPTY(ALIAS())
		FOR I = 1 TO (M.NDBCCOUNT+M.NVIEWCOUNT)
		IF ASCAN(ASKIPTABLES, ADBCTABLES(M.I, 2))<>0 .OR. UPPER(THIS.EXCLDBF)==ADBCTABLES(M.I, 2)
		LOOP
		ENDIF
		THIS.GETDBCTABLE(ADBCTABLES(M.I, 1))
		IF  .NOT. EMPTY(ALIAS())
		THIS.DBCTABLE = ADBCTABLES(M.I, 1)
		THIS.LSTTABLES.VALUE = THIS.DBCTABLE
		EXIT
		ENDIF
		ENDFOR
		ENDIF
		IF  .NOT. EMPTY(ALIAS())
		THIS.GETTABLEDATA()
		ENDIF
		THIS.LSTTABLES.ENABLED = (THIS.LSTTABLES.LISTCOUNT<>0)
		IF THIS.LSTTABLES.LISTCOUNT<>0 .AND. THIS.LSTTABLES.LISTINDEX=0
		THIS.LSTTABLES.LISTINDEX = 1
		ENDIF
	ENDPROC

	PROCEDURE getdbcname		&& Retrieves DBC name.
		LPARAMETERS XX
		LOCAL M.RETVAL
		IF TYPE("m.XX")='L'
		XX = SELECT()
		ENDIF
		M.RETVAL = CURSORGETPROP("database", M.XX)
		IF  .NOT. EMPTY(M.RETVAL) .AND.  .NOT. EMPTY(DBC())
		IF CURSORGETPROP("sourcetype", M.XX)=3 .AND.  .NOT. INDBC(CURSORGETPROP("sourcename", M.XX), "table") .OR. CURSORGETPROP("sourcetype", M.XX)<>3 .AND.  .NOT. INDBC(CURSORGETPROP("sourcename", M.XX), "view")
		M.RETVAL = ""
		ENDIF
		ENDIF
		RETURN M.RETVAL
	ENDPROC

	PROCEDURE getdbctable		&& Retrieves DBC table.
		LPARAMETERS CDBCTABLE
		LOCAL CDBFNAME, ATMPARR, M.I
		DIMENSION ATMPARR[1]
		M.CDBFNAME = ""
		DO CASE
		CASE ADBOBJECTS(ATMPARR, "table")>0 .AND. ASCAN(ATMPARR, UPPER(M.CDBCTABLE), 1, 3)<>0
		M.CDBFNAME = FULLPATH(DBGETPROP(M.CDBCTABLE, 'TABLE', 'path'), DBC())
		FOR M.I = 1 TO ALEN(ADBCLIST, 1)
		IF  .NOT. EMPTY(ADBCLIST(M.I, 1)) .AND. CURSORGETPROP("sourcetype", ADBCLIST(M.I, 2))=3 .AND. M.CDBFNAME==ADBCLIST(M.I, 1)
		SELECT (ADBCLIST(M.I, 2))
		RETURN
		ENDIF
		ENDFOR
		CASE ADBOBJECTS(ATMPARR, "view")>0 .AND. ASCAN(ATMPARR, UPPER(M.CDBCTABLE), 1, 3)<>0
		M.CDBFNAME = UPPER(M.CDBCTABLE)
		FOR M.I = 1 TO ALEN(ADBCLIST, 1)
		IF  .NOT. EMPTY(ADBCLIST(M.I, 1)) .AND. CURSORGETPROP("sourcetype", ADBCLIST(M.I, 2))<>3 .AND. M.CDBFNAME==ADBCLIST(M.I, 1)
		SELECT (ADBCLIST(M.I, 2))
		RETURN
		ENDIF
		ENDFOR
		OTHERWISE
		RETURN
		ENDCASE
		THIS.USETABLE(M.CDBFNAME)
		IF  .NOT. EMPTY(ALIAS()) .AND. EMPTY(THIS.GETDBCNAME())
		THIS.ALERT("La tabla seleccionada no tiene un vínculo primario válido a su DBC. "+"Puede solucionarlo con el comando VALIDATE DATABASE RECOVER.")
		ENDIF
	ENDPROC

	PROCEDURE getfreedata		&& Retrieves free table fields.
		LOCAL CCURRDATA, NCOUNT
		CCURRDATA = SET("DATABASE")
		SET DATABASE TO
		IF THIS.CBODATA.LISTCOUNT=0
		THIS.CBODATA.ADDITEM("Tablas libres")
		ENDIF
		THIS.CBODATA.VALUE = "Tablas libres"
		THIS.LSTTABLES.CLEAR()
		THIS.LSTTABLES.PICTURE[0] = ""
		IF  .NOT. EMPTY(ADBFLIST(1))
		IF UPPER(THIS.EXCLDBF)==DBF()
		SELECT 0
		ENDIF
		FOR NCOUNT = 1 TO ALEN(ADBFLIST, 1)
		IF UPPER(THIS.EXCLDBF)==UPPER(ADBFLIST(M.NCOUNT, 1))
		LOOP
		ENDIF
		THIS.LSTTABLES.ADDITEM(ADBFLIST(M.NCOUNT, 2))
		IF EMPTY(ALIAS())
		IF USED(ADBFLIST(M.NCOUNT, 2))
		SELECT (ADBFLIST(M.NCOUNT, 2))
		ENDIF
		ENDIF
		ENDFOR
		THIS.LSTTABLES.VALUE = ALIAS()
		ELSE
		SELECT 0
		ENDIF
		THIS.GETTABLEDATA()
		IF THIS.LSTTABLES.LISTCOUNT<>0 .AND. THIS.LSTTABLES.LISTINDEX=0
		THIS.LSTTABLES.LISTINDEX = 1
		ENDIF
		IF  .NOT. THIS.LSTTABLES.ENABLED .AND.  .NOT. EMPTY(ALIAS())
		THIS.LSTTABLES.ENABLED = .T.
		ENDIF
	ENDPROC

	PROCEDURE Init
		IF TYPE("aSkipTables")<>"U"
		THIS.LPUBLICSINUSE = .T.
		ENDIF
		DODEFAULT()
	ENDPROC

	PROCEDURE initdata
		LOCAL NTOTWORKAREAS, NCOUNT, I, CCURRDBC, ADBC, NWORKAREA
		LOCAL COLDEXACT, NTOTTABLES, LISINDBC, AWORKAREAS
		THIS.INITVARS
		THIS.ADDTOARRAY(@ASKIPTABLES, "FORMSTYLES")
		DIMENSION ADBFLIST[1, 2]
		DIMENSION ADBCLIST[1, 2]
		DIMENSION AWORKAREAS[1]
		DIMENSION ADBC[1]
		STORE "" TO ADBFLIST, ADBCLIST, ADBC, AWORKAREAS
		COLDEXACT = SET("EXACT")
		SET EXACT ON
		M.LISINDBC = .F.
		FOR I = 1 TO ALEN(ASKIPTABLES, 1)
		IF  .NOT. EMPTY(ASKIPTABLES(M.I, 1)) .AND. USED(ASKIPTABLES(M.I, 1))
		ASKIPTABLES[M.I] = DBF(ASKIPTABLES(M.I, 1))
		ENDIF
		ENDFOR
		THIS.CBODATA.ADDITEM("Tablas libres")
		THIS.CBODATA.VALUE = "Tablas libres"
		M.NDBCCOUNT = ADATABASES(ADBC)
		FOR I = 1 TO M.NDBCCOUNT
		IF M.I=1
		THIS.CBODATA.ADDITEM("\-")
		ENDIF
		THIS.CBODATA.ADDITEM(ADBC(M.I, 1))
		ENDFOR
		M.NTOTWORKAREAS = AUSED(AWORKAREAS)
		FOR M.NCOUNT = 1 TO M.NTOTWORKAREAS
		M.NWORKAREA = AWORKAREAS(M.NCOUNT, 2)
		DO CASE
		CASE ASCAN(ASKIPTABLES, DBF(M.NWORKAREA))<>0
		LOOP
		CASE ISREADONLY(M.NWORKAREA) .AND.  .NOT. THIS.ALLOWREADONLY
		LOOP
		CASE EMPTY(THIS.GETDBCNAME(M.NWORKAREA))
		IF ATC(".TMP", DBF(M.NWORKAREA))<>0 .AND.  .NOT. THIS.ALLOWQUERY
		LOOP
		ENDIF
		IF  .NOT. EMPTY(ADBFLIST(1))
		DIMENSION ADBFLIST[ALEN(ADBFLIST, 1)+1, 2]
		ENDIF
		ADBFLIST[ALEN(ADBFLIST, 1), 1] = DBF(M.NWORKAREA)
		ADBFLIST[ALEN(ADBFLIST, 1), 2] = ALIAS(M.NWORKAREA)
		OTHERWISE
		IF  .NOT. THIS.ALLOWVIEWS .AND. CURSORGETPROP("sourcetype", M.NWORKAREA)<>3
		LOOP
		ENDIF
		IF  .NOT. EMPTY(ADBCLIST(1))
		DIMENSION ADBCLIST[ALEN(ADBCLIST, 1)+1, 2]
		ENDIF
		IF CURSORGETPROP("sourcetype", M.NWORKAREA)<>3
		ADBCLIST[ALEN(ADBCLIST, 1), 1] = UPPER(CURSORGETPROP("sourcename", M.NWORKAREA))
		ELSE
		ADBCLIST[ALEN(ADBCLIST, 1), 1] = DBF(M.NWORKAREA)
		ENDIF
		ADBCLIST[ALEN(ADBCLIST, 1), 2] = ALIAS(M.NWORKAREA)
		ENDCASE
		ENDFOR
		= ASORT(ADBFLIST, 1)
		THIS.CURRENTDBC = DBC()
		M.CCURRDBC = ""
		IF  .NOT. EMPTY(ALIAS())
		DO CASE
		CASE ASCAN(ASKIPTABLES, DBF())<>0
		SELECT 0
		CASE  .NOT. THIS.ALLOWREADONLY .AND. ISREADONLY()
		SELECT 0
		CASE EMPTY(THIS.GETDBCNAME()) .AND.  .NOT. THIS.ALLOWQUERY .AND. ATC(".TMP", DBF())<>0
		SELECT 0
		CASE  .NOT. THIS.ALLOWVIEWS .AND. CURSORGETPROP("sourcetype")<>3
		SELECT 0
		ENDCASE
		ENDIF
		DO CASE
		CASE  .NOT. EMPTY(ALIAS())
		M.CCURRDBC = THIS.GETDBCNAME()
		M.LISINDBC =  .NOT. EMPTY(M.CCURRDBC)
		IF M.LISINDBC .AND. DBC()<>M.CCURRDBC
		SET DATABASE TO (M.CCURRDBC)
		ENDIF
		CASE  .NOT. EMPTY(DBC())
		M.LISINDBC = .T.
		CASE  .NOT. EMPTY(ADBFLIST(1))
		SELECT (ADBFLIST(1, 2))
		CASE  .NOT. EMPTY(ADBC(1))
		M.LISINDBC = .T.
		SET DATABASE TO (ADBC(1))
		ENDCASE
		IF M.LISINDBC .AND.  .NOT. EMPTY(ALIAS())
		LOCAL CSNAME
		CSNAME = CURSORGETPROP('sourcename')
		IF THIS.ALLOWQUERY .AND. ATC(".TMP", DBF())<>0 .AND. M.CSNAME<>ALIAS() .AND. USED(M.CSNAME) .AND. M.CSNAME<>DBF()
		IF  .NOT. EMPTY(ADBFLIST(1))
		DIMENSION ADBFLIST[ALEN(ADBFLIST, 1)+1, 2]
		ENDIF
		ADBFLIST[ALEN(ADBFLIST, 1), 1] = DBF()
		ADBFLIST[ALEN(ADBFLIST, 1), 2] = ALIAS()
		M.LISINDBC = .F.
		ENDIF
		ENDIF
		IF M.LISINDBC
		THIS.CURRENTDBC = DBC()
		THIS.CBODATA.VALUE = THIS.GETDBCALIAS()
		THIS.GETDBCDATA(THIS.CBODATA.VALUE)
		ELSE
		THIS.GETFREEDATA()
		ENDIF
		IF THIS.LSTTABLES.LISTCOUNT=0
		THIS.LSTTABLES.ENABLED = .F.
		THIS.LSTLEFT.ENABLED = .F.
		THIS.LSTRIGHT.ENABLED = .F.
		ENDIF
		SET EXACT &COLDEXACT
	ENDPROC

	PROCEDURE initvars
		DODEFAULT()
		THIS.EXCLDBF = IIF(TYPE("THIS.ExclDBF")="C", THIS.EXCLDBF, "")
		THIS.REFRESHFIELDS = IIF(TYPE("THIS.RefreshFields")="L", THIS.REFRESHFIELDS, .T.)
		THIS.VIEWNODATA = IIF(TYPE("THIS.ViewNoData")="L", THIS.VIEWNODATA, .T.)
		THIS.ALLOWVIEWS = IIF(TYPE("THIS.AllowViews")="L", THIS.ALLOWVIEWS, .T.)
		THIS.ALLOWQUERY = IIF(TYPE("THIS.AllowQuery")="L", THIS.ALLOWQUERY, .F.)
		PUBLIC ASKIPTABLES, ADBFLIST, ADBCLIST
		IF TYPE("aSkipTables[1]")<>"C"
		DIMENSION ASKIPTABLES[1]
		ASKIPTABLES = ""
		ENDIF
		IF TYPE("aDBFList[1]")<>"C"
		DIMENSION ADBFLIST[1, 2]
		ADBFLIST = ""
		ENDIF
		IF TYPE("aDBCList[1]")<>"C"
		DIMENSION ADBCLIST[1, 2]
		ADBCLIST = ""
		ENDIF
	ENDPROC

	PROCEDURE moverrefresh		&& Refreshes movers.
		LPARAMETERS LREFRESH, LQUICKPASS, CSAVELSTVALUE
		LOCAL LOLDREFRESH, ATMPDATA, I, APOPITEMS
		M.LOLDREFRESH = IIF(TYPE("THIS.RefreshFields")="L", THIS.REFRESHFIELDS, .T.)
		M.LQUICKPASS = IIF(TYPE("m.lQuickPass")="L", M.LQUICKPASS, .F.)
		THIS.REFRESHFIELDS = IIF(PARAMETERS()<>0 .AND. TYPE("m.lRefresh")="L", M.LREFRESH, M.LOLDREFRESH)
		THIS.REFRESHCURRENT = IIF(TYPE("THIS.RefreshCurrent")="L", THIS.REFRESHCURRENT, .T.)
		IF THIS.REFRESHCURRENT
		THIS.CURRENTDBC = DBC()
		THIS.CURRENTALIAS = ALIAS()
		ENDIF
		DIMENSION ATMPDATA[1, 2]
		DIMENSION APOPITEMS[1]
		STORE "" TO ATMPDATA, APOPITEMS
		IF ADATABASES(ATMPDATA)>0
		IF THIS.CBODATA.LISTCOUNT=0
		THIS.CBODATA.ADDITEM("Tablas libres")
		ENDIF
		IF THIS.CBODATA.LISTCOUNT=1
		THIS.CBODATA.ADDITEM("\-")
		ENDIF
		DIMENSION APOPITEMS[THIS.CBODATA.LISTCOUNT]
		FOR I = 1 TO THIS.CBODATA.LISTCOUNT
		APOPITEMS[M.I] = ALLTRIM(THIS.CBODATA.LISTITEM(M.I))
		ENDFOR
		FOR I = 1 TO ALEN(ATMPDATA, 1)
		IF ASCAN(APOPITEMS, ATMPDATA(M.I, 1))=0
		THIS.CBODATA.ADDITEM(ATMPDATA(M.I, 1))
		ENDIF
		ENDFOR
		ENDIF
		IF  .NOT. EMPTY(THIS.CURRENTALIAS)
		IF USED(THIS.CURRENTALIAS)
		SELECT (THIS.CURRENTALIAS)
		ELSE
		THIS.REFRESHFIELDS = .T.
		THIS.CURRENTALIAS = ""
		SELECT 0
		ENDIF
		ELSE
		THIS.REFRESHFIELDS = .T.
		ENDIF
		IF  .NOT. EMPTY(THIS.CURRENTALIAS) .AND. THIS.EXCLDBF==DBF(THIS.CURRENTALIAS)
		THIS.REFRESHFIELDS = .T.
		THIS.CURRENTALIAS = ""
		SELECT 0
		ENDIF
		CSAVELSTVALUE = IIF(EMPTY(THIS.CURRENTALIAS), "", THIS.LSTTABLES.VALUE)
		IF  .NOT. EMPTY(THIS.CURRENTDBC)
		SET DATABASE TO (THIS.CURRENTDBC)
		IF THIS.REFRESHFIELDS .OR.  .NOT. M.LQUICKPASS
		THIS.CBODATA.VALUE = THIS.GETDBCALIAS()
		THIS.GETDBCDATA(THIS.CBODATA.VALUE)
		ENDIF
		ELSE
		THIS.GETFREEDATA()
		ENDIF
		IF  .NOT. EMPTY(M.CSAVELSTVALUE)
		THIS.LSTTABLES.VALUE = M.CSAVELSTVALUE
		ENDIF
		THIS.REFRESHFIELDS = M.LOLDREFRESH
	ENDPROC

	PROCEDURE opentable		&& Routine opens datasource.
		LOCAL CGETDBF, SOLDSAFE, NPOS, COLDEXCL
		LOCAL SOLDAREA, CCURRDBC, CTMPDBC
		M.SOLDSAFE = SET('SAFETY')
		SET SAFETY OFF
		M.SOLDAREA = SELECT()
		M.CCURRDBC = DBC()
		SET DATABASE TO
		DO WHILE .T.
		M.CGETDBF = ""
		M.CGETDBF = GETFILE('DBF|DBC', "Abrir el archivo:")
		IF EMPTY(M.CGETDBF)
		IF EMPTY(M.CCURRDBC)
		SET DATABASE TO
		ELSE
		SET DATABASE TO (M.CCURRDBC)
		ENDIF
		SELECT (M.SOLDAREA)
		EXIT
		ENDIF
		IF ASCAN(ASKIPTABLES, M.CGETDBF, 1, 3)<>0 .OR. UPPER(THIS.EXCLDBF)==M.CGETDBF
		M.CGETDBF = ""
		IF EMPTY(M.CCURRDBC)
		SET DATABASE TO
		ELSE
		SET DATABASE TO (M.CCURRDBC)
		ENDIF
		SELECT (M.SOLDAREA)
		THIS.ALERT("El archivo está en uso. Seleccione otro.")
		EXIT
		ENDIF
		IF RIGHT(M.CGETDBF, 4)=".DBC"
		THIS.SKIPERROR = .T.
		COLDEXCL = SET("EXCL")
		DO CASE
		CASE TYPE("THIS.ExclusiveSet")<>"N"
		CASE THIS.EXCLUSIVESET=1
		SET EXCLUSIVE OFF
		CASE THIS.EXCLUSIVESET=2
		SET EXCLUSIVE ON
		ENDCASE
		OPEN DATABASE (M.CGETDBF)
		SET EXCLUSIVE &COLDEXCL
		THIS.SKIPERROR = .F.
		IF EMPTY(DBC())
		LOOP
		ELSE
		EXIT
		ENDIF
		ENDIF
		NPOS = ASCAN(ADBCLIST, M.CGETDBF, 1, 3)
		IF M.NPOS<>0
		SELECT (ADBCLIST(M.NPOS+1))
		M.CTMPDBC = THIS.GETDBCNAME()
		IF DBC()<>THIS.GETDBCNAME()
		SET DATABASE TO (M.CTMPDBC)
		ENDIF
		EXIT
		ENDIF
		NPOS = ASCAN(ADBFLIST, M.CGETDBF, 1, 3)
		IF M.NPOS<>0
		SELECT (ADBFLIST(M.NPOS+1))
		EXIT
		ENDIF
		THIS.USETABLE(M.CGETDBF, .T.)
		IF  .NOT. EMPTY(ALIAS())
		EXIT
		ENDIF
		ENDDO
		SET SAFETY &SOLDSAFE
		RETURN M.CGETDBF
	ENDPROC

	PROCEDURE tablechange
	ENDPROC

	PROCEDURE usetable		&& Handles USEing datasource.
		LPARAMETERS CGETDBF, LUSEEXCL
		LOCAL CTMPALIAS, NTMPCOUNT, CALIAS, COLDSAFE, BADCHARS, GOODCHARS, I, COLDEXCL
		LUSEEXCL = IIF(PCOUNT()>1, "EXCLUSIVE", "SHARED")
		CALIAS = THIS.JUSTSTEM(M.CGETDBF)
		IF VERSION(3)$"81 82 86 88"
		M.BADCHARS = '/,-=:;!@#$%&*.<>()?'+'+'+CHR(34)+CHR(39)+" "
		ELSE
		M.BADCHARS = ' ¡¢£¤¥/\,-=:;{}[]!@#$%^&*.<>()?'+'+|¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ'+'ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþ'+CHR(34)+CHR(39)+" "
		ENDIF
		M.GOODCHARS = ""
		FOR I = 1 TO LEN(M.BADCHARS)
		IF ISALPHA(SUBSTR(M.BADCHARS, M.I, 1))
		M.GOODCHARS = M.GOODCHARS+SUBSTR(M.BADCHARS, M.I, 1)
		ENDIF
		ENDFOR
		M.BADCHARS = CHRTRAN(M.BADCHARS, M.GOODCHARS, '')
		M.CALIAS = CHRTRAN(M.CALIAS, M.BADCHARS, REPLICATE("_", LEN(M.BADCHARS)))
		IF ISDIGIT(M.CALIAS)
		M.CALIAS = '_'+M.CALIAS
		ENDIF
		M.CTMPALIAS = M.CALIAS
		SELECT 0
		M.NTMPCOUNT = 1
		DO WHILE .T.
		IF  .NOT. USED(M.CTMPALIAS)
		EXIT
		ENDIF
		M.CTMPALIAS = M.CALIAS+"_"+ALLTRIM(STR(M.NTMPCOUNT))
		M.NTMPCOUNT = M.NTMPCOUNT+1
		ENDDO
		THIS.SKIPERROR = .T.
		M.COLDSAFE = SET("SAFETY")
		SET SAFETY OFF
		M.COLDEXCL = SET("EXCL")
		DO CASE
		CASE TYPE("THIS.ExclusiveSet")<>"N"
		CASE THIS.EXCLUSIVESET=1
		SET EXCLUSIVE OFF
		CASE THIS.EXCLUSIVESET=2
		SET EXCLUSIVE ON
		ENDCASE
		IF THIS.VIEWNODATA
		USE (M.CGETDBF) AGAIN NODATA ALIAS (M.CTMPALIAS) &LUSEEXCL 
		ELSE
		USE (M.CGETDBF) AGAIN ALIAS (M.CTMPALIAS) &LUSEEXCL
		ENDIF
		THIS.SKIPERROR = .F.
		SET SAFETY &COLDSAFE
		SET EXCLUSIVE &COLDEXCL
		IF EMPTY(ALIAS())
		RETURN
		ENDIF
		IF ISREADONLY() .AND. TYPE('THIS.AllowReadOnly')="L" .AND.  .NOT. THIS.ALLOWREADONLY
		USE
		THIS.ALERT("El archivo es de sólo lectura y esta aplicación no puede utilizarlo. Seleccione otro.")
		RETURN
		ENDIF
		IF EMPTY(THIS.GETDBCNAME())
		IF  .NOT. EMPTY(ADBFLIST(1))
		DIMENSION ADBFLIST[ALEN(ADBFLIST, 1)+1, 2]
		ENDIF
		ADBFLIST[ALEN(ADBFLIST, 1), 1] = DBF()
		ADBFLIST[ALEN(ADBFLIST, 1), 2] = ALIAS()
		THIS.LSTTABLES.ADDITEM(ALIAS())
		ELSE
		IF  .NOT. EMPTY(ADBCLIST(1))
		DIMENSION ADBCLIST[ALEN(ADBCLIST, 1)+1, 2]
		ENDIF
		IF CURSORGETPROP("SourceType")<>3
		ADBCLIST[ALEN(ADBCLIST, 1), 1] = CURSORGETPROP("SourceName")
		ELSE
		ADBCLIST[ALEN(ADBCLIST, 1), 1] = DBF()
		ENDIF
		ADBCLIST[ALEN(ADBCLIST, 1), 2] = ALIAS()
		ENDIF
	ENDPROC

	PROCEDURE cboData.InteractiveChange
		LOCAL CNEWTABLE, LHADDBC, LOLDLOCK, OLDREFRESH
		M.LHADDBC =  .NOT. EMPTY(DBC())
		M.CNEWTABLE = ""
		M.LOLDLOCK = THISFORM.LOCKSCREEN
		THISFORM.LOCKSCREEN = .T.
		M.LOLDREFRESH = THIS.PARENT.REFRESHFIELDS
		THIS.PARENT.REFRESHFIELDS = .T.
		DO CASE
		CASE THIS.VALUE="Tablas libres" .AND.  .NOT. M.LHADDBC
		CASE M.LHADDBC .AND. THIS.VALUE==THIS.PARENT.GETDBCALIAS()
		CASE THIS.VALUE<>"Tablas libres"
		THIS.PARENT.GETDBCDATA(THIS.VALUE)
		THIS.PARENT.TABLECHANGE()
		OTHERWISE
		SELECT 0
		THIS.PARENT.GETFREEDATA()
		THIS.PARENT.LSTTABLES.ENABLED =  .NOT. EMPTY(ADBFLIST(1))
		THIS.PARENT.LSTLEFT.ENABLED =  .NOT. EMPTY(ADBFLIST(1))
		IF  .NOT. THIS.PARENT.MULTITABLE
		THIS.PARENT.LSTRIGHT.ENABLED =  .NOT. EMPTY(ADBFLIST(1))
		ENDIF
		THIS.PARENT.TABLECHANGE()
		IF THIS.PARENT.LSTTABLES.LISTCOUNT<>0 .AND. THIS.PARENT.LSTTABLES.LISTINDEX=0
		THIS.PARENT.LSTTABLES.LISTINDEX = 1
		ENDIF
		ENDCASE
		THISFORM.LOCKSCREEN = M.LOLDLOCK
		THIS.PARENT.REFRESHFIELDS = M.LOLDREFRESH
	ENDPROC

	PROCEDURE cmdOpen.Click
		LOCAL LHASDBC, CDBCALIAS, LOLDLOCK, LOLDREFRESH, ADBCTABLES, CNEWTABLE
		DIMENSION ADBCTABLES[1]
		M.LHASDBC =  .NOT. EMPTY(DBC())
		M.CNEWTABLE = THIS.PARENT.OPENTABLE()
		M.LOLDLOCK = THISFORM.LOCKSCREEN
		THISFORM.LOCKSCREEN = .T.
		M.LOLDREFRESH = THIS.PARENT.REFRESHFIELDS
		THIS.PARENT.REFRESHFIELDS = .T.
		M.CDBCALIAS = THIS.PARENT.GETDBCALIAS()
		DO CASE
		CASE EMPTY(M.CNEWTABLE)
		THIS.PARENT.CBODATA.VALUE = IIF(EMPTY(DBC()), "Tablas libres", M.CDBCALIAS)
		CASE RIGHT(M.CNEWTABLE, 4)=".DBC" .OR.  .NOT. EMPTY(THIS.PARENT.GETDBCNAME())
		IF RIGHT(M.CNEWTABLE, 4)<>".DBC"
		M.CDBCALIAS = THIS.PARENT.GETDBCALIAS(THIS.PARENT.GETDBCNAME())
		ENDIF
		DO CASE
		CASE THIS.PARENT.CBODATA.VALUE<>M.CDBCALIAS
		THIS.PARENT.GETDBCDATA(M.CDBCALIAS)
		OTHERWISE
		THIS.PARENT.LSTTABLES.VALUE = UPPER(CURSORGETPROP('sourcename'))
		THIS.PARENT.GETTABLEDATA()
		ENDCASE
		THIS.PARENT.TABLECHANGE()
		OTHERWISE
		IF M.LHASDBC
		THIS.PARENT.GETFREEDATA()
		ELSE
		THIS.PARENT.GETTABLEDATA()
		ENDIF
		THIS.PARENT.LSTTABLES.VALUE = ALIAS()
		THIS.PARENT.TABLECHANGE()
		ENDCASE
		THIS.PARENT.LSTTABLES.ENABLED = (THIS.PARENT.LSTTABLES.LISTCOUNT<>0)
		THISFORM.LOCKSCREEN = M.LOLDLOCK
		THIS.PARENT.REFRESHFIELDS = M.LOLDREFRESH
	ENDPROC

	PROCEDURE lstTables.Init
		THIS.VALUE = ""
	ENDPROC

	PROCEDURE lstTables.InteractiveChange
		IF EMPTY(THIS.LIST(1))
		RETURN
		ENDIF
		IF EMPTY(THIS.VALUE)
		THIS.VALUE = THIS.LIST(1)
		ENDIF
		LOCAL LOLDLOCK, LOLDREFRESH
		M.LOLDREFRESH = THIS.PARENT.REFRESHFIELDS
		THIS.PARENT.REFRESHFIELDS = .T.
		M.LOLDLOCK = THISFORM.LOCKSCREEN
		THISFORM.LOCKSCREEN = .T.
		IF  .NOT. EMPTY(DBC())
		THIS.PARENT.GETDBCTABLE(ALLTRIM(THIS.VALUE))
		THIS.PARENT.DBCTABLE = ALLTRIM(THIS.VALUE)
		ELSE
		SELECT (THIS.VALUE)
		ENDIF
		THIS.PARENT.GETTABLEDATA()
		THIS.PARENT.TABLECHANGE()
		THISFORM.LOCKSCREEN = M.LOLDLOCK
		THIS.PARENT.REFRESHFIELDS = M.LOLDREFRESH
	ENDPROC

ENDDEFINE
