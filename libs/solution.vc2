*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="solution.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS behindscenes AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = ""
	Height = 23
	Name = "behindscenes"
	Picture = bts.bmp
	ToolTipText = "Ayuda"
	Width = 25
	
	PROCEDURE Click
		IF THISFORM.HELPCONTEXTID>0
		HELP ID (THISFORM.HELPCONTEXTID)
		ELSE
		HELP
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS c_solutions AS custom 		&& funcionalidad común del ejemplo solutions
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addtopath
		*m: getdirectory
		*m: restorehelp		&& Restaura el valor de archivo de Ayuda guardado anteriormente.
		*m: savehelp		&& Guarda el valor actual del archivo de Ayuda.
		*p: autosetdefault		&& Si se debe establecer o no el directorio predeterminado en el Init de la clase
		*p: ccurrency		&& Anterior valor de SET CURRENCY TO
		*p: cdate		&& Anterior valor de SET DATE TO
		*p: cdeleted
		*p: cdirectory		&& Almacena el directorio SET DEFAULT cuando se ejecutó el formulario y lo restaura después de cerrar el formulario.
		*p: centerform		&& Si es .T., Thisform.Autocenter se establece a .T.
		*p: chelpfile		&& Archivo de Ayuda para el ejemplo
		*p: coldhelp		&& archivo de Ayuda original
		*p: coldpath
		*p: cpoint		&& anterior valor de SET POINT TO
		*p: csep		&& Anterior valor de SET SEPARATOR TO
		*p: ctalk
		*p: fixedformborder		&& Si es .T., borderstyle del formulario se establece a .T.
		*p: lcalledbysolution
	*</DefinedPropArrayMethod>

	PROTECTED ccurrency,cdate,cdeleted,cdirectory,chelpfile,coldhelp,cpoint,csep,ctalk
	ccurrency = 		&& Anterior valor de SET CURRENCY TO
	cdate = 		&& Anterior valor de SET DATE TO
	cdeleted = 
	cdirectory = 		&& Almacena el directorio SET DEFAULT cuando se ejecutó el formulario y lo restaura después de cerrar el formulario.
	centerform = .T.		&& Si es .T., Thisform.Autocenter se establece a .T.
	chelpfile = solution.chm		&& Archivo de Ayuda para el ejemplo
	coldhelp = 		&& archivo de Ayuda original
	coldpath = 
	cpoint = 		&& anterior valor de SET POINT TO
	csep = 		&& Anterior valor de SET SEPARATOR TO
	ctalk = OFF
	fixedformborder = .T.		&& Si es .T., borderstyle del formulario se establece a .T.
	Height = 18
	Name = "c_solutions"
	Width = 25
	
	PROCEDURE addtopath
		LPARAMETERS TCPATH
		LOCAL LCPATH
		TCPATH = ALLTRIM(TCPATH)
		LCSETPATH = ALLTRIM(SET("PATH"))
		IF ATC(TCPATH, LCSETPATH)<>0
		DO CASE
		CASE ATC(TCPATH+";", LCSETPATH)<>0
		RETURN
		CASE ATC(ADDBS(TCPATH)+";", LCSETPATH)<>0
		RETURN
		CASE ATC(RIGHT(LCSETPATH, LEN(TCPATH)), TCPATH)<>0
		RETURN
		ENDCASE
		ENDIF
		IF EMPTY(LCSETPATH)
		SET PATH TO (TCPATH)
		ELSE
		SET PATH TO (LCSETPATH+IIF(RIGHT(LCSETPATH, 1)=";", "", ";")+TCPATH)
		ENDIF
	ENDPROC

	PROCEDURE Destroy
		CMACRO = THIS.CTALK
		SET TALK &CMACRO
		CMACRO = THIS.CDELETED
		SET DELETED &CMACRO
		SET POINT TO THIS.CPOINT
		SET SEPARATOR TO THIS.CSEP
		SET DATE TO (THIS.CDATE)
		SET CURRENCY TO THIS.CCURRENCY
		THIS.RESTOREHELP
		IF EMPTY(THIS.COLDPATH)
		SET PATH TO
		ELSE
		SET PATH TO (THIS.COLDPATH)
		ENDIF
		IF THIS.AUTOSETDEFAULT .AND.  .NOT. EMPTY(THIS.CDIRECTORY)
		SET DEFAULT TO (THIS.CDIRECTORY)
		ENDIF
		IF THIS.LCALLEDBYSOLUTION .AND.  .NOT. (TYPE('solution')='U' .OR. ISNULL(SOLUTION))
		SOLUTION.SHOW
		THISFORM.VISIBLE = .F.
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE getdirectory
		LPARAMETERS LCFILE
		IF TYPE("lcFile")="L"
		IF TYPE("THISFORM")="O"
		LCFILE = SYS(1271, THISFORM)
		ELSE
		LCFILE = SYS(16, 1)
		ENDIF
		ENDIF
		RETURN JUSTPATH(LCFILE)
	ENDPROC

	PROCEDURE Init
		LOCAL LCDIR, LCSAMPLEPATHS, LCHOME
		IF ATC("SOLUTIONS.", PROGRAM(PROGRAM(-1)-1))<>0
		THIS.LCALLEDBYSOLUTION = .T.
		ENDIF
		THISFORM.SHOWTIPS = .T.
		THISFORM.AUTOCENTER = THIS.CENTERFORM
		IF THIS.FIXEDFORMBORDER
		THISFORM.BORDERSTYLE = 2
		ENDIF
		THIS.COLDPATH = SET("PATH")
		LCDIR = THIS.GETDIRECTORY()
		LCHOME = HOME(2)
		THIS.ADDTOPATH(LCHOME+"CLASSES")
		THIS.ADDTOPATH(LCHOME+"SOLUTION")
		THIS.ADDTOPATH(LCDIR)
		THIS.CDIRECTORY = SET("DEFAULT")+CURDIR()
		IF THIS.AUTOSETDEFAULT
		SET DEFAULT TO (LCDIR)
		ENDIF
		THIS.CPOINT = SET("POINT")
		THIS.CSEP = SET("SEPARATOR")
		THIS.CDATE = SET("DATE")
		THIS.CCURRENCY = SET("CURRENCY", 1)
		THIS.CTALK = SET("TALK")
		THIS.CDELETED = SET("DELETED")
		SET POINT TO "."
		SET SEPARATOR TO ","
		SET DATE TO "MDY"
		SET CURRENCY TO "$"
		SET DELETED ON
		SET TALK OFF
	ENDPROC

	PROCEDURE restorehelp		&& Restaura el valor de archivo de Ayuda guardado anteriormente.
		IF  .NOT. EMPTY(THIS.COLDHELP)
		IF FILE(THIS.COLDHELP)
		SET HELP TO (THIS.COLDHELP)
		ELSE
		SET HELP TO EVALUATE(THIS.COLDHELP)
		ENDIF
		ENDIF
	ENDPROC

	PROCEDURE savehelp		&& Guarda el valor actual del archivo de Ayuda.
		IF  .NOT. "SOLUTION"$UPPER(SET("HELP", 1))
		THIS.COLDHELP = SET("HELP", 1)
		ENDIF
		IF  .NOT. EMPTY(THIS.CHELPFILE) .AND. FILE(THIS.CHELPFILE)
		SET HELP TO (THIS.CHELPFILE)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdclose AS commandbutton 		&& Botón Cerrar
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Cancel = .T.
	Caption = "Cerrar"
	FontBold = .F.
	FontName = "MS Sans Serif"
	FontSize = 8
	Height = 23
	Name = "cmdclose"
	Width = 72
	
	PROCEDURE Click
		IF TYPE("THISFORM.Parent")="O"
		THISFORMSET.RELEASE
		ELSE
		THISFORM.RELEASE
		ENDIF
	ENDPROC

	PROCEDURE Error
		LPARAMETERS NERROR, CMETHOD, NLINE
		LOCAL LNCHOICE
		DO CASE
		CASE NERROR=1545
		LNCHOICE = MESSAGEBOX("¿Desea guardar las modificaciones?", 0052, "Cambios sin confirmar")
		DO CASE
		CASE LNCHOICE=6
		= TABLEUPDATE(.T., .T.)
		CASE LNCHOICE=7
		= TABLEREVERT(.T.)
		ENDCASE
		OTHERWISE
		LCMSG = "Número de error: "+ALLTRIM(STR(NERROR))+CHR(13)+CHR(13)+MESSAGE()+CHR(13)+CHR(13)+"Programa: "+PROGRAM(1)
		LNCHOICE = MESSAGEBOX(LCMSG, 0562, "ERROR")
		DO CASE
		CASE LNCHOICE=3
		CANCEL
		CASE LNCHOICE=4
		RETRY
		CASE LNCHOICE=5
		RETURN
		ENDCASE
		ENDCASE
	ENDPROC

ENDDEFINE

DEFINE CLASS datachecker AS custom 		&& administra conflictos
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\classes\checker.bmp" ClassIcon="..\classes\checker.bmp" />

	*<DefinedPropArrayMethod>
		*m: checkconflicts		&& Notifica a un usuario si alguien más ha cambiado los datos de la tabla después de que él o ella empezara a modificar un registro.
		*m: handlerecord		&& compara el valor actual, el valor anterior y el valor original de cada campo, mostrando un cuadro de mensajes si se detecta un cambio o un conflicto.
		*m: string		&& devuelve el equivalente de tipo 'c' del valor pasado
		*m: verifychanges		&& Pregunta a un usuario si desea guardar todos los cambios realizados a una tabla o un registro.
		*m: verifyeachchange		&& Pide a un usuario que confirme cada cambio que ha realizado.
	*</DefinedPropArrayMethod>

	Height = 15
	Name = "datachecker"
	Width = 23
	
	PROCEDURE checkconflicts		&& Notifica a un usuario si alguien más ha cambiado los datos de la tabla después de que él o ella empezara a modificar un registro.
		LOCAL LNSUCCESS, LLNREC
		M.LNSUCCESS = 0
		DO CASE
		CASE INLIST(CURSORGETPROP('Buffering'), 2, 3)
		IF '2'$GETFLDSTATE(-1)
		M.LNSUCCESS = THIS.HANDLERECORD(0)
		ENDIF
		CASE INLIST(CURSORGETPROP('Buffering'), 4, 5)
		M.LLNREC = GETNEXTMODIFIED(0)
		DO WHILE M.LLNREC>0
		GOTO M.LLNREC
		M.LNSUCCESS = IIF(M.LNSUCCESS<>2, THIS.HANDLERECORD(0), 2)
		M.LLNREC = GETNEXTMODIFIED(M.LLNREC)
		ENDDO
		OTHERWISE
		WAIT WINDOW NOWAIT NOBUFF_LOC
		ENDCASE
		RETURN M.LNSUCCESS
	ENDPROC

	PROCEDURE handlerecord		&& compara el valor actual, el valor anterior y el valor original de cada campo, mostrando un cuadro de mensajes si se detecta un cambio o un conflicto.
		LPARAMETERS LNSCOPE
		IF TYPE("m.lnScope")<>"N"
		M.LNSCOPE = 0
		ENDIF
		IF  .NOT. BETWEEN(M.LNSCOPE, 0, 1)
		WAIT WINDOW "Se ha transferido un valor no válido a conflictmanager.handlerecord"
		ENDIF
		LOCAL LNCHOICE, LNFIELD, LCFIELD, LUOLDVAL, LUCURVAL, LUFIELD, LLMADECHANGE, LLSUCCESS
		M.LLMADECHANGE = .F.
		M.LLSUCCESS = .T.
		IF CURSORGETPROP('SourceType')<>3
		= REFRESH()
		ENDIF
		FOR M.LNFIELD = 1 TO FCOUNT()
		M.LNCHOICE = 0
		M.LCFIELD = FIELD(M.LNFIELD)
		IF TYPE(M.LCFIELD)="G"
		LOOP
		ENDIF
		M.LUOLDVAL = OLDVAL(M.LCFIELD)
		M.LUCURVAL = CURVAL(M.LCFIELD)
		DO CASE
		CASE M.LNSCOPE=0
		IF M.LUOLDVAL<>M.LUCURVAL
		M.LLMADECHANGE = .T.
		M.LNCHOICE = MESSAGEBOX("Otro usuario ha cambiado un valor."+CHR(13)+"Campo: "+LCFIELD+CHR(13)+"Número de registro: "+ALLTRIM(STR(RECNO()))+IIF(TYPE("m.lcField")<>"M", CHR(13)+CHR(13)+"Valor original: "+THIS.STRING(M.LUOLDVAL)+CHR(13)+"Valor actual: "+THIS.STRING(M.LUCURVAL)+CHR(13)+"Su cambio: "+THIS.STRING(EVALUATE(M.LCFIELD)), CHR(13)+CHR(13)+M.LCFIELD+" es un campo Memo.")+CHR(13)+CHR(13)+"¿Desea sobrescribir el valor actual con su cambio?"+CHR(13)+"(Elija 'Cancelar' para restaurar el valor original).", 0051, "Conflicto de datos")
		ENDIF
		CASE M.LNSCOPE=1
		M.LUFIELD = EVALUATE(M.LCFIELD)
		IF M.LUOLDVAL<>M.LUFIELD .OR. M.LUCURVAL<>M.LUFIELD
		M.LLMADECHANGE = .T.
		M.LNCHOICE = MESSAGEBOX("Se ha cambiado un valor."+CHR(13)+"Campo: "+M.LCFIELD+CHR(13)+"Número de registro: "+ALLTRIM(STR(RECNO()))+IIF(TYPE("m.lcField")<>"M", CHR(13)+CHR(13)+"Valor original: "+THIS.STRING(M.LUOLDVAL)+CHR(13)+"Valor actual: "+THIS.STRING(M.LUCURVAL)+CHR(13)+"Su cambio: "+THIS.STRING(EVALUATE(M.LCFIELD)), CHR(13)+CHR(13)+M.LCFIELD+" es un campo Memo.")+CHR(13)+CHR(13)+"¿Desea sobrescribir el valor actual con su cambio?"+CHR(13)+"(Elija 'Cancelar' para restaurar el valor original).", 0051, "Comprobar cambios")
		ENDIF
		ENDCASE
		DO CASE
		CASE M.LNCHOICE=7
		REPLACE (M.LCFIELD) WITH M.LUCURVAL
		CASE M.LNCHOICE=2
		REPLACE (M.LCFIELD) WITH M.LUOLDVAL
		ENDCASE
		ENDFOR
		IF M.LLMADECHANGE
		M.LLSUCCESS = TABLEUPDATE(.F., .T.)
		RETURN IIF(M.LLSUCCESS, 1, 2)
		ELSE
		RETURN 0
		ENDIF
	ENDPROC

	PROCEDURE string		&& devuelve el equivalente de tipo 'c' del valor pasado
		LPARAMETERS LUVALUE
		M.UTYPE = TYPE('m.luValue')
		DO CASE
		CASE M.UTYPE='C'
		RETURN ALLTRIM(M.LUVALUE)
		CASE INLIST(M.UTYPE, 'N', 'Y')
		RETURN ALLTRIM(STR(M.LUVALUE))
		CASE M.UTYPE='D'
		RETURN DTOC(M.LUVALUE)
		CASE M.UTYPE='T'
		RETURN TTOC('m.luValue')
		CASE M.UTYPE='L'
		RETURN IIF(M.LUVALUE, '.T.', '.F.')
		CASE UTYPE='M'
		RETURN 'Memo field'
		ENDCASE
	ENDPROC

	PROCEDURE verifychanges		&& Pregunta a un usuario si desea guardar todos los cambios realizados a una tabla o un registro.
		LOCAL LNCHOICE, LLMADECHANGE, LNSUCCESS
		M.LLMADECHANGE = .F.
		M.LNSUCCESS = 0
		DO CASE
		CASE INLIST(CURSORGETPROP('Buffering'), 2, 3)
		IF '2'$GETFLDSTATE(-1)
		M.LLMADECHANGE = .T.
		ENDIF
		CASE INLIST(CURSORGETPROP('Buffering'), 4, 5)
		IF GETNEXTMODIFIED(0)>0
		M.LLMADECHANGE = .T.
		ENDIF
		OTHERWISE
		WAIT WINDOW NOWAIT NOBUFF_LOC
		ENDCASE
		IF M.LLMADECHANGE
		M.LNCHOICE = MESSAGEBOX('¿Desea guardar sus cambios?', 036, 'Guardar cambios')
		IF M.LNCHOICE=6
		M.LNSUCCESS = IIF(TABLEUPDATE(.T., .T.), 1, 2)
		ELSE
		= TABLEREVERT(.T.)
		ENDIF
		ENDIF
		RETURN M.LNSUCCESS
	ENDPROC

	PROCEDURE verifyeachchange		&& Pide a un usuario que confirme cada cambio que ha realizado.
		LOCAL LNSUCCESS, LNREC
		M.LNSUCCESS = 0
		DO CASE
		CASE INLIST(CURSORGETPROP('Buffering'), 2, 3)
		IF '2'$GETFLDSTATE(-1)
		M.LNSUCCESS = THIS.HANDLERECORD(1)
		ENDIF
		CASE INLIST(CURSORGETPROP('Buffering'), 4, 5)
		M.LNREC = GETNEXTMODIFIED(0)
		DO WHILE M.LNREC>0
		GOTO M.LNREC
		M.LNSUCCESS = IIF(M.LNSUCCESS<>2, THIS.HANDLERECORD(1), 2)
		M.LNREC = GETNEXTMODIFIED(M.LNREC)
		ENDDO
		OTHERWISE
		WAIT WINDOW NOWAIT NOBUFF_LOC
		ENDCASE
		RETURN M.LNSUCCESS
	ENDPROC

ENDDEFINE

DEFINE CLASS formmargin AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackColor = 255,0,255
	Height = 253
	Left = 0
	Name = "Shape5"
	Top = 64
	Width = 10

ENDDEFINE

DEFINE CLASS frmsolution AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="C_solutions1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Behindscenes1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmdclose1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addtopath
		*p: csavesetpath
		*p: lsetffcpath
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "Solutions"
	csavesetpath = 
	DataSession = 2
	DoCreate = .T.
	Height = 197
	HelpContextID = 35
	MaxButton = .F.
	Name = "frmsolution"
	Width = 348

	ADD OBJECT 'Behindscenes1' AS behindscenes WITH ;
		Left = 9, ;
		Name = "Behindscenes1", ;
		TabIndex = 3, ;
		Top = 165
		*< END OBJECT: ClassLib="solution.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'C_solutions1' AS c_solutions WITH ;
		centerform = .F., ;
		Height = 18, ;
		Left = 309, ;
		Name = "C_solutions1", ;
		Top = 125, ;
		Width = 25
		*< END OBJECT: ClassLib="solution.vcx" BaseClass="custom" />

	ADD OBJECT 'Cmdclose1' AS cmdclose WITH ;
		Left = 265, ;
		Name = "Cmdclose1", ;
		TabIndex = 4, ;
		Top = 165
		*< END OBJECT: ClassLib="solution.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Label1' AS label WITH ;
		Caption = "Instrucciones de ejemplo", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 30, ;
		Left = 24, ;
		Name = "Label1", ;
		TabIndex = 0, ;
		Top = 24, ;
		Width = 300, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label4' AS label WITH ;
		Caption = "Instrucciones", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 16, ;
		Name = "Label4", ;
		TabIndex = 0, ;
		Top = 5, ;
		Width = 62
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		BackStyle = 0, ;
		Height = 48, ;
		Left = 12, ;
		Name = "Shape2", ;
		SpecialEffect = 0, ;
		Top = 12, ;
		Width = 324
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE Activate
		IF TYPE("THIS.c_solutions1.Baseclass")="C"
		THIS.C_SOLUTIONS1.SAVEHELP
		ENDIF
	ENDPROC

	PROCEDURE addtopath
		LPARAMETERS TCPATH
		LOCAL LCPATH
		TCPATH = ALLTRIM(TCPATH)
		LCSETPATH = ALLTRIM(SET("PATH"))
		IF ATC(TCPATH, LCSETPATH)<>0
		DO CASE
		CASE ATC(TCPATH+";", LCSETPATH)<>0
		RETURN
		CASE ATC(ADDBS(TCPATH)+";", LCSETPATH)<>0
		RETURN
		CASE ATC(RIGHT(LCSETPATH, LEN(TCPATH)), TCPATH)<>0
		RETURN
		ENDCASE
		ENDIF
		IF EMPTY(LCSETPATH)
		SET PATH TO (TCPATH)
		ELSE
		SET PATH TO (LCSETPATH+IIF(RIGHT(LCSETPATH, 1)=";", "", ";")+TCPATH)
		ENDIF
	ENDPROC

	PROCEDURE Deactivate
		IF TYPE("THIS.c_solutions1.Baseclass")="C"
		THIS.C_SOLUTIONS1.RESTOREHELP
		ENDIF
	ENDPROC

	PROCEDURE Init
		IF FONTMETRIC(1, 'MS Sans Serif', 8, '')<>13 .OR. FONTMETRIC(4, 'MS Sans Serif', 8, '')<>2 .OR. FONTMETRIC(6, 'MS Sans Serif', 8, '')<>5 .OR. FONTMETRIC(7, 'MS Sans Serif', 8, '')<>11
		THIS.SETALL('fontname', 'Arial')
		ELSE
		THIS.SETALL('fontname', 'MS Sans Serif')
		ENDIF
		THIS.SETALL('fontsize', 8)
	ENDPROC

	PROCEDURE Load
		IF THIS.LSETFFCPATH
		LOCAL LCFFCPATH
		THIS.CSAVESETPATH = SET("PATH")
		THIS.ADDTOPATH(HOME()+"FFC")
		THIS.ADDTOPATH(HOME()+"WIZARDS")
		THIS.ADDTOPATH(HOME()+"GALLERY")
		ENDIF
	ENDPROC

	PROCEDURE Unload
		SET MESSAGE TO
		IF THIS.LSETFFCPATH
		IF EMPTY(THIS.CSAVESETPATH)
		SET PATH TO
		ELSE
		SET PATH TO (THIS.CSAVESETPATH)
		ENDIF
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS resizable AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addtoarray
		*m: adjustcontrols		&& llamada desde el evento Resize de un formulario para ajustar la colocación y el tamaño de los objetos contenidos.
		*m: loopthroughcontrols
		*m: reset		&& Restablece el control Timer de forma que empiece a contar desde 0.
		*m: setposition
		*m: setsize
		*p: initialformheight
		*p: initialformwidth
		*p: initialresize		&& ¿Es la primera vez que se ajustan los controles?
		*p: repositionlist
		*p: resizelist
		*a: acontrolstats[1,5]
	*</DefinedPropArrayMethod>

	PROTECTED acontrolstats,initialformheight,initialformwidth,initialresize
	Height = 19
	initialformheight = 0
	initialformwidth = 0
	initialresize = .T.		&& ¿Es la primera vez que se ajustan los controles?
	Name = "resizable"
	repositionlist = Commandbutton tscombobox Checkbox Listbox Form Grid Textbox Label Shape Editbox Olecontrol Pageframe Image Spinner
	resizelist = Commandbutton tscombobox Checkbox Listbox Form Grid Textbox Label Shape Editbox Olecontrol Pageframe Image Spinner
	Width = 27
	
	PROTECTED PROCEDURE addtoarray
		LPARAMETERS OCONTROL
		NLEN = ALEN(THIS.ACONTROLSTATS, 1)
		THIS.ACONTROLSTATS[NLEN, 1] = OCONTROL.TOP/THIS.INITIALFORMHEIGHT
		THIS.ACONTROLSTATS[NLEN, 2] = OCONTROL.LEFT/THIS.INITIALFORMWIDTH
		THIS.ACONTROLSTATS[NLEN, 3] = OCONTROL.HEIGHT/THIS.INITIALFORMHEIGHT
		THIS.ACONTROLSTATS[NLEN, 4] = OCONTROL.WIDTH/THIS.INITIALFORMWIDTH
		THIS.ACONTROLSTATS[NLEN, 5] = IIF(TYPE("oControl.FontSize")='U', 0, OCONTROL.FONTSIZE)
		DIMENSION THIS.ACONTROLSTATS[NLEN+1, 5]
	ENDPROC

	PROCEDURE adjustcontrols		&& llamada desde el evento Resize de un formulario para ajustar la colocación y el tamaño de los objetos contenidos.
		IF THIS.INITIALRESIZE
		THIS.LOOPTHROUGHCONTROLS("INITIALIZE_AND_ADJUST")
		THIS.INITIALRESIZE = .F.
		ELSE
		THIS.LOOPTHROUGHCONTROLS("ADJUST")
		ENDIF
	ENDPROC

	PROCEDURE Init
		THIS.INITIALFORMHEIGHT = THISFORM.HEIGHT
		THIS.INITIALFORMWIDTH = THISFORM.WIDTH
	ENDPROC

	PROTECTED PROCEDURE loopthroughcontrols
		LPARAMETERS CTASK
		CTASK = UPPER(CTASK)
		NOLDDECIMAL = SET("DECIMAL")
		SET DECIMALS TO 18
		NPOS = 0
		THISFORM.LOCKSCREEN = .T.
		FOR M.I = 1 TO THISFORM.CONTROLCOUNT
		OCONTROL = THISFORM.CONTROLS(M.I)
		NPOS = NPOS+1
		IF CTASK='INITIALIZE_AND_ADJUST'
		THIS.ADDTOARRAY(OCONTROL)
		ENDIF
		IF OCONTROL.CLASS$THIS.RESIZELIST
		THIS.SETSIZE(OCONTROL, NPOS)
		ENDIF
		IF OCONTROL.CLASS$THIS.REPOSITIONLIST
		THIS.SETPOSITION(OCONTROL, NPOS)
		ENDIF
		IF THISFORM.CONTROLS(M.I).BASECLASS$"Pageframe"
		FOR M.J = 1 TO THISFORM.CONTROLS(M.I).PAGECOUNT
		WITH THISFORM.CONTROLS(M.I).PAGES(M.J)
		FOR M.K = 1 TO .CONTROLCOUNT
		NPOS = NPOS+1
		IF CTASK='INITIALIZE_AND_ADJUST'
		THIS.ADDTOARRAY(.CONTROLS(M.K))
		ENDIF
		IF OCONTROL.CLASS$THIS.RESIZELIST
		THIS.SETSIZE(OCONTROL, NPOS)
		ENDIF
		IF OCONTROL.CLASS$THIS.REPOSITIONLIST
		THIS.SETPOSITION(OCONTROL, NPOS)
		ENDIF
		ENDFOR
		ENDWITH
		ENDFOR
		ENDIF
		ENDFOR
		THISFORM.LOCKSCREEN = .F.
		SET DECIMALS TO NOLDDECIMAL
	ENDPROC

	PROCEDURE reset		&& Restablece el control Timer de forma que empiece a contar desde 0.
		THIS.INITIALRESIZE = .T.
		DIMENSION THIS.ACONTROLSTATS[1, 5]
		THIS.INITIALFORMHEIGHT = THISFORM.HEIGHT
		THIS.INITIALFORMWIDTH = THISFORM.WIDTH
	ENDPROC

	PROTECTED PROCEDURE setposition
		LPARAMETERS OCONTROL, NPOS
		OCONTROL.TOP = THISFORM.HEIGHT*THIS.ACONTROLSTATS(NPOS, 1)
		OCONTROL.LEFT = THISFORM.WIDTH*THIS.ACONTROLSTATS(NPOS, 2)
	ENDPROC

	PROTECTED PROCEDURE setsize
		LPARAMETERS OCONTROL, NPOS
		OCONTROL.WIDTH = THISFORM.WIDTH*THIS.ACONTROLSTATS(NPOS, 4)
		IF  .NOT. OCONTROL.BASECLASS$"Textbox Spinner"
		OCONTROL.HEIGHT = THISFORM.HEIGHT*THIS.ACONTROLSTATS(NPOS, 3)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS tbrbackcolor AS toolbar 
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdRed" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGreen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBlue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdWhite" UniqueID="" Timestamp="" />

	Caption = "Color de fondo del formulario"
	ControlBox = .F.
	Height = 32
	Left = 0
	Name = "tbrbackcolor"
	Top = 0
	Width = 103

	ADD OBJECT 'cmdBlue' AS commandbutton WITH ;
		Caption = "", ;
		Default = .F., ;
		Height = 23, ;
		Left = 52, ;
		Name = "cmdBlue", ;
		Picture = menus\blue.bmp, ;
		Top = 6, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdGreen' AS commandbutton WITH ;
		Caption = "", ;
		Default = .F., ;
		Height = 23, ;
		Left = 29, ;
		Name = "cmdGreen", ;
		Picture = menus\green.bmp, ;
		Top = 6, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRed' AS commandbutton WITH ;
		Caption = "", ;
		Default = .F., ;
		Height = 23, ;
		Left = 6, ;
		Name = "cmdRed", ;
		Picture = menus\red.bmp, ;
		Top = 6, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdWhite' AS commandbutton WITH ;
		Caption = "", ;
		Default = .F., ;
		Height = 23, ;
		Left = 75, ;
		Name = "cmdWhite", ;
		Picture = menus\white.bmp, ;
		Top = 6, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />
	
	PROCEDURE Destroy
		THIS.VISIBLE = .F.
	ENDPROC

	PROCEDURE cmdBlue.Click
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .T.
		_SCREEN.ACTIVEFORM.BACKCOLOR = RGB(0, 0, 255)
		_SCREEN.ACTIVEFORM.SETALL("ForeColor", RGB(255, 255, 255), "LABEL")
		_SCREEN.ACTIVEFORM.SETALL("BackColor", _SCREEN.ACTIVEFORM.BACKCOLOR, "LABEL")
		_SCREEN.ACTIVEFORM.SETALL("ForeColor", RGB(255, 255, 255), "CHECKBOX")
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .F.
	ENDPROC

	PROCEDURE cmdGreen.Click
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .T.
		_SCREEN.ACTIVEFORM.BACKCOLOR = RGB(0, 255, 0)
		_SCREEN.ACTIVEFORM.SETALL("ForeColor", RGB(0, 0, 0))
		_SCREEN.ACTIVEFORM.SETALL("BackColor", _SCREEN.ACTIVEFORM.BACKCOLOR, "LABEL")
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .F.
	ENDPROC

	PROCEDURE cmdRed.Click
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .T.
		_SCREEN.ACTIVEFORM.BACKCOLOR = RGB(255, 0, 0)
		_SCREEN.ACTIVEFORM.SETALL("ForeColor", RGB(255, 255, 255), "LABEL")
		_SCREEN.ACTIVEFORM.SETALL("BackColor", _SCREEN.ACTIVEFORM.BACKCOLOR, "LABEL")
		_SCREEN.ACTIVEFORM.SETALL("ForeColor", RGB(255, 255, 255), "CHECKBOX")
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .F.
	ENDPROC

	PROCEDURE cmdWhite.Click
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .T.
		_SCREEN.ACTIVEFORM.BACKCOLOR = RGB(255, 255, 255)
		_SCREEN.ACTIVEFORM.SETALL("ForeColor", RGB(0, 0, 0))
		_SCREEN.ACTIVEFORM.SETALL("BackColor", _SCREEN.ACTIVEFORM.BACKCOLOR, "LABEL")
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .F.
	ENDPROC

ENDDEFINE

DEFINE CLASS vcr AS container 		&& botones genéricos de vcr
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="next.bmp" ClassIcon="next.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrior" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNext" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBottom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Datachecker1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: beforerecordpointermoved
		*m: enabledisablebuttons
		*m: recordpointermoved		&& Método al que se llama cada vez que se mueve el puntero de registro y que proporciona básicamente un nuevo evento para la clase.
		*p: enabledisableoninit
		*p: skiptable		&& La tabla a la que se mueve el puntero de registro.
	*</DefinedPropArrayMethod>

	BackColor = 192,192,192
	BorderWidth = 1
	enabledisableoninit = .T.
	Height = 24
	Name = "vcr"
	skiptable = 		&& La tabla a la que se mueve el puntero de registro.
	Width = 104

	ADD OBJECT 'cmdBottom' AS commandbutton WITH ;
		Caption = ">|", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 24, ;
		Left = 78, ;
		Name = "cmdBottom", ;
		TabIndex = 4, ;
		ToolTipText = "Inferior", ;
		Top = 0, ;
		Width = 26
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdNext' AS commandbutton WITH ;
		Caption = ">", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 24, ;
		Left = 52, ;
		Name = "cmdNext", ;
		TabIndex = 3, ;
		ToolTipText = "Siguiente", ;
		Top = 0, ;
		Width = 26
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrior' AS commandbutton WITH ;
		Caption = "<", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 24, ;
		Left = 26, ;
		Name = "cmdPrior", ;
		TabIndex = 2, ;
		ToolTipText = "Anterior", ;
		Top = 0, ;
		Width = 26
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdTop' AS commandbutton WITH ;
		Caption = "|<", ;
		FontBold = .T., ;
		FontName = "Courier New", ;
		FontSize = 11, ;
		Height = 24, ;
		Left = 0, ;
		Name = "cmdTop", ;
		TabIndex = 1, ;
		ToolTipText = "Superior", ;
		Top = 0, ;
		Width = 26
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Datachecker1' AS datachecker WITH ;
		Height = 15, ;
		Left = 44, ;
		Name = "Datachecker1", ;
		Top = 6, ;
		Width = 23
		*< END OBJECT: ClassLib="solution.vcx" BaseClass="custom" />
	
	PROCEDURE beforerecordpointermoved
		IF  .NOT. EMPTY(THIS.SKIPTABLE)
		SELECT (THIS.SKIPTABLE)
		ENDIF
	ENDPROC

	PROCEDURE enabledisablebuttons
		LOCAL NREC, NTOP, NBOTTOM
		IF EOF()
		THIS.SETALL("Enabled", .F.)
		RETURN
		ENDIF
		NREC = RECNO()
		GOTO TOP
		NTOP = RECNO()
		GOTO BOTTOM
		NBOTTOM = RECNO()
		GOTO NREC
		DO CASE
		CASE NREC=NTOP
		THIS.CMDTOP.ENABLED = .F.
		THIS.CMDPRIOR.ENABLED = .F.
		THIS.CMDNEXT.ENABLED = .T.
		THIS.CMDBOTTOM.ENABLED = .T.
		CASE NREC=NBOTTOM
		THIS.CMDTOP.ENABLED = .T.
		THIS.CMDPRIOR.ENABLED = .T.
		THIS.CMDNEXT.ENABLED = .F.
		THIS.CMDBOTTOM.ENABLED = .F.
		OTHERWISE
		THIS.SETALL("Enabled", .T.)
		ENDCASE
	ENDPROC

	PROCEDURE Error
		PARAMETER NERROR, CMETHOD, NLINE
		DO CASE
		CASE NERROR=13
		CNEWTABLE = GETFILE('DBF', "Seleccione una tabla:", "Abrir")
		IF FILE(CNEWTABLE)
		SELECT 0
		USE (CNEWTABLE)
		THIS.SKIPTABLE = ALIAS()
		ELSE
		THIS.SKIPTABLE = ""
		ENDIF
		CASE NERROR=1585
		NCONFLICTSTATUS = THIS.DATACHECKER1.CHECKCONFLICTS()
		IF NCONFLICTSTATUS=2
		WAIT WINDOW "No se puede resolver el conflicto de datos."
		ENDIF
		OTHERWISE
		LCMSG = "Número de error: "+ALLTRIM(STR(NERROR))+CHR(13)+CHR(13)+"Mensaje de error: "+MESSAGE()+CHR(13)+CHR(13)+"Procedimiento: "+PROGRAM(1)
		LNANSWER = MESSAGEBOX(LCMSG, 0562)
		DO CASE
		CASE LNANSWER=3
		CANCEL
		CASE LNANSWER=4
		RETRY
		OTHERWISE
		RETURN
		ENDCASE
		ENDCASE
	ENDPROC

	PROCEDURE Init
		IF THIS.ENABLEDISABLEONINIT
		THIS.ENABLEDISABLEBUTTONS
		ENDIF
	ENDPROC

	PROCEDURE recordpointermoved		&& Método al que se llama cada vez que se mueve el puntero de registro y que proporciona básicamente un nuevo evento para la clase.
		IF TYPE('_VFP.ActiveForm')='O'
		_VFP.ACTIVEFORM.REFRESH
		ENDIF
	ENDPROC

	PROCEDURE cmdBottom.Click
		THIS.PARENT.BEFORERECORDPOINTERMOVED
		GOTO BOTTOM
		THIS.PARENT.ENABLEDISABLEBUTTONS
		THIS.PARENT.RECORDPOINTERMOVED
	ENDPROC

	PROCEDURE cmdBottom.Error
		PARAMETER NERROR, CMETHOD, NLINE
		THIS.PARENT.ERROR(NERROR, CMETHOD, NLINE)
	ENDPROC

	PROCEDURE cmdNext.Click
		THIS.PARENT.BEFORERECORDPOINTERMOVED
		SKIP 1
		IF EOF()
		GOTO BOTTOM
		ENDIF
		THIS.PARENT.RECORDPOINTERMOVED
		THIS.PARENT.ENABLEDISABLEBUTTONS
	ENDPROC

	PROCEDURE cmdNext.Error
		PARAMETER NERROR, CMETHOD, NLINE
		THIS.PARENT.ERROR(NERROR, CMETHOD, NLINE)
	ENDPROC

	PROCEDURE cmdPrior.Click
		THIS.PARENT.BEFORERECORDPOINTERMOVED
		SKIP -1
		IF BOF()
		GOTO TOP
		ENDIF
		THIS.PARENT.RECORDPOINTERMOVED
		THIS.PARENT.ENABLEDISABLEBUTTONS
	ENDPROC

	PROCEDURE cmdPrior.Error
		PARAMETER NERROR, CMETHOD, NLINE
		THIS.PARENT.ERROR(NERROR, CMETHOD, NLINE)
	ENDPROC

	PROCEDURE cmdTop.Click
		THIS.PARENT.BEFORERECORDPOINTERMOVED
		GOTO TOP
		THIS.PARENT.RECORDPOINTERMOVED
		THIS.PARENT.ENABLEDISABLEBUTTONS
	ENDPROC

	PROCEDURE cmdTop.Error
		PARAMETER NERROR, CMETHOD, NLINE
		THIS.PARENT.ERROR(NERROR, CMETHOD, NLINE)
	ENDPROC

ENDDEFINE
