*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="registry.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS filereg AS registry OF "registry.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\registry.h"
	*<DefinedPropArrayMethod>
		*m: getapplication		&& Retrieves application key.
		*m: getapppath		&& Checks and returns path of application associated with a particular extension (e.g., XLS, DOC).
		*m: getlatestversion		&& Returns latest version for a specified application.
	*</DefinedPropArrayMethod>

	Name = "filereg"
	
	PROCEDURE getapplication		&& Retrieves application key.
		LPARAMETERS CEXTNKEY, CAPPKEY, LSERVER
		LOCAL NERRNUM, COPTNAME
		COPTNAME = ""
		IF TYPE("m.lServer")="L" .AND. M.LSERVER
		THIS.CAPPPATHKEY = "\Protocol\StdFileEditing\Server"
		ELSE
		THIS.CAPPPATHKEY = "\Shell\Open\Command"
		ENDIF
		M.NERRNUM = THIS.OPENKEY(M.CEXTNKEY+THIS.CAPPPATHKEY)
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		NERRNUM = THIS.GETKEYVALUE(COPTNAME, @CAPPKEY)
		THIS.CLOSEKEY()
		RETURN M.NERRNUM
	ENDPROC

	PROCEDURE getapppath		&& Checks and returns path of application associated with a particular extension (e.g., XLS, DOC).
		LPARAMETERS CEXTENSION, CEXTNKEY, CAPPKEY, LSERVER
		LOCAL NERRNUM, COPTNAME
		COPTNAME = ""
		IF TYPE("m.cExtension")<>"C" .OR. LEN(M.CEXTENSION)>3
		RETURN -103
		ENDIF
		M.CEXTENSION = "."+M.CEXTENSION
		NERRNUM = THIS.OPENKEY(M.CEXTENSION)
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		NERRNUM = THIS.GETKEYVALUE(COPTNAME, @CEXTNKEY)
		THIS.CLOSEKEY()
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		RETURN THIS.GETAPPLICATION(CEXTNKEY, @CAPPKEY, LSERVER)
	ENDPROC

	PROCEDURE getlatestversion		&& Returns latest version for a specified application.
		LPARAMETERS CCLASS, CEXTNKEY, CAPPKEY, LSERVER
		LOCAL NERRNUM, COPTNAME
		COPTNAME = ""
		NERRNUM = THIS.OPENKEY(M.CCLASS+"\CurVer")
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		NERRNUM = THIS.GETKEYVALUE(COPTNAME, @CEXTNKEY)
		THIS.CLOSEKEY()
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		RETURN THIS.GETAPPLICATION(CEXTNKEY, @CAPPKEY, LSERVER)
	ENDPROC

ENDDEFINE

DEFINE CLASS foxreg AS registry OF "registry.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\registry.h"
	*<DefinedPropArrayMethod>
		*m: enumfoxoptions
		*m: getfoxoption		&& Retrieves an option from FoxPro registry settings.
		*m: setfoxoption		&& Sets an option from FoxPro registry settings.
	*</DefinedPropArrayMethod>

	Name = "foxreg"
	
	PROCEDURE enumfoxoptions
		LPARAMETERS AFOXOPTS
		RETURN THIS.ENUMOPTIONS(@AFOXOPTS, THIS.CVFPOPTPATH, THIS.NUSERKEY, .F.)
	ENDPROC

	PROCEDURE getfoxoption		&& Retrieves an option from FoxPro registry settings.
		LPARAMETERS COPTNAME, COPTVAL
		RETURN THIS.GETREGKEY(COPTNAME, @COPTVAL, THIS.CVFPOPTPATH, THIS.NUSERKEY)
	ENDPROC

	PROCEDURE setfoxoption		&& Sets an option from FoxPro registry settings.
		LPARAMETERS COPTNAME, COPTVAL
		RETURN THIS.SETREGKEY(COPTNAME, COPTVAL, THIS.CVFPOPTPATH, THIS.NUSERKEY)
	ENDPROC

ENDDEFINE

DEFINE CLASS odbcreg AS registry OF "registry.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\registry.h"
	*<DefinedPropArrayMethod>
		*m: enumodbcdata		&& Enumerates through ODBC data sources.
		*m: enumodbcdrvrs		&& Enumerates through ODBC drivers.
		*m: getodbcdrvrs		&& Retrieves ODBC drivers.
		*m: loadodbcfuncs		&& Loads ODBC registry functions.
	*</DefinedPropArrayMethod>

	Name = "odbcreg"
	
	PROCEDURE enumodbcdata		&& Enumerates through ODBC data sources.
		LPARAMETERS ADRVROPTS, CDATASOURCE
		LOCAL CSOURCEKEY
		CSOURCEKEY = "Software\ODBC\ODBC.INI\"+CDATASOURCE
		RETURN THIS.ENUMOPTIONS(@ADRVROPTS, M.CSOURCEKEY, -2147483647, .F.)
	ENDPROC

	PROCEDURE enumodbcdrvrs		&& Enumerates through ODBC drivers.
		LPARAMETERS ADRVROPTS, CODBCDRIVER
		LOCAL CSOURCEKEY
		CSOURCEKEY = "Software\ODBC\ODBCINST.INI\"+M.CODBCDRIVER
		RETURN THIS.ENUMOPTIONS(@ADRVROPTS, M.CSOURCEKEY, -2147483646, .F.)
	ENDPROC

	PROCEDURE getodbcdrvrs		&& Retrieves ODBC drivers.
		LPARAMETERS ADRVRS, LDATASOURCES
		LOCAL NODBCENV, NRETVAL, DSN, DSNDESC, MDSN, MDESC
		LDATASOURCES = IIF(TYPE("m.lDataSources")="L", M.LDATASOURCES, .F.)
		NRETVAL = THIS.LOADODBCFUNCS()
		IF M.NRETVAL<>0
		RETURN M.NRETVAL
		ENDIF
		NODBCENV = VAL(SYS(3053))
		IF INLIST(NODBCENV, 527, 528, 182)
		RETURN -113
		ENDIF
		DIMENSION ADRVRS[1, IIF(M.LDATASOURCES, 2, 1)]
		ADRVRS[1] = ""
		DO WHILE .T.
		DSN = SPACE(100)
		DSNDESC = SPACE(100)
		MDSN = 0
		MDESC = 0
		IF M.LDATASOURCES
		NRETVAL = SQLDATASOURCES(M.NODBCENV, 1, @DSN, 100, @MDSN, @DSNDESC, 255, @MDESC)
		ELSE
		NRETVAL = SQLDRIVERS(M.NODBCENV, 1, @DSN, 100, @MDSN, @DSNDESC, 100, @MDESC)
		ENDIF
		DO CASE
		CASE M.NRETVAL=100
		NRETVAL = 0
		EXIT
		CASE M.NRETVAL<>0 .AND. M.NRETVAL<>1
		EXIT
		OTHERWISE
		IF  .NOT. EMPTY(ADRVRS(1))
		IF M.LDATASOURCES
		DIMENSION ADRVRS[ALEN(ADRVRS, 1)+1, 2]
		ELSE
		DIMENSION ADRVRS[ALEN(ADRVRS, 1)+1, 1]
		ENDIF
		ENDIF
		DSN = ALLTRIM(M.DSN)
		ADRVRS[ALEN(ADRVRS, 1), 1] = LEFT(M.DSN, LEN(M.DSN)-1)
		IF M.LDATASOURCES
		DSNDESC = ALLTRIM(M.DSNDESC)
		ADRVRS[ALEN(ADRVRS, 1), 2] = LEFT(M.DSNDESC, LEN(M.DSNDESC)-1)
		ENDIF
		ENDCASE
		ENDDO
		RETURN NRETVAL
	ENDPROC

	PROCEDURE loadodbcfuncs		&& Loads ODBC registry functions.
		IF THIS.LLOADEDODBCS
		RETURN 0
		ENDIF
		IF EMPTY(THIS.CODBCDLLFILE)
		RETURN -112
		ENDIF
		LOCAL HENV, FDIRECTION, SZDRIVERDESC, CBDRIVERDESCMAX
		LOCAL PCBDRIVERDESC, SZDRIVERATTRIBUTES, CBDRVRATTRMAX, PCBDRVRATTR
		LOCAL SZDSN, CBDSNMAX, PCBDSN, SZDESCRIPTION, CBDESCRIPTIONMAX, PCBDESCRIPTION
		DECLARE SHORT SQLDrivers IN (THIS.CODBCDLLFILE) INTEGER, INTEGER, STRING @, INTEGER, INTEGER, STRING @, INTEGER, INTEGER
		IF THIS.LHADERROR
		RETURN -1
		ENDIF
		DECLARE SHORT SQLDataSources IN (THIS.CODBCDLLFILE) INTEGER, INTEGER, STRING @, INTEGER, INTEGER @, STRING @, INTEGER, INTEGER
		THIS.LLOADEDODBCS = .T.
		RETURN 0
	ENDPROC

ENDDEFINE

DEFINE CLASS oldinireg AS registry OF "registry.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\registry.h"
	*<DefinedPropArrayMethod>
		*m: getinientry		&& Retrieves information from INI entry.
		*m: getinisection		&& Retrieves information from INI section.
		*m: loadinifuncs		&& Loads functions needed for reading INI files.
		*m: writeinientry		&& Writes a specific INI entry.
	*</DefinedPropArrayMethod>

	Name = "oldinireg"
	
	PROCEDURE getinientry		&& Retrieves information from INI entry.
		LPARAMETERS CVALUE, CSECTION, CENTRY, CINIFILE
		LOCAL CBUFFER, NBUFSIZE, NERRNUM, NTOTPARMS
		NTOTPARMS = PCOUNT()
		NERRNUM = THIS.LOADINIFUNCS()
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		IF M.NTOTPARMS<3
		M.CENTRY = 0
		ENDIF
		M.CBUFFER = SPACE(2000)
		IF EMPTY(M.CINIFILE)
		M.NBUFSIZE = GETWININI(M.CSECTION, M.CENTRY, "", @CBUFFER, LEN(M.CBUFFER))
		ELSE
		M.NBUFSIZE = GETPRIVATEINI(M.CSECTION, M.CENTRY, "", @CBUFFER, LEN(M.CBUFFER), M.CINIFILE)
		ENDIF
		IF M.NBUFSIZE=0
		RETURN -109
		ENDIF
		M.CVALUE = LEFT(M.CBUFFER, M.NBUFSIZE)
		RETURN 0
	ENDPROC

	PROCEDURE getinisection		&& Retrieves information from INI section.
		LPARAMETERS ASECTIONS, CSECTION, CINIFILE
		LOCAL CINIVALUE, NTOTENTRIES, I, NLASTPOS
		CINIVALUE = ""
		IF TYPE("m.cINIFile")<>"C"
		CINIFILE = ""
		ENDIF
		IF THIS.GETINIENTRY(@CINIVALUE, CSECTION, 0, M.CINIFILE)<>0
		RETURN -110
		ENDIF
		NTOTENTRIES = OCCURS(CHR(0), M.CINIVALUE)
		DIMENSION ASECTIONS[M.NTOTENTRIES]
		NLASTPOS = 1
		FOR I = 1 TO M.NTOTENTRIES
		NTMPPOS = AT(CHR(0), M.CINIVALUE, M.I)
		ASECTIONS[M.I] = SUBSTR(M.CINIVALUE, M.NLASTPOS, M.NTMPPOS-M.NLASTPOS)
		NLASTPOS = M.NTMPPOS+1
		ENDFOR
		RETURN 0
	ENDPROC

	PROCEDURE loadinifuncs		&& Loads functions needed for reading INI files.
		IF THIS.LLOADEDINIS
		RETURN 0
		ENDIF
		DECLARE INTEGER GetPrivateProfileString IN Win32API AS GetPrivateINI STRING, STRING, STRING, STRING, INTEGER, STRING
		IF THIS.LHADERROR
		RETURN -1
		ENDIF
		DECLARE INTEGER GetProfileString IN Win32API AS GetWinINI STRING, STRING, STRING, STRING, INTEGER
		DECLARE INTEGER WriteProfileString IN Win32API AS WriteWinINI STRING, STRING, STRING
		DECLARE INTEGER WritePrivateProfileString IN Win32API AS WritePrivateINI STRING, STRING, STRING, STRING
		THIS.LLOADEDINIS = .T.
		RETURN 0
	ENDPROC

	PROCEDURE writeinientry		&& Writes a specific INI entry.
		LPARAMETERS CVALUE, CSECTION, CENTRY, CINIFILE
		LOCAL NERRNUM
		NERRNUM = THIS.LOADINIFUNCS()
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		IF EMPTY(M.CINIFILE)
		NERRNUM = WRITEWININI(M.CSECTION, M.CENTRY, M.CVALUE)
		ELSE
		NERRNUM = WRITEPRIVATEINI(M.CSECTION, M.CENTRY, M.CVALUE, M.CINIFILE)
		ENDIF
		RETURN IIF(M.NERRNUM=1, 0, M.NERRNUM)
	ENDPROC

ENDDEFINE

DEFINE CLASS registry AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\registry.h"
	*<DefinedPropArrayMethod>
		*m: closekey		&& Closes a registry key.
		*m: deletekey		&& Deletes a registry key.
		*m: deletekeyvalue		&& Deletes value from registry key.
		*m: enumkeys		&& Enumerates through a registry key.
		*m: enumkeyvalues		&& Enumerates through values of a registry key
		*m: enumoptions		&& Enumerates through all entries for a key and populates array.
		*m: getkeyvalue		&& Obtains a value from a registry key.
		*m: getregkey		&& Gets a registry key setting.
		*m: iskey		&& Checks to see if a key exists.
		*m: loadregfuncs		&& Loads funtions needed for Registry.
		*m: openkey		&& Opens a registry key.
		*m: setkeyvalue		&& Sets a key value.
		*m: setregkey		&& Sets a registry key setting.
		*p: capppathkey		&& Application path registry key.
		*p: cinidllfile		&& DLL file for INI functions.
		*p: codbcdllfile		&& DLL file for ODBC functions.
		*p: cregdllfile		&& DLL file for registry functions.
		*p: cvfpoptpath		&& Registry path to VFP options settings.
		*p: lcreatekey		&& Whether to create key if one does not already exist.
		*p: ldisallowexpanded
		*p: lhaderror		&& Whether an error occurred.
		*p: lhasdllloaded
		*p: lloadeddlls		&& Whether registry key functions loaded.
		*p: lloadedinis		&& Whether INI functions loaded.
		*p: lloadedodbcs		&& Whether ODBC functions loaded.
		*p: ncurrentkey		&& Current registry key.
		*p: ncurrentos		&& Current operating system code.
		*p: nuserkey		&& User registry key.
	*</DefinedPropArrayMethod>

	capppathkey = 		&& Application path registry key.
	cinidllfile = 		&& DLL file for INI functions.
	codbcdllfile = 		&& DLL file for ODBC functions.
	cregdllfile = 		&& DLL file for registry functions.
	cvfpoptpath = 		&& Registry path to VFP options settings.
	Name = "registry"
	ncurrentkey = 0		&& Current registry key.
	ncurrentos = 0		&& Current operating system code.
	nuserkey = 0		&& User registry key.
	
	PROCEDURE closekey		&& Closes a registry key.
		= REGCLOSEKEY(THIS.NCURRENTKEY)
		THIS.NCURRENTKEY = 0
	ENDPROC

	PROCEDURE deletekey		&& Deletes a registry key.
		LPARAMETERS NUSERKEY, CKEYPATH
		LOCAL NERRNUM
		NERRNUM = 0
		M.NERRNUM = REGDELETEKEY(M.NUSERKEY, M.CKEYPATH)
		RETURN M.NERRNUM
	ENDPROC

	PROCEDURE deletekeyvalue		&& Deletes value from registry key.
		LPARAMETERS COPTNAME, CKEYPATH, NUSERKEY
		LOCAL COPTION, NERRNUM
		COPTION = COPTNAME
		NERRNUM = 0
		M.NERRNUM = THIS.OPENKEY(M.CKEYPATH, M.NUSERKEY)
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		M.NERRNUM = REGDELETEVALUE(THIS.NCURRENTKEY, M.COPTION)
		THIS.CLOSEKEY()
		RETURN M.NERRNUM
	ENDPROC

	PROCEDURE Destroy
		IF  .NOT. THIS.LHASDLLLOADED
		CLEAR DLLS  'REGOPENKEY'
		CLEAR DLLS  'REGCREATEKEY'
		CLEAR DLLS  'REGDELETEKEY'
		CLEAR DLLS  'REGDELETEVALUE'
		CLEAR DLLS  'REGCLOSEKEY'
		CLEAR DLLS  'REGSETVALUEEX'
		CLEAR DLLS  'REGQUERYVALUEEX'
		CLEAR DLLS  'REGENUMKEY'
		CLEAR DLLS  'REGENUMKEYEX'
		CLEAR DLLS  'REGENUMVALUE'
		ENDIF
	ENDPROC

	PROCEDURE enumkeys		&& Enumerates through a registry key.
		LPARAMETERS AKEYNAMES
		LOCAL NKEYENTRY, CNEWKEY, CBUF, NBUFLEN, CRETTIME, NKEYSIZE, NERRCODE
		NKEYENTRY = 0
		DIMENSION AKEYNAMES[1]
		DO WHILE .T.
		NKEYSIZE = 0
		CNEWKEY = SPACE(100)
		NKEYSIZE = LEN(M.CNEWKEY)
		CBUF = SPACE(100)
		NBUFLEN = LEN(M.CBUF)
		CRETTIME = SPACE(100)
		M.NERRCODE = REGENUMKEYEX(THIS.NCURRENTKEY, M.NKEYENTRY, @CNEWKEY, @NKEYSIZE, 0, @CBUF, @NBUFLEN, @CRETTIME)
		DO CASE
		CASE M.NERRCODE=259
		EXIT
		CASE M.NERRCODE<>0
		EXIT
		ENDCASE
		CNEWKEY = ALLTRIM(M.CNEWKEY)
		CNEWKEY = LEFT(M.CNEWKEY, LEN(M.CNEWKEY)-1)
		IF  .NOT. EMPTY(AKEYNAMES(1))
		DIMENSION AKEYNAMES[ALEN(AKEYNAMES)+1]
		ENDIF
		AKEYNAMES[ALEN(AKEYNAMES)] = M.CNEWKEY
		NKEYENTRY = M.NKEYENTRY+1
		ENDDO
		IF M.NERRCODE=259 .AND. M.NKEYENTRY<>0
		M.NERRCODE = 0
		ENDIF
		RETURN M.NERRCODE
	ENDPROC

	PROCEDURE enumkeyvalues		&& Enumerates through values of a registry key
		LPARAMETERS AKEYVALUES
		LOCAL LPSZVALUE, LPCCHVALUE, LPDWRESERVED
		LOCAL LPDWTYPE, LPBDATA, LPCBDATA
		LOCAL NERRCODE, NKEYENTRY
		STORE 0 TO NKEYENTRY
		IF TYPE("THIS.nCurrentKey")<>'N' .OR. THIS.NCURRENTKEY=0
		RETURN -105
		ENDIF
		IF THIS.NCURRENTOS=1
		RETURN -107
		ENDIF
		DO WHILE .T.
		STORE 0 TO LPDWRESERVED, LPDWTYPE, NERRCODE
		STORE SPACE(256) TO LPBDATA, LPSZVALUE
		STORE LEN(LPBDATA) TO M.LPCCHVALUE
		STORE LEN(LPSZVALUE) TO M.LPCBDATA
		NERRCODE = REGENUMVALUE(THIS.NCURRENTKEY, M.NKEYENTRY, @LPSZVALUE, @LPCCHVALUE, M.LPDWRESERVED, @LPDWTYPE, @LPBDATA, @LPCBDATA)
		DO CASE
		CASE M.NERRCODE=259
		EXIT
		CASE M.NERRCODE<>0
		EXIT
		ENDCASE
		NKEYENTRY = M.NKEYENTRY+1
		DIMENSION AKEYVALUES[M.NKEYENTRY, 2]
		AKEYVALUES[M.NKEYENTRY, 1] = LEFT(M.LPSZVALUE, M.LPCCHVALUE)
		DO CASE
		CASE LPDWTYPE=1
		AKEYVALUES[M.NKEYENTRY, 2] = LEFT(M.LPBDATA, M.LPCBDATA-1)
		CASE LPDWTYPE=2 .AND.  .NOT. THIS.LDISALLOWEXPANDED
		AKEYVALUES[M.NKEYENTRY, 2] = LEFT(M.LPBDATA, M.LPCBDATA-1)
		CASE LPDWTYPE=3
		AKEYVALUES[M.NKEYENTRY, 2] = "*Binario*"
		CASE LPDWTYPE=4
		AKEYVALUES[M.NKEYENTRY, 2] = LEFT(M.LPBDATA, M.LPCBDATA-1)
		OTHERWISE
		AKEYVALUES[M.NKEYENTRY, 2] = "*Tipo desconocido*"
		ENDCASE
		ENDDO
		IF M.NERRCODE=259 .AND. M.NKEYENTRY<>0
		M.NERRCODE = 0
		ENDIF
		RETURN M.NERRCODE
	ENDPROC

	PROCEDURE enumoptions		&& Enumerates through all entries for a key and populates array.
		LPARAMETERS AREGOPTS, COPTPATH, NUSERKEY, LENUMKEYS
		LOCAL IPOS, COPTION, NERRNUM
		IPOS = 0
		COPTION = ""
		NERRNUM = 0
		IF PCOUNT()<4 .OR. TYPE("m.lEnumKeys")<>"L"
		LENUMKEYS = .F.
		ENDIF
		M.NERRNUM = THIS.OPENKEY(M.COPTPATH, M.NUSERKEY)
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		IF M.LENUMKEYS
		NERRNUM = THIS.ENUMKEYS(@AREGOPTS)
		ELSE
		NERRNUM = THIS.ENUMKEYVALUES(@AREGOPTS)
		ENDIF
		THIS.CLOSEKEY()
		RETURN M.NERRNUM
	ENDPROC

	PROCEDURE Error
		LPARAMETERS NERROR, CMETHOD, NLINE
		THIS.LHADERROR = .T.
		= MESSAGEBOX(MESSAGE())
	ENDPROC

	PROCEDURE getkeyvalue		&& Obtains a value from a registry key.
		LPARAMETERS CVALUENAME, CKEYVALUE
		LOCAL LPDWRESERVED, LPDWTYPE, LPBDATA, LPCBDATA, NERRCODE
		STORE 0 TO LPDWRESERVED, LPDWTYPE
		STORE SPACE(256) TO LPBDATA
		STORE LEN(M.LPBDATA) TO M.LPCBDATA
		DO CASE
		CASE TYPE("THIS.nCurrentKey")<>'N' .OR. THIS.NCURRENTKEY=0
		RETURN -105
		CASE TYPE("m.cValueName")<>"C"
		RETURN -103
		ENDCASE
		M.NERRCODE = REGQUERYVALUEEX(THIS.NCURRENTKEY, M.CVALUENAME, M.LPDWRESERVED, @LPDWTYPE, @LPBDATA, @LPCBDATA)
		IF M.NERRCODE<>0
		RETURN M.NERRCODE
		ENDIF
		IF M.LPDWTYPE<>1 .AND. M.LPDWTYPE<>2
		RETURN -106
		ENDIF
		M.CKEYVALUE = LEFT(M.LPBDATA, M.LPCBDATA-1)
		RETURN 0
	ENDPROC

	PROCEDURE getregkey		&& Gets a registry key setting.
		LPARAMETERS COPTNAME, COPTVAL, CKEYPATH, NUSERKEY
		LOCAL IPOS, COPTION, NERRNUM
		IPOS = 0
		COPTION = ""
		NERRNUM = 0
		M.NERRNUM = THIS.OPENKEY(M.CKEYPATH, M.NUSERKEY)
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		NERRNUM = THIS.GETKEYVALUE(COPTNAME, @COPTVAL)
		THIS.CLOSEKEY()
		RETURN M.NERRNUM
	ENDPROC

	PROCEDURE Init
		LOCAL LATMPDLLS, LNDLLS
		DIMENSION LATMPDLLS[1]
		THIS.NUSERKEY = -2147483647
		THIS.CVFPOPTPATH = "Software\Microsoft\VisualFoxPro\"+_VFP.VERSION+"\Options"
		DO CASE
		CASE _DOS .OR. _UNIX .OR. _MAC
		RETURN .F.
		CASE ATC("Windows 3", OS(1))<>0
		THIS.NCURRENTOS = 1
		CASE ATC("Windows NT", OS(1))<>0
		THIS.NCURRENTOS = 2
		THIS.CREGDLLFILE = "ADVAPI32.DLL"
		THIS.CINIDLLFILE = "KERNEL32.DLL"
		THIS.CODBCDLLFILE = "ODBC32.DLL"
		OTHERWISE
		THIS.NCURRENTOS = 3
		THIS.CREGDLLFILE = "ADVAPI32.DLL"
		THIS.CINIDLLFILE = "KERNEL32.DLL"
		THIS.CODBCDLLFILE = "ODBC32.DLL"
		ENDCASE
		LNDLLS = ADLLS(LATMPDLLS)
		IF LNDLLS>0
		IF ASCAN(LATMPDLLS, "RegOpenKey", -1, -1, -1, 1)<>0
		THIS.LHASDLLLOADED = .T.
		ENDIF
		ENDIF
	ENDPROC

	PROCEDURE iskey		&& Checks to see if a key exists.
		LPARAMETERS CKEYNAME, NREGKEY
		LOCAL NERRNUM
		NERRNUM = THIS.OPENKEY(M.CKEYNAME, M.NREGKEY)
		IF M.NERRNUM=0
		THIS.CLOSEKEY()
		ENDIF
		RETURN M.NERRNUM=0
	ENDPROC

	PROCEDURE loadregfuncs		&& Loads funtions needed for Registry.
		LOCAL NHKEY, CSUBKEY, NRESULT
		LOCAL HKEY, IVALUE, LPSZVALUE, LPCCHVALUE, LPDWTYPE, LPBDATA, LPCBDATA
		LOCAL LPCSTR, LPSZVAL, NLEN, LPDWRESERVED
		LOCAL LPSZVALUENAME, DWRESERVED, FDWTYPE
		LOCAL ISUBKEY, LPSZNAME, CCHNAME
		IF THIS.LLOADEDDLLS
		RETURN 0
		ENDIF
		DECLARE INTEGER RegOpenKey IN Win32API INTEGER, STRING @, INTEGER @
		IF THIS.LHADERROR
		RETURN -1
		ENDIF
		DECLARE INTEGER RegCreateKey IN Win32API INTEGER, STRING @, INTEGER @
		DECLARE INTEGER RegDeleteKey IN Win32API INTEGER, STRING @
		DECLARE INTEGER RegDeleteValue IN Win32API INTEGER, STRING
		DECLARE INTEGER RegCloseKey IN Win32API INTEGER
		DECLARE INTEGER RegSetValueEx IN Win32API INTEGER, STRING, INTEGER, INTEGER, STRING, INTEGER
		DECLARE INTEGER RegQueryValueEx IN Win32API INTEGER, STRING, INTEGER, INTEGER @, STRING @, INTEGER @
		DECLARE INTEGER RegEnumKey IN Win32API INTEGER, INTEGER, STRING @, INTEGER @
		DECLARE INTEGER RegEnumKeyEx IN Win32API INTEGER, INTEGER, STRING @, INTEGER @, INTEGER, STRING @, INTEGER @, STRING @
		DECLARE INTEGER RegEnumValue IN Win32API INTEGER, INTEGER, STRING @, INTEGER @, INTEGER, INTEGER @, STRING @, INTEGER @
		THIS.LLOADEDDLLS = .T.
		RETURN 0
	ENDPROC

	PROCEDURE openkey		&& Opens a registry key.
		LPARAMETERS CLOOKUPKEY, NREGKEY, LCREATEKEY
		LOCAL NSUBKEY, NERRCODE, NPCOUNT, LSAVECREATEKEY
		NSUBKEY = 0
		NPCOUNT = PCOUNT()
		IF TYPE("m.nRegKey")<>"N" .OR. EMPTY(M.NREGKEY)
		M.NREGKEY = -2147483648 
		ENDIF
		NERRCODE = THIS.LOADREGFUNCS()
		IF M.NERRCODE<>0
		RETURN M.NERRCODE
		ENDIF
		LSAVECREATEKEY = THIS.LCREATEKEY
		IF M.NPCOUNT>2 .AND. TYPE("m.lCreateKey")="L"
		THIS.LCREATEKEY = M.LCREATEKEY
		ENDIF
		IF THIS.LCREATEKEY
		NERRCODE = REGCREATEKEY(M.NREGKEY, M.CLOOKUPKEY, @NSUBKEY)
		ELSE
		NERRCODE = REGOPENKEY(M.NREGKEY, M.CLOOKUPKEY, @NSUBKEY)
		ENDIF
		THIS.LCREATEKEY = M.LSAVECREATEKEY
		IF NERRCODE<>0
		RETURN M.NERRCODE
		ENDIF
		THIS.NCURRENTKEY = M.NSUBKEY
		RETURN 0
	ENDPROC

	PROCEDURE setkeyvalue		&& Sets a key value.
		LPARAMETERS CVALUENAME, CVALUE
		LOCAL NVALUESIZE, NERRCODE
		DO CASE
		CASE TYPE("THIS.nCurrentKey")<>'N' .OR. THIS.NCURRENTKEY=0
		RETURN -105
		CASE TYPE("m.cValueName")<>"C" .OR. TYPE("m.cValue")<>"C"
		RETURN -103
		ENDCASE
		CVALUE = M.CVALUE+CHR(0)
		NVALUESIZE = LEN(M.CVALUE)
		M.NERRCODE = REGSETVALUEEX(THIS.NCURRENTKEY, M.CVALUENAME, 0, 1, M.CVALUE, M.NVALUESIZE)
		IF M.NERRCODE<>0
		RETURN M.NERRCODE
		ENDIF
		RETURN 0
	ENDPROC

	PROCEDURE setregkey		&& Sets a registry key setting.
		LPARAMETERS COPTNAME, COPTVAL, CKEYPATH, NUSERKEY, LCREATEKEY
		LOCAL IPOS, COPTKEY, COPTION, NERRNUM
		IPOS = 0
		COPTION = ""
		NERRNUM = 0
		M.NERRNUM = THIS.OPENKEY(M.CKEYPATH, M.NUSERKEY, M.LCREATEKEY)
		IF M.NERRNUM<>0
		RETURN M.NERRNUM
		ENDIF
		NERRNUM = THIS.SETKEYVALUE(M.COPTNAME, M.COPTVAL)
		THIS.CLOSEKEY()
		RETURN M.NERRNUM
	ENDPROC

ENDDEFINE
